var UT=Object.defineProperty;var VT=(t,s,n)=>s in t?UT(t,s,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[s]=n;var he=(t,s,n)=>VT(t,typeof s!="symbol"?s+"":s,n);(function(){const s=document.createElement("link").relList;if(s&&s.supports&&s.supports("modulepreload"))return;for(const l of document.querySelectorAll('link[rel="modulepreload"]'))i(l);new MutationObserver(l=>{for(const o of l)if(o.type==="childList")for(const c of o.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&i(c)}).observe(document,{childList:!0,subtree:!0});function n(l){const o={};return l.integrity&&(o.integrity=l.integrity),l.referrerPolicy&&(o.referrerPolicy=l.referrerPolicy),l.crossOrigin==="use-credentials"?o.credentials="include":l.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function i(l){if(l.ep)return;l.ep=!0;const o=n(l);fetch(l.href,o)}})();var pm={exports:{}},Sp={};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var zg;function GT(){if(zg)return Sp;zg=1;var t=Symbol.for("react.transitional.element"),s=Symbol.for("react.fragment");function n(i,l,o){var c=null;if(o!==void 0&&(c=""+o),l.key!==void 0&&(c=""+l.key),"key"in l){o={};for(var p in l)p!=="key"&&(o[p]=l[p])}else o=l;return l=o.ref,{$$typeof:t,type:i,key:c,ref:l!==void 0?l:null,props:o}}return Sp.Fragment=s,Sp.jsx=n,Sp.jsxs=n,Sp}var Fg;function WT(){return Fg||(Fg=1,pm.exports=GT()),pm.exports}var Wn=WT(),hm={exports:{}},Jt={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Lg;function HT(){if(Lg)return Jt;Lg=1;var t=Symbol.for("react.transitional.element"),s=Symbol.for("react.portal"),n=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),l=Symbol.for("react.profiler"),o=Symbol.for("react.consumer"),c=Symbol.for("react.context"),p=Symbol.for("react.forward_ref"),d=Symbol.for("react.suspense"),f=Symbol.for("react.memo"),g=Symbol.for("react.lazy"),_=Symbol.iterator;function y(W){return W===null||typeof W!="object"?null:(W=_&&W[_]||W["@@iterator"],typeof W=="function"?W:null)}var T={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},b=Object.assign,k={};function L(W,U,B){this.props=W,this.context=U,this.refs=k,this.updater=B||T}L.prototype.isReactComponent={},L.prototype.setState=function(W,U){if(typeof W!="object"&&typeof W!="function"&&W!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,W,U,"setState")},L.prototype.forceUpdate=function(W){this.updater.enqueueForceUpdate(this,W,"forceUpdate")};function C(){}C.prototype=L.prototype;function S(W,U,B){this.props=W,this.context=U,this.refs=k,this.updater=B||T}var I=S.prototype=new C;I.constructor=S,b(I,L.prototype),I.isPureReactComponent=!0;var O=Array.isArray,x={H:null,A:null,T:null,S:null,V:null},E=Object.prototype.hasOwnProperty;function A(W,U,B,Q,le,re){return B=re.ref,{$$typeof:t,type:W,key:U,ref:B!==void 0?B:null,props:re}}function F(W,U){return A(W.type,U,void 0,void 0,void 0,W.props)}function K(W){return typeof W=="object"&&W!==null&&W.$$typeof===t}function X(W){var U={"=":"=0",":":"=2"};return"$"+W.replace(/[=:]/g,function(B){return U[B]})}var oe=/\/+/g;function ie(W,U){return typeof W=="object"&&W!==null&&W.key!=null?X(""+W.key):U.toString(36)}function J(){}function ue(W){switch(W.status){case"fulfilled":return W.value;case"rejected":throw W.reason;default:switch(typeof W.status=="string"?W.then(J,J):(W.status="pending",W.then(function(U){W.status==="pending"&&(W.status="fulfilled",W.value=U)},function(U){W.status==="pending"&&(W.status="rejected",W.reason=U)})),W.status){case"fulfilled":return W.value;case"rejected":throw W.reason}}throw W}function ne(W,U,B,Q,le){var re=typeof W;(re==="undefined"||re==="boolean")&&(W=null);var ve=!1;if(W===null)ve=!0;else switch(re){case"bigint":case"string":case"number":ve=!0;break;case"object":switch(W.$$typeof){case t:case s:ve=!0;break;case g:return ve=W._init,ne(ve(W._payload),U,B,Q,le)}}if(ve)return le=le(W),ve=Q===""?"."+ie(W,0):Q,O(le)?(B="",ve!=null&&(B=ve.replace(oe,"$&/")+"/"),ne(le,U,B,"",function(ut){return ut})):le!=null&&(K(le)&&(le=F(le,B+(le.key==null||W&&W.key===le.key?"":(""+le.key).replace(oe,"$&/")+"/")+ve)),U.push(le)),1;ve=0;var Se=Q===""?".":Q+":";if(O(W))for(var Be=0;Be<W.length;Be++)Q=W[Be],re=Se+ie(Q,Be),ve+=ne(Q,U,B,re,le);else if(Be=y(W),typeof Be=="function")for(W=Be.call(W),Be=0;!(Q=W.next()).done;)Q=Q.value,re=Se+ie(Q,Be++),ve+=ne(Q,U,B,re,le);else if(re==="object"){if(typeof W.then=="function")return ne(ue(W),U,B,Q,le);throw U=String(W),Error("Objects are not valid as a React child (found: "+(U==="[object Object]"?"object with keys {"+Object.keys(W).join(", ")+"}":U)+"). If you meant to render a collection of children, use an array instead.")}return ve}function G(W,U,B){if(W==null)return W;var Q=[],le=0;return ne(W,Q,"","",function(re){return U.call(B,re,le++)}),Q}function se(W){if(W._status===-1){var U=W._result;U=U(),U.then(function(B){(W._status===0||W._status===-1)&&(W._status=1,W._result=B)},function(B){(W._status===0||W._status===-1)&&(W._status=2,W._result=B)}),W._status===-1&&(W._status=0,W._result=U)}if(W._status===1)return W._result.default;throw W._result}var ce=typeof reportError=="function"?reportError:function(W){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var U=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof W=="object"&&W!==null&&typeof W.message=="string"?String(W.message):String(W),error:W});if(!window.dispatchEvent(U))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",W);return}console.error(W)};function ge(){}return Jt.Children={map:G,forEach:function(W,U,B){G(W,function(){U.apply(this,arguments)},B)},count:function(W){var U=0;return G(W,function(){U++}),U},toArray:function(W){return G(W,function(U){return U})||[]},only:function(W){if(!K(W))throw Error("React.Children.only expected to receive a single React element child.");return W}},Jt.Component=L,Jt.Fragment=n,Jt.Profiler=l,Jt.PureComponent=S,Jt.StrictMode=i,Jt.Suspense=d,Jt.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=x,Jt.__COMPILER_RUNTIME={__proto__:null,c:function(W){return x.H.useMemoCache(W)}},Jt.cache=function(W){return function(){return W.apply(null,arguments)}},Jt.cloneElement=function(W,U,B){if(W==null)throw Error("The argument must be a React element, but you passed "+W+".");var Q=b({},W.props),le=W.key,re=void 0;if(U!=null)for(ve in U.ref!==void 0&&(re=void 0),U.key!==void 0&&(le=""+U.key),U)!E.call(U,ve)||ve==="key"||ve==="__self"||ve==="__source"||ve==="ref"&&U.ref===void 0||(Q[ve]=U[ve]);var ve=arguments.length-2;if(ve===1)Q.children=B;else if(1<ve){for(var Se=Array(ve),Be=0;Be<ve;Be++)Se[Be]=arguments[Be+2];Q.children=Se}return A(W.type,le,void 0,void 0,re,Q)},Jt.createContext=function(W){return W={$$typeof:c,_currentValue:W,_currentValue2:W,_threadCount:0,Provider:null,Consumer:null},W.Provider=W,W.Consumer={$$typeof:o,_context:W},W},Jt.createElement=function(W,U,B){var Q,le={},re=null;if(U!=null)for(Q in U.key!==void 0&&(re=""+U.key),U)E.call(U,Q)&&Q!=="key"&&Q!=="__self"&&Q!=="__source"&&(le[Q]=U[Q]);var ve=arguments.length-2;if(ve===1)le.children=B;else if(1<ve){for(var Se=Array(ve),Be=0;Be<ve;Be++)Se[Be]=arguments[Be+2];le.children=Se}if(W&&W.defaultProps)for(Q in ve=W.defaultProps,ve)le[Q]===void 0&&(le[Q]=ve[Q]);return A(W,re,void 0,void 0,null,le)},Jt.createRef=function(){return{current:null}},Jt.forwardRef=function(W){return{$$typeof:p,render:W}},Jt.isValidElement=K,Jt.lazy=function(W){return{$$typeof:g,_payload:{_status:-1,_result:W},_init:se}},Jt.memo=function(W,U){return{$$typeof:f,type:W,compare:U===void 0?null:U}},Jt.startTransition=function(W){var U=x.T,B={};x.T=B;try{var Q=W(),le=x.S;le!==null&&le(B,Q),typeof Q=="object"&&Q!==null&&typeof Q.then=="function"&&Q.then(ge,ce)}catch(re){ce(re)}finally{x.T=U}},Jt.unstable_useCacheRefresh=function(){return x.H.useCacheRefresh()},Jt.use=function(W){return x.H.use(W)},Jt.useActionState=function(W,U,B){return x.H.useActionState(W,U,B)},Jt.useCallback=function(W,U){return x.H.useCallback(W,U)},Jt.useContext=function(W){return x.H.useContext(W)},Jt.useDebugValue=function(){},Jt.useDeferredValue=function(W,U){return x.H.useDeferredValue(W,U)},Jt.useEffect=function(W,U,B){var Q=x.H;if(typeof B=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return Q.useEffect(W,U)},Jt.useId=function(){return x.H.useId()},Jt.useImperativeHandle=function(W,U,B){return x.H.useImperativeHandle(W,U,B)},Jt.useInsertionEffect=function(W,U){return x.H.useInsertionEffect(W,U)},Jt.useLayoutEffect=function(W,U){return x.H.useLayoutEffect(W,U)},Jt.useMemo=function(W,U){return x.H.useMemo(W,U)},Jt.useOptimistic=function(W,U){return x.H.useOptimistic(W,U)},Jt.useReducer=function(W,U,B){return x.H.useReducer(W,U,B)},Jt.useRef=function(W){return x.H.useRef(W)},Jt.useState=function(W){return x.H.useState(W)},Jt.useSyncExternalStore=function(W,U,B){return x.H.useSyncExternalStore(W,U,B)},Jt.useTransition=function(){return x.H.useTransition()},Jt.version="19.1.0",Jt}var Bg;function k_(){return Bg||(Bg=1,hm.exports=HT()),hm.exports}var ks=k_(),mm={exports:{}},Cp={},_m={exports:{}},gm={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Rg;function KT(){return Rg||(Rg=1,function(t){function s(G,se){var ce=G.length;G.push(se);e:for(;0<ce;){var ge=ce-1>>>1,W=G[ge];if(0<l(W,se))G[ge]=se,G[ce]=W,ce=ge;else break e}}function n(G){return G.length===0?null:G[0]}function i(G){if(G.length===0)return null;var se=G[0],ce=G.pop();if(ce!==se){G[0]=ce;e:for(var ge=0,W=G.length,U=W>>>1;ge<U;){var B=2*(ge+1)-1,Q=G[B],le=B+1,re=G[le];if(0>l(Q,ce))le<W&&0>l(re,Q)?(G[ge]=re,G[le]=ce,ge=le):(G[ge]=Q,G[B]=ce,ge=B);else if(le<W&&0>l(re,ce))G[ge]=re,G[le]=ce,ge=le;else break e}}return se}function l(G,se){var ce=G.sortIndex-se.sortIndex;return ce!==0?ce:G.id-se.id}if(t.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var o=performance;t.unstable_now=function(){return o.now()}}else{var c=Date,p=c.now();t.unstable_now=function(){return c.now()-p}}var d=[],f=[],g=1,_=null,y=3,T=!1,b=!1,k=!1,L=!1,C=typeof setTimeout=="function"?setTimeout:null,S=typeof clearTimeout=="function"?clearTimeout:null,I=typeof setImmediate<"u"?setImmediate:null;function O(G){for(var se=n(f);se!==null;){if(se.callback===null)i(f);else if(se.startTime<=G)i(f),se.sortIndex=se.expirationTime,s(d,se);else break;se=n(f)}}function x(G){if(k=!1,O(G),!b)if(n(d)!==null)b=!0,E||(E=!0,ie());else{var se=n(f);se!==null&&ne(x,se.startTime-G)}}var E=!1,A=-1,F=5,K=-1;function X(){return L?!0:!(t.unstable_now()-K<F)}function oe(){if(L=!1,E){var G=t.unstable_now();K=G;var se=!0;try{e:{b=!1,k&&(k=!1,S(A),A=-1),T=!0;var ce=y;try{t:{for(O(G),_=n(d);_!==null&&!(_.expirationTime>G&&X());){var ge=_.callback;if(typeof ge=="function"){_.callback=null,y=_.priorityLevel;var W=ge(_.expirationTime<=G);if(G=t.unstable_now(),typeof W=="function"){_.callback=W,O(G),se=!0;break t}_===n(d)&&i(d),O(G)}else i(d);_=n(d)}if(_!==null)se=!0;else{var U=n(f);U!==null&&ne(x,U.startTime-G),se=!1}}break e}finally{_=null,y=ce,T=!1}se=void 0}}finally{se?ie():E=!1}}}var ie;if(typeof I=="function")ie=function(){I(oe)};else if(typeof MessageChannel<"u"){var J=new MessageChannel,ue=J.port2;J.port1.onmessage=oe,ie=function(){ue.postMessage(null)}}else ie=function(){C(oe,0)};function ne(G,se){A=C(function(){G(t.unstable_now())},se)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(G){G.callback=null},t.unstable_forceFrameRate=function(G){0>G||125<G?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):F=0<G?Math.floor(1e3/G):5},t.unstable_getCurrentPriorityLevel=function(){return y},t.unstable_next=function(G){switch(y){case 1:case 2:case 3:var se=3;break;default:se=y}var ce=y;y=se;try{return G()}finally{y=ce}},t.unstable_requestPaint=function(){L=!0},t.unstable_runWithPriority=function(G,se){switch(G){case 1:case 2:case 3:case 4:case 5:break;default:G=3}var ce=y;y=G;try{return se()}finally{y=ce}},t.unstable_scheduleCallback=function(G,se,ce){var ge=t.unstable_now();switch(typeof ce=="object"&&ce!==null?(ce=ce.delay,ce=typeof ce=="number"&&0<ce?ge+ce:ge):ce=ge,G){case 1:var W=-1;break;case 2:W=250;break;case 5:W=1073741823;break;case 4:W=1e4;break;default:W=5e3}return W=ce+W,G={id:g++,callback:se,priorityLevel:G,startTime:ce,expirationTime:W,sortIndex:-1},ce>ge?(G.sortIndex=ce,s(f,G),n(d)===null&&G===n(f)&&(k?(S(A),A=-1):k=!0,ne(x,ce-ge))):(G.sortIndex=W,s(d,G),b||T||(b=!0,E||(E=!0,ie()))),G},t.unstable_shouldYield=X,t.unstable_wrapCallback=function(G){var se=y;return function(){var ce=y;y=se;try{return G.apply(this,arguments)}finally{y=ce}}}}(gm)),gm}var Ng;function qT(){return Ng||(Ng=1,_m.exports=KT()),_m.exports}var ym={exports:{}},ps={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jg;function QT(){if(jg)return ps;jg=1;var t=k_();function s(d){var f="https://react.dev/errors/"+d;if(1<arguments.length){f+="?args[]="+encodeURIComponent(arguments[1]);for(var g=2;g<arguments.length;g++)f+="&args[]="+encodeURIComponent(arguments[g])}return"Minified React error #"+d+"; visit "+f+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function n(){}var i={d:{f:n,r:function(){throw Error(s(522))},D:n,C:n,L:n,m:n,X:n,S:n,M:n},p:0,findDOMNode:null},l=Symbol.for("react.portal");function o(d,f,g){var _=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:l,key:_==null?null:""+_,children:d,containerInfo:f,implementation:g}}var c=t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function p(d,f){if(d==="font")return"";if(typeof f=="string")return f==="use-credentials"?f:""}return ps.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=i,ps.createPortal=function(d,f){var g=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!f||f.nodeType!==1&&f.nodeType!==9&&f.nodeType!==11)throw Error(s(299));return o(d,f,null,g)},ps.flushSync=function(d){var f=c.T,g=i.p;try{if(c.T=null,i.p=2,d)return d()}finally{c.T=f,i.p=g,i.d.f()}},ps.preconnect=function(d,f){typeof d=="string"&&(f?(f=f.crossOrigin,f=typeof f=="string"?f==="use-credentials"?f:"":void 0):f=null,i.d.C(d,f))},ps.prefetchDNS=function(d){typeof d=="string"&&i.d.D(d)},ps.preinit=function(d,f){if(typeof d=="string"&&f&&typeof f.as=="string"){var g=f.as,_=p(g,f.crossOrigin),y=typeof f.integrity=="string"?f.integrity:void 0,T=typeof f.fetchPriority=="string"?f.fetchPriority:void 0;g==="style"?i.d.S(d,typeof f.precedence=="string"?f.precedence:void 0,{crossOrigin:_,integrity:y,fetchPriority:T}):g==="script"&&i.d.X(d,{crossOrigin:_,integrity:y,fetchPriority:T,nonce:typeof f.nonce=="string"?f.nonce:void 0})}},ps.preinitModule=function(d,f){if(typeof d=="string")if(typeof f=="object"&&f!==null){if(f.as==null||f.as==="script"){var g=p(f.as,f.crossOrigin);i.d.M(d,{crossOrigin:g,integrity:typeof f.integrity=="string"?f.integrity:void 0,nonce:typeof f.nonce=="string"?f.nonce:void 0})}}else f==null&&i.d.M(d)},ps.preload=function(d,f){if(typeof d=="string"&&typeof f=="object"&&f!==null&&typeof f.as=="string"){var g=f.as,_=p(g,f.crossOrigin);i.d.L(d,g,{crossOrigin:_,integrity:typeof f.integrity=="string"?f.integrity:void 0,nonce:typeof f.nonce=="string"?f.nonce:void 0,type:typeof f.type=="string"?f.type:void 0,fetchPriority:typeof f.fetchPriority=="string"?f.fetchPriority:void 0,referrerPolicy:typeof f.referrerPolicy=="string"?f.referrerPolicy:void 0,imageSrcSet:typeof f.imageSrcSet=="string"?f.imageSrcSet:void 0,imageSizes:typeof f.imageSizes=="string"?f.imageSizes:void 0,media:typeof f.media=="string"?f.media:void 0})}},ps.preloadModule=function(d,f){if(typeof d=="string")if(f){var g=p(f.as,f.crossOrigin);i.d.m(d,{as:typeof f.as=="string"&&f.as!=="script"?f.as:void 0,crossOrigin:g,integrity:typeof f.integrity=="string"?f.integrity:void 0})}else i.d.m(d)},ps.requestFormReset=function(d){i.d.r(d)},ps.unstable_batchedUpdates=function(d,f){return d(f)},ps.useFormState=function(d,f,g){return c.H.useFormState(d,f,g)},ps.useFormStatus=function(){return c.H.useHostTransitionStatus()},ps.version="19.1.0",ps}var Ug;function XT(){if(Ug)return ym.exports;Ug=1;function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(s){console.error(s)}}return t(),ym.exports=QT(),ym.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Vg;function YT(){if(Vg)return Cp;Vg=1;var t=qT(),s=k_(),n=XT();function i(e){var r="https://react.dev/errors/"+e;if(1<arguments.length){r+="?args[]="+encodeURIComponent(arguments[1]);for(var a=2;a<arguments.length;a++)r+="&args[]="+encodeURIComponent(arguments[a])}return"Minified React error #"+e+"; visit "+r+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function l(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function o(e){var r=e,a=e;if(e.alternate)for(;r.return;)r=r.return;else{e=r;do r=e,(r.flags&4098)!==0&&(a=r.return),e=r.return;while(e)}return r.tag===3?a:null}function c(e){if(e.tag===13){var r=e.memoizedState;if(r===null&&(e=e.alternate,e!==null&&(r=e.memoizedState)),r!==null)return r.dehydrated}return null}function p(e){if(o(e)!==e)throw Error(i(188))}function d(e){var r=e.alternate;if(!r){if(r=o(e),r===null)throw Error(i(188));return r!==e?null:e}for(var a=e,u=r;;){var m=a.return;if(m===null)break;var v=m.alternate;if(v===null){if(u=m.return,u!==null){a=u;continue}break}if(m.child===v.child){for(v=m.child;v;){if(v===a)return p(m),e;if(v===u)return p(m),r;v=v.sibling}throw Error(i(188))}if(a.return!==u.return)a=m,u=v;else{for(var j=!1,Y=m.child;Y;){if(Y===a){j=!0,a=m,u=v;break}if(Y===u){j=!0,u=m,a=v;break}Y=Y.sibling}if(!j){for(Y=v.child;Y;){if(Y===a){j=!0,a=v,u=m;break}if(Y===u){j=!0,u=v,a=m;break}Y=Y.sibling}if(!j)throw Error(i(189))}}if(a.alternate!==u)throw Error(i(190))}if(a.tag!==3)throw Error(i(188));return a.stateNode.current===a?e:r}function f(e){var r=e.tag;if(r===5||r===26||r===27||r===6)return e;for(e=e.child;e!==null;){if(r=f(e),r!==null)return r;e=e.sibling}return null}var g=Object.assign,_=Symbol.for("react.element"),y=Symbol.for("react.transitional.element"),T=Symbol.for("react.portal"),b=Symbol.for("react.fragment"),k=Symbol.for("react.strict_mode"),L=Symbol.for("react.profiler"),C=Symbol.for("react.provider"),S=Symbol.for("react.consumer"),I=Symbol.for("react.context"),O=Symbol.for("react.forward_ref"),x=Symbol.for("react.suspense"),E=Symbol.for("react.suspense_list"),A=Symbol.for("react.memo"),F=Symbol.for("react.lazy"),K=Symbol.for("react.activity"),X=Symbol.for("react.memo_cache_sentinel"),oe=Symbol.iterator;function ie(e){return e===null||typeof e!="object"?null:(e=oe&&e[oe]||e["@@iterator"],typeof e=="function"?e:null)}var J=Symbol.for("react.client.reference");function ue(e){if(e==null)return null;if(typeof e=="function")return e.$$typeof===J?null:e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case b:return"Fragment";case L:return"Profiler";case k:return"StrictMode";case x:return"Suspense";case E:return"SuspenseList";case K:return"Activity"}if(typeof e=="object")switch(e.$$typeof){case T:return"Portal";case I:return(e.displayName||"Context")+".Provider";case S:return(e._context.displayName||"Context")+".Consumer";case O:var r=e.render;return e=e.displayName,e||(e=r.displayName||r.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case A:return r=e.displayName||null,r!==null?r:ue(e.type)||"Memo";case F:r=e._payload,e=e._init;try{return ue(e(r))}catch{}}return null}var ne=Array.isArray,G=s.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,se=n.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,ce={pending:!1,data:null,method:null,action:null},ge=[],W=-1;function U(e){return{current:e}}function B(e){0>W||(e.current=ge[W],ge[W]=null,W--)}function Q(e,r){W++,ge[W]=e.current,e.current=r}var le=U(null),re=U(null),ve=U(null),Se=U(null);function Be(e,r){switch(Q(ve,r),Q(re,e),Q(le,null),r.nodeType){case 9:case 11:e=(e=r.documentElement)&&(e=e.namespaceURI)?ug(e):0;break;default:if(e=r.tagName,r=r.namespaceURI)r=ug(r),e=cg(r,e);else switch(e){case"svg":e=1;break;case"math":e=2;break;default:e=0}}B(le),Q(le,e)}function ut(){B(le),B(re),B(ve)}function Oe(e){e.memoizedState!==null&&Q(Se,e);var r=le.current,a=cg(r,e.type);r!==a&&(Q(re,e),Q(le,a))}function ae(e){re.current===e&&(B(le),B(re)),Se.current===e&&(B(Se),wp._currentValue=ce)}var Z=Object.prototype.hasOwnProperty,Ee=t.unstable_scheduleCallback,Ve=t.unstable_cancelCallback,Ue=t.unstable_shouldYield,qe=t.unstable_requestPaint,We=t.unstable_now,nt=t.unstable_getCurrentPriorityLevel,at=t.unstable_ImmediatePriority,ct=t.unstable_UserBlockingPriority,V=t.unstable_NormalPriority,fe=t.unstable_LowPriority,q=t.unstable_IdlePriority,pe=t.log,we=t.unstable_setDisableYieldValue,Fe=null,De=null;function rt(e){if(typeof pe=="function"&&we(e),De&&typeof De.setStrictMode=="function")try{De.setStrictMode(Fe,e)}catch{}}var He=Math.clz32?Math.clz32:_t,it=Math.log,mt=Math.LN2;function _t(e){return e>>>=0,e===0?32:31-(it(e)/mt|0)|0}var Ot=256,Ft=4194304;function Dn(e){var r=e&42;if(r!==0)return r;switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return e&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return e}}function hn(e,r,a){var u=e.pendingLanes;if(u===0)return 0;var m=0,v=e.suspendedLanes,j=e.pingedLanes;e=e.warmLanes;var Y=u&134217727;return Y!==0?(u=Y&~v,u!==0?m=Dn(u):(j&=Y,j!==0?m=Dn(j):a||(a=Y&~e,a!==0&&(m=Dn(a))))):(Y=u&~v,Y!==0?m=Dn(Y):j!==0?m=Dn(j):a||(a=u&~e,a!==0&&(m=Dn(a)))),m===0?0:r!==0&&r!==m&&(r&v)===0&&(v=m&-m,a=r&-r,v>=a||v===32&&(a&4194048)!==0)?r:m}function Kn(e,r){return(e.pendingLanes&~(e.suspendedLanes&~e.pingedLanes)&r)===0}function Ws(e,r){switch(e){case 1:case 2:case 4:case 8:case 64:return r+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return r+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function ga(){var e=Ot;return Ot<<=1,(Ot&4194048)===0&&(Ot=256),e}function Hr(){var e=Ft;return Ft<<=1,(Ft&62914560)===0&&(Ft=4194304),e}function ms(e){for(var r=[],a=0;31>a;a++)r.push(e);return r}function _s(e,r){e.pendingLanes|=r,r!==268435456&&(e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0)}function gs(e,r,a,u,m,v){var j=e.pendingLanes;e.pendingLanes=a,e.suspendedLanes=0,e.pingedLanes=0,e.warmLanes=0,e.expiredLanes&=a,e.entangledLanes&=a,e.errorRecoveryDisabledLanes&=a,e.shellSuspendCounter=0;var Y=e.entanglements,_e=e.expirationTimes,Ie=e.hiddenUpdates;for(a=j&~a;0<a;){var Qe=31-He(a),tt=1<<Qe;Y[Qe]=0,_e[Qe]=-1;var Le=Ie[Qe];if(Le!==null)for(Ie[Qe]=null,Qe=0;Qe<Le.length;Qe++){var Re=Le[Qe];Re!==null&&(Re.lane&=-536870913)}a&=~tt}u!==0&&Pt(e,u,0),v!==0&&m===0&&e.tag!==0&&(e.suspendedLanes|=v&~(j&~r))}function Pt(e,r,a){e.pendingLanes|=r,e.suspendedLanes&=~r;var u=31-He(r);e.entangledLanes|=r,e.entanglements[u]=e.entanglements[u]|1073741824|a&4194090}function ys(e,r){var a=e.entangledLanes|=r;for(e=e.entanglements;a;){var u=31-He(a),m=1<<u;m&r|e[u]&r&&(e[u]|=r),a&=~m}}function Kr(e){switch(e){case 2:e=1;break;case 8:e=4;break;case 32:e=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:e=128;break;case 268435456:e=134217728;break;default:e=0}return e}function Ms(e){return e&=-e,2<e?8<e?(e&134217727)!==0?32:268435456:8:2}function Hs(){var e=se.p;return e!==0?e:(e=window.event,e===void 0?32:Ag(e.type))}function ya(e,r){var a=se.p;try{return se.p=e,r()}finally{se.p=a}}var Pr=Math.random().toString(36).slice(2),Nn="__reactFiber$"+Pr,mn="__reactProps$"+Pr,st="__reactContainer$"+Pr,yt="__reactEvents$"+Pr,Et="__reactListeners$"+Pr,Qn="__reactHandles$"+Pr,_n="__reactResources$"+Pr,mr="__reactMarker$"+Pr;function vs(e){delete e[Nn],delete e[mn],delete e[yt],delete e[Et],delete e[Qn]}function Fr(e){var r=e[Nn];if(r)return r;for(var a=e.parentNode;a;){if(r=a[st]||a[Nn]){if(a=r.alternate,r.child!==null||a!==null&&a.child!==null)for(e=hg(e);e!==null;){if(a=e[Nn])return a;e=hg(e)}return r}e=a,a=e.parentNode}return null}function rr(e){if(e=e[Nn]||e[st]){var r=e.tag;if(r===5||r===6||r===13||r===26||r===27||r===3)return e}return null}function qr(e){var r=e.tag;if(r===5||r===26||r===27||r===6)return e.stateNode;throw Error(i(33))}function Lr(e){var r=e[_n];return r||(r=e[_n]={hoistableStyles:new Map,hoistableScripts:new Map}),r}function Pn(e){e[mr]=!0}var Ks=new Set,Ua={};function as(e,r){ws(e,r),ws(e+"Capture",r)}function ws(e,r){for(Ua[e]=r,e=0;e<r.length;e++)Ks.add(r[e])}var Ei=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),Ds={},Va={};function Si(e){return Z.call(Va,e)?!0:Z.call(Ds,e)?!1:Ei.test(e)?Va[e]=!0:(Ds[e]=!0,!1)}function qs(e,r,a){if(Si(r))if(a===null)e.removeAttribute(r);else{switch(typeof a){case"undefined":case"function":case"symbol":e.removeAttribute(r);return;case"boolean":var u=r.toLowerCase().slice(0,5);if(u!=="data-"&&u!=="aria-"){e.removeAttribute(r);return}}e.setAttribute(r,""+a)}}function Ar(e,r,a){if(a===null)e.removeAttribute(r);else{switch(typeof a){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(r);return}e.setAttribute(r,""+a)}}function Tr(e,r,a,u){if(u===null)e.removeAttribute(a);else{switch(typeof u){case"undefined":case"function":case"symbol":case"boolean":e.removeAttribute(a);return}e.setAttributeNS(r,a,""+u)}}var _r,Ma;function is(e){if(_r===void 0)try{throw Error()}catch(a){var r=a.stack.trim().match(/\n( *(at )?)/);_r=r&&r[1]||"",Ma=-1<a.stack.indexOf(`
    at`)?" (<anonymous>)":-1<a.stack.indexOf("@")?"@unknown:0:0":""}return`
`+_r+e+Ma}var $r=!1;function os(e,r){if(!e||$r)return"";$r=!0;var a=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var u={DetermineComponentFrameRoot:function(){try{if(r){var tt=function(){throw Error()};if(Object.defineProperty(tt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(tt,[])}catch(Re){var Le=Re}Reflect.construct(e,[],tt)}else{try{tt.call()}catch(Re){Le=Re}e.call(tt.prototype)}}else{try{throw Error()}catch(Re){Le=Re}(tt=e())&&typeof tt.catch=="function"&&tt.catch(function(){})}}catch(Re){if(Re&&Le&&typeof Re.stack=="string")return[Re.stack,Le.stack]}return[null,null]}};u.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var m=Object.getOwnPropertyDescriptor(u.DetermineComponentFrameRoot,"name");m&&m.configurable&&Object.defineProperty(u.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var v=u.DetermineComponentFrameRoot(),j=v[0],Y=v[1];if(j&&Y){var _e=j.split(`
`),Ie=Y.split(`
`);for(m=u=0;u<_e.length&&!_e[u].includes("DetermineComponentFrameRoot");)u++;for(;m<Ie.length&&!Ie[m].includes("DetermineComponentFrameRoot");)m++;if(u===_e.length||m===Ie.length)for(u=_e.length-1,m=Ie.length-1;1<=u&&0<=m&&_e[u]!==Ie[m];)m--;for(;1<=u&&0<=m;u--,m--)if(_e[u]!==Ie[m]){if(u!==1||m!==1)do if(u--,m--,0>m||_e[u]!==Ie[m]){var Qe=`
`+_e[u].replace(" at new "," at ");return e.displayName&&Qe.includes("<anonymous>")&&(Qe=Qe.replace("<anonymous>",e.displayName)),Qe}while(1<=u&&0<=m);break}}}finally{$r=!1,Error.prepareStackTrace=a}return(a=e?e.displayName||e.name:"")?is(a):""}function uo(e){switch(e.tag){case 26:case 27:case 5:return is(e.type);case 16:return is("Lazy");case 13:return is("Suspense");case 19:return is("SuspenseList");case 0:case 15:return os(e.type,!1);case 11:return os(e.type.render,!1);case 1:return os(e.type,!0);case 31:return is("Activity");default:return""}}function Qr(e){try{var r="";do r+=uo(e),e=e.return;while(e);return r}catch(a){return`
Error generating stack: `+a.message+`
`+a.stack}}function xr(e){switch(typeof e){case"bigint":case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function va(e){var r=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(r==="checkbox"||r==="radio")}function Xr(e){var r=va(e)?"checked":"value",a=Object.getOwnPropertyDescriptor(e.constructor.prototype,r),u=""+e[r];if(!e.hasOwnProperty(r)&&typeof a<"u"&&typeof a.get=="function"&&typeof a.set=="function"){var m=a.get,v=a.set;return Object.defineProperty(e,r,{configurable:!0,get:function(){return m.call(this)},set:function(j){u=""+j,v.call(this,j)}}),Object.defineProperty(e,r,{enumerable:a.enumerable}),{getValue:function(){return u},setValue:function(j){u=""+j},stopTracking:function(){e._valueTracker=null,delete e[r]}}}}function Yr(e){e._valueTracker||(e._valueTracker=Xr(e))}function lr(e){if(!e)return!1;var r=e._valueTracker;if(!r)return!0;var a=r.getValue(),u="";return e&&(u=va(e)?e.checked?"true":"false":e.value),e=u,e!==a?(r.setValue(e),!0):!1}function sr(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}var Ga=/[\n"\\]/g;function Er(e){return e.replace(Ga,function(r){return"\\"+r.charCodeAt(0).toString(16)+" "})}function Is(e,r,a,u,m,v,j,Y){e.name="",j!=null&&typeof j!="function"&&typeof j!="symbol"&&typeof j!="boolean"?e.type=j:e.removeAttribute("type"),r!=null?j==="number"?(r===0&&e.value===""||e.value!=r)&&(e.value=""+xr(r)):e.value!==""+xr(r)&&(e.value=""+xr(r)):j!=="submit"&&j!=="reset"||e.removeAttribute("value"),r!=null?Te(e,j,xr(r)):a!=null?Te(e,j,xr(a)):u!=null&&e.removeAttribute("value"),m==null&&v!=null&&(e.defaultChecked=!!v),m!=null&&(e.checked=m&&typeof m!="function"&&typeof m!="symbol"),Y!=null&&typeof Y!="function"&&typeof Y!="symbol"&&typeof Y!="boolean"?e.name=""+xr(Y):e.removeAttribute("name")}function Ci(e,r,a,u,m,v,j,Y){if(v!=null&&typeof v!="function"&&typeof v!="symbol"&&typeof v!="boolean"&&(e.type=v),r!=null||a!=null){if(!(v!=="submit"&&v!=="reset"||r!=null))return;a=a!=null?""+xr(a):"",r=r!=null?""+xr(r):a,Y||r===e.value||(e.value=r),e.defaultValue=r}u=u??m,u=typeof u!="function"&&typeof u!="symbol"&&!!u,e.checked=Y?e.checked:!!u,e.defaultChecked=!!u,j!=null&&typeof j!="function"&&typeof j!="symbol"&&typeof j!="boolean"&&(e.name=j)}function Te(e,r,a){r==="number"&&sr(e.ownerDocument)===e||e.defaultValue===""+a||(e.defaultValue=""+a)}function N(e,r,a,u){if(e=e.options,r){r={};for(var m=0;m<a.length;m++)r["$"+a[m]]=!0;for(a=0;a<e.length;a++)m=r.hasOwnProperty("$"+e[a].value),e[a].selected!==m&&(e[a].selected=m),m&&u&&(e[a].defaultSelected=!0)}else{for(a=""+xr(a),r=null,m=0;m<e.length;m++){if(e[m].value===a){e[m].selected=!0,u&&(e[m].defaultSelected=!0);return}r!==null||e[m].disabled||(r=e[m])}r!==null&&(r.selected=!0)}}function ee(e,r,a){if(r!=null&&(r=""+xr(r),r!==e.value&&(e.value=r),a==null)){e.defaultValue!==r&&(e.defaultValue=r);return}e.defaultValue=a!=null?""+xr(a):""}function de(e,r,a,u){if(r==null){if(u!=null){if(a!=null)throw Error(i(92));if(ne(u)){if(1<u.length)throw Error(i(93));u=u[0]}a=u}a==null&&(a=""),r=a}a=xr(r),e.defaultValue=a,u=e.textContent,u===a&&u!==""&&u!==null&&(e.value=u)}function Me(e,r){if(r){var a=e.firstChild;if(a&&a===e.lastChild&&a.nodeType===3){a.nodeValue=r;return}}e.textContent=r}var xe=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Ge(e,r,a){var u=r.indexOf("--")===0;a==null||typeof a=="boolean"||a===""?u?e.setProperty(r,""):r==="float"?e.cssFloat="":e[r]="":u?e.setProperty(r,a):typeof a!="number"||a===0||xe.has(r)?r==="float"?e.cssFloat=a:e[r]=(""+a).trim():e[r]=a+"px"}function lt(e,r,a){if(r!=null&&typeof r!="object")throw Error(i(62));if(e=e.style,a!=null){for(var u in a)!a.hasOwnProperty(u)||r!=null&&r.hasOwnProperty(u)||(u.indexOf("--")===0?e.setProperty(u,""):u==="float"?e.cssFloat="":e[u]="");for(var m in r)u=r[m],r.hasOwnProperty(m)&&a[m]!==u&&Ge(e,m,u)}else for(var v in r)r.hasOwnProperty(v)&&Ge(e,v,r[v])}function ht(e){if(e.indexOf("-")===-1)return!1;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ft=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),Mt=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function kt(e){return Mt.test(""+e)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":e}var Zt=null;function sn(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var gn=null,en=null;function $n(e){var r=rr(e);if(r&&(e=r.stateNode)){var a=e[mn]||null;e:switch(e=r.stateNode,r.type){case"input":if(Is(e,a.value,a.defaultValue,a.defaultValue,a.checked,a.defaultChecked,a.type,a.name),r=a.name,a.type==="radio"&&r!=null){for(a=e;a.parentNode;)a=a.parentNode;for(a=a.querySelectorAll('input[name="'+Er(""+r)+'"][type="radio"]'),r=0;r<a.length;r++){var u=a[r];if(u!==e&&u.form===e.form){var m=u[mn]||null;if(!m)throw Error(i(90));Is(u,m.value,m.defaultValue,m.defaultValue,m.checked,m.defaultChecked,m.type,m.name)}}for(r=0;r<a.length;r++)u=a[r],u.form===e.form&&lr(u)}break e;case"textarea":ee(e,a.value,a.defaultValue);break e;case"select":r=a.value,r!=null&&N(e,!!a.multiple,r,!1)}}}var gr=!1;function yr(e,r,a){if(gr)return e(r,a);gr=!0;try{var u=e(r);return u}finally{if(gr=!1,(gn!==null||en!==null)&&(cc(),gn&&(r=gn,e=en,en=gn=null,$n(r),e)))for(r=0;r<e.length;r++)$n(e[r])}}function Br(e,r){var a=e.stateNode;if(a===null)return null;var u=a[mn]||null;if(u===null)return null;a=u[r];e:switch(r){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(u=!u.disabled)||(e=e.type,u=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!u;break e;default:e=!1}if(e)return null;if(a&&typeof a!="function")throw Error(i(231,r,typeof a));return a}var Bn=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),bs=!1;if(Bn)try{var wn={};Object.defineProperty(wn,"passive",{get:function(){bs=!0}}),window.addEventListener("test",wn,wn),window.removeEventListener("test",wn,wn)}catch{bs=!1}var bn=null,ur=null,Zr=null;function zs(){if(Zr)return Zr;var e,r=ur,a=r.length,u,m="value"in bn?bn.value:bn.textContent,v=m.length;for(e=0;e<a&&r[e]===m[e];e++);var j=a-e;for(u=1;u<=j&&r[a-u]===m[v-u];u++);return Zr=m.slice(e,1<u?1-u:void 0)}function On(e){var r=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&r===13&&(e=13)):e=r,e===10&&(e=13),32<=e||e===13?e:0}function Xn(){return!0}function Tn(){return!1}function nn(e){function r(a,u,m,v,j){this._reactName=a,this._targetInst=m,this.type=u,this.nativeEvent=v,this.target=j,this.currentTarget=null;for(var Y in e)e.hasOwnProperty(Y)&&(a=e[Y],this[Y]=a?a(v):v[Y]);return this.isDefaultPrevented=(v.defaultPrevented!=null?v.defaultPrevented:v.returnValue===!1)?Xn:Tn,this.isPropagationStopped=Tn,this}return g(r.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():typeof a.returnValue!="unknown"&&(a.returnValue=!1),this.isDefaultPrevented=Xn)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():typeof a.cancelBubble!="unknown"&&(a.cancelBubble=!0),this.isPropagationStopped=Xn)},persist:function(){},isPersistent:Xn}),r}var yn={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},In=nn(yn),jn=g({},yn,{view:0,detail:0}),Pi=nn(jn),wa,Qo,Wa,co=g({},jn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Zo,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==Wa&&(Wa&&e.type==="mousemove"?(wa=e.screenX-Wa.screenX,Qo=e.screenY-Wa.screenY):Qo=wa=0,Wa=e),wa)},movementY:function(e){return"movementY"in e?e.movementY:Qo}}),Fs=nn(co),Sc=g({},co,{dataTransfer:0}),Cc=nn(Sc),fo=g({},jn,{relatedTarget:0}),Xo=nn(fo),iu=g({},yn,{animationName:0,elapsedTime:0,pseudoElement:0}),ou=nn(iu),Pc=g({},yn,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Ac=nn(Pc),Yo=g({},yn,{data:0}),lu=nn(Yo),uu={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},$c={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},cu={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Hd(e){var r=this.nativeEvent;return r.getModifierState?r.getModifierState(e):(e=cu[e])?!!r[e]:!1}function Zo(){return Hd}var du=g({},jn,{key:function(e){if(e.key){var r=uu[e.key]||e.key;if(r!=="Unidentified")return r}return e.type==="keypress"?(e=On(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?$c[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Zo,charCode:function(e){return e.type==="keypress"?On(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?On(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),Oc=nn(du),Jo=g({},co,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),fu=nn(Jo),kc=g({},jn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Zo}),Dc=nn(kc),pu=g({},yn,{propertyName:0,elapsedTime:0,pseudoElement:0}),hu=nn(pu),mu=g({},co,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Ic=nn(mu),el=g({},yn,{newState:0,oldState:0}),tl=nn(el),_u=[9,13,27,32],Qs=Bn&&"CompositionEvent"in window,Ts=null;Bn&&"documentMode"in document&&(Ts=document.documentMode);var gu=Bn&&"TextEvent"in window&&!Ts,zc=Bn&&(!Qs||Ts&&8<Ts&&11>=Ts),yu=" ",Fc=!1;function po(e,r){switch(e){case"keyup":return _u.indexOf(r.keyCode)!==-1;case"keydown":return r.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function ho(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var Ha=!1;function Lc(e,r){switch(e){case"compositionend":return ho(r);case"keypress":return r.which!==32?null:(Fc=!0,yu);case"textInput":return e=r.data,e===yu&&Fc?null:e;default:return null}}function Bc(e,r){if(Ha)return e==="compositionend"||!Qs&&po(e,r)?(e=zs(),Zr=ur=bn=null,Ha=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(r.ctrlKey||r.altKey||r.metaKey)||r.ctrlKey&&r.altKey){if(r.char&&1<r.char.length)return r.char;if(r.which)return String.fromCharCode(r.which)}return null;case"compositionend":return zc&&r.locale!=="ko"?null:r.data;default:return null}}var Rc={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Mu(e){var r=e&&e.nodeName&&e.nodeName.toLowerCase();return r==="input"?!!Rc[e.type]:r==="textarea"}function mo(e,r,a,u){gn?en?en.push(u):en=[u]:gn=u,r=Go(r,"onChange"),0<r.length&&(a=new In("onChange","change",null,a,u),e.push({event:a,listeners:r}))}var Ai=null,$i=null;function Nc(e){io(e,0)}function Xs(e){var r=qr(e);if(lr(r))return e}function Ka(e,r){if(e==="change")return r}var nl=!1;if(Bn){var _o;if(Bn){var rl="oninput"in document;if(!rl){var go=document.createElement("div");go.setAttribute("oninput","return;"),rl=typeof go.oninput=="function"}_o=rl}else _o=!1;nl=_o&&(!document.documentMode||9<document.documentMode)}function Oi(){Ai&&(Ai.detachEvent("onpropertychange",sl),$i=Ai=null)}function sl(e){if(e.propertyName==="value"&&Xs($i)){var r=[];mo(r,$i,e,sn(e)),yr(Nc,r)}}function vu(e,r,a){e==="focusin"?(Oi(),Ai=r,$i=a,Ai.attachEvent("onpropertychange",sl)):e==="focusout"&&Oi()}function al(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return Xs($i)}function wu(e,r){if(e==="click")return Xs(r)}function bu(e,r){if(e==="input"||e==="change")return Xs(r)}function il(e,r){return e===r&&(e!==0||1/e===1/r)||e!==e&&r!==r}var Rr=typeof Object.is=="function"?Object.is:il;function qa(e,r){if(Rr(e,r))return!0;if(typeof e!="object"||e===null||typeof r!="object"||r===null)return!1;var a=Object.keys(e),u=Object.keys(r);if(a.length!==u.length)return!1;for(u=0;u<a.length;u++){var m=a[u];if(!Z.call(r,m)||!Rr(e[m],r[m]))return!1}return!0}function ol(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ll(e,r){var a=ol(e);e=0;for(var u;a;){if(a.nodeType===3){if(u=e+a.textContent.length,e<=r&&u>=r)return{node:a,offset:r-e};e=u}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=ol(a)}}function ki(e,r){return e&&r?e===r?!0:e&&e.nodeType===3?!1:r&&r.nodeType===3?ki(e,r.parentNode):"contains"in e?e.contains(r):e.compareDocumentPosition?!!(e.compareDocumentPosition(r)&16):!1:!1}function Je(e){e=e!=null&&e.ownerDocument!=null&&e.ownerDocument.defaultView!=null?e.ownerDocument.defaultView:window;for(var r=sr(e.document);r instanceof e.HTMLIFrameElement;){try{var a=typeof r.contentWindow.location.href=="string"}catch{a=!1}if(a)e=r.contentWindow;else break;r=sr(e.document)}return r}function ul(e){var r=e&&e.nodeName&&e.nodeName.toLowerCase();return r&&(r==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||r==="textarea"||e.contentEditable==="true")}var Tu=Bn&&"documentMode"in document&&11>=document.documentMode,Ys=null,Qa=null,Or=null,ba=!1;function yo(e,r,a){var u=a.window===a?a.document:a.nodeType===9?a:a.ownerDocument;ba||Ys==null||Ys!==sr(u)||(u=Ys,"selectionStart"in u&&ul(u)?u={start:u.selectionStart,end:u.selectionEnd}:(u=(u.ownerDocument&&u.ownerDocument.defaultView||window).getSelection(),u={anchorNode:u.anchorNode,anchorOffset:u.anchorOffset,focusNode:u.focusNode,focusOffset:u.focusOffset}),Or&&qa(Or,u)||(Or=u,u=Go(Qa,"onSelect"),0<u.length&&(r=new In("onSelect","select",null,r,a),e.push({event:r,listeners:u}),r.target=Ys)))}function Zs(e,r){var a={};return a[e.toLowerCase()]=r.toLowerCase(),a["Webkit"+e]="webkit"+r,a["Moz"+e]="moz"+r,a}var Js={animationend:Zs("Animation","AnimationEnd"),animationiteration:Zs("Animation","AnimationIteration"),animationstart:Zs("Animation","AnimationStart"),transitionrun:Zs("Transition","TransitionRun"),transitionstart:Zs("Transition","TransitionStart"),transitioncancel:Zs("Transition","TransitionCancel"),transitionend:Zs("Transition","TransitionEnd")},Mo={},vo={};Bn&&(vo=document.createElement("div").style,"AnimationEvent"in window||(delete Js.animationend.animation,delete Js.animationiteration.animation,delete Js.animationstart.animation),"TransitionEvent"in window||delete Js.transitionend.transition);function Ls(e){if(Mo[e])return Mo[e];if(!Js[e])return e;var r=Js[e],a;for(a in r)if(r.hasOwnProperty(a)&&a in vo)return Mo[e]=r[a];return e}var cl=Ls("animationend"),Lt=Ls("animationiteration"),Ta=Ls("animationstart"),xu=Ls("transitionrun"),It=Ls("transitionstart"),wo=Ls("transitioncancel"),zt=Ls("transitionend"),dl=new Map,Di="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Di.push("scrollEnd");function Jr(e,r){dl.set(e,r),as(r,[e])}var fl=new WeakMap;function kr(e,r){if(typeof e=="object"&&e!==null){var a=fl.get(e);return a!==void 0?a:(r={value:e,source:r,stack:Qr(r)},fl.set(e,r),r)}return{value:e,source:r,stack:Qr(r)}}var Nr=[],ea=0,Ii=0;function zi(){for(var e=ea,r=Ii=ea=0;r<e;){var a=Nr[r];Nr[r++]=null;var u=Nr[r];Nr[r++]=null;var m=Nr[r];Nr[r++]=null;var v=Nr[r];if(Nr[r++]=null,u!==null&&m!==null){var j=u.pending;j===null?m.next=m:(m.next=j.next,j.next=m),u.pending=m}v!==0&&pl(a,m,v)}}function Fi(e,r,a,u){Nr[ea++]=e,Nr[ea++]=r,Nr[ea++]=a,Nr[ea++]=u,Ii|=u,e.lanes|=u,e=e.alternate,e!==null&&(e.lanes|=u)}function Li(e,r,a,u){return Fi(e,r,a,u),Xa(e)}function xa(e,r){return Fi(e,null,null,r),Xa(e)}function pl(e,r,a){e.lanes|=a;var u=e.alternate;u!==null&&(u.lanes|=a);for(var m=!1,v=e.return;v!==null;)v.childLanes|=a,u=v.alternate,u!==null&&(u.childLanes|=a),v.tag===22&&(e=v.stateNode,e===null||e._visibility&1||(m=!0)),e=v,v=v.return;return e.tag===3?(v=e.stateNode,m&&r!==null&&(m=31-He(a),e=v.hiddenUpdates,u=e[m],u===null?e[m]=[r]:u.push(r),r.lane=a|536870912),v):null}function Xa(e){if(50<Vl)throw Vl=0,Ad=null,Error(i(185));for(var r=e.return;r!==null;)e=r,r=e.return;return e.tag===3?e.stateNode:null}var Ea={};function Eu(e,r,a,u){this.tag=e,this.key=a,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=r,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=u,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Sr(e,r,a,u){return new Eu(e,r,a,u)}function bo(e){return e=e.prototype,!(!e||!e.isReactComponent)}function xs(e,r){var a=e.alternate;return a===null?(a=Sr(e.tag,r,e.key,e.mode),a.elementType=e.elementType,a.type=e.type,a.stateNode=e.stateNode,a.alternate=e,e.alternate=a):(a.pendingProps=r,a.type=e.type,a.flags=0,a.subtreeFlags=0,a.deletions=null),a.flags=e.flags&65011712,a.childLanes=e.childLanes,a.lanes=e.lanes,a.child=e.child,a.memoizedProps=e.memoizedProps,a.memoizedState=e.memoizedState,a.updateQueue=e.updateQueue,r=e.dependencies,a.dependencies=r===null?null:{lanes:r.lanes,firstContext:r.firstContext},a.sibling=e.sibling,a.index=e.index,a.ref=e.ref,a.refCleanup=e.refCleanup,a}function To(e,r){e.flags&=65011714;var a=e.alternate;return a===null?(e.childLanes=0,e.lanes=r,e.child=null,e.subtreeFlags=0,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null,e.stateNode=null):(e.childLanes=a.childLanes,e.lanes=a.lanes,e.child=a.child,e.subtreeFlags=0,e.deletions=null,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,e.updateQueue=a.updateQueue,e.type=a.type,r=a.dependencies,e.dependencies=r===null?null:{lanes:r.lanes,firstContext:r.firstContext}),e}function Bi(e,r,a,u,m,v){var j=0;if(u=e,typeof e=="function")bo(e)&&(j=1);else if(typeof e=="string")j=AT(e,a,le.current)?26:e==="html"||e==="head"||e==="body"?27:5;else e:switch(e){case K:return e=Sr(31,a,r,m),e.elementType=K,e.lanes=v,e;case b:return ta(a.children,m,v,r);case k:j=8,m|=24;break;case L:return e=Sr(12,a,r,m|2),e.elementType=L,e.lanes=v,e;case x:return e=Sr(13,a,r,m),e.elementType=x,e.lanes=v,e;case E:return e=Sr(19,a,r,m),e.elementType=E,e.lanes=v,e;default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case C:case I:j=10;break e;case S:j=9;break e;case O:j=11;break e;case A:j=14;break e;case F:j=16,u=null;break e}j=29,a=Error(i(130,e===null?"null":typeof e,"")),u=null}return r=Sr(j,a,r,m),r.elementType=e,r.type=u,r.lanes=v,r}function ta(e,r,a,u){return e=Sr(7,e,u,r),e.lanes=a,e}function Ri(e,r,a){return e=Sr(6,e,null,r),e.lanes=a,e}function xo(e,r,a){return r=Sr(4,e.children!==null?e.children:[],e.key,r),r.lanes=a,r.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},r}var Sa=[],na=0,Ni=null,ji=0,jr=[],Ur=0,Bs=null,Es=1,Ss="";function Rs(e,r){Sa[na++]=ji,Sa[na++]=Ni,Ni=e,ji=r}function hl(e,r,a){jr[Ur++]=Es,jr[Ur++]=Ss,jr[Ur++]=Bs,Bs=e;var u=Es;e=Ss;var m=32-He(u)-1;u&=~(1<<m),a+=1;var v=32-He(r)+m;if(30<v){var j=m-m%5;v=(u&(1<<j)-1).toString(32),u>>=j,m-=j,Es=1<<32-He(r)+m|a<<m|u,Ss=v+e}else Es=1<<v|a<<m|u,Ss=e}function Eo(e){e.return!==null&&(Rs(e,1),hl(e,1,0))}function Ui(e){for(;e===Ni;)Ni=Sa[--na],Sa[na]=null,ji=Sa[--na],Sa[na]=null;for(;e===Bs;)Bs=jr[--Ur],jr[Ur]=null,Ss=jr[--Ur],jr[Ur]=null,Es=jr[--Ur],jr[Ur]=null}var Mr=null,zn=null,an=!1,ra=null,ls=!1,Vi=Error(i(519));function sa(e){var r=Error(i(418,""));throw Ja(kr(r,e)),Vi}function ml(e){var r=e.stateNode,a=e.type,u=e.memoizedProps;switch(r[Nn]=e,r[mn]=u,a){case"dialog":Yt("cancel",r),Yt("close",r);break;case"iframe":case"object":case"embed":Yt("load",r);break;case"video":case"audio":for(a=0;a<Gn.length;a++)Yt(Gn[a],r);break;case"source":Yt("error",r);break;case"img":case"image":case"link":Yt("error",r),Yt("load",r);break;case"details":Yt("toggle",r);break;case"input":Yt("invalid",r),Ci(r,u.value,u.defaultValue,u.checked,u.defaultChecked,u.type,u.name,!0),Yr(r);break;case"select":Yt("invalid",r);break;case"textarea":Yt("invalid",r),de(r,u.value,u.defaultValue,u.children),Yr(r)}a=u.children,typeof a!="string"&&typeof a!="number"&&typeof a!="bigint"||r.textContent===""+a||u.suppressHydrationWarning===!0||dh(r.textContent,a)?(u.popover!=null&&(Yt("beforetoggle",r),Yt("toggle",r)),u.onScroll!=null&&Yt("scroll",r),u.onScrollEnd!=null&&Yt("scrollend",r),u.onClick!=null&&(r.onclick=Fd),r=!0):r=!1,r||sa(e)}function So(e){for(Mr=e.return;Mr;)switch(Mr.tag){case 5:case 13:ls=!1;return;case 27:case 3:ls=!0;return;default:Mr=Mr.return}}function Ya(e){if(e!==Mr)return!1;if(!an)return So(e),an=!0,!1;var r=e.tag,a;if((a=r!==3&&r!==27)&&((a=r===5)&&(a=e.type,a=!(a!=="form"&&a!=="button")||Jh(e.type,e.memoizedProps)),a=!a),a&&zn&&sa(e),So(e),r===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(i(317));e:{for(e=e.nextSibling,r=0;e;){if(e.nodeType===8)if(a=e.data,a==="/$"){if(r===0){zn=hi(e.nextSibling);break e}r--}else a!=="$"&&a!=="$!"&&a!=="$?"||r++;e=e.nextSibling}zn=null}}else r===27?(r=zn,Ql(e.type)?(e=rm,rm=null,zn=e):zn=r):zn=Mr?hi(e.stateNode.nextSibling):null;return!0}function Za(){zn=Mr=null,an=!1}function Co(){var e=ra;return e!==null&&(ns===null?ns=e:ns.push.apply(ns,e),ra=null),e}function Ja(e){ra===null?ra=[e]:ra.push(e)}var Po=U(null),aa=null,Cs=null;function Ns(e,r,a){Q(Po,r._currentValue),r._currentValue=a}function js(e){e._currentValue=Po.current,B(Po)}function _l(e,r,a){for(;e!==null;){var u=e.alternate;if((e.childLanes&r)!==r?(e.childLanes|=r,u!==null&&(u.childLanes|=r)):u!==null&&(u.childLanes&r)!==r&&(u.childLanes|=r),e===a)break;e=e.return}}function gl(e,r,a,u){var m=e.child;for(m!==null&&(m.return=e);m!==null;){var v=m.dependencies;if(v!==null){var j=m.child;v=v.firstContext;e:for(;v!==null;){var Y=v;v=m;for(var _e=0;_e<r.length;_e++)if(Y.context===r[_e]){v.lanes|=a,Y=v.alternate,Y!==null&&(Y.lanes|=a),_l(v.return,a,e),u||(j=null);break e}v=Y.next}}else if(m.tag===18){if(j=m.return,j===null)throw Error(i(341));j.lanes|=a,v=j.alternate,v!==null&&(v.lanes|=a),_l(j,a,e),j=null}else j=m.child;if(j!==null)j.return=m;else for(j=m;j!==null;){if(j===e){j=null;break}if(m=j.sibling,m!==null){m.return=j.return,j=m;break}j=j.return}m=j}}function Gi(e,r,a,u){e=null;for(var m=r,v=!1;m!==null;){if(!v){if((m.flags&524288)!==0)v=!0;else if((m.flags&262144)!==0)break}if(m.tag===10){var j=m.alternate;if(j===null)throw Error(i(387));if(j=j.memoizedProps,j!==null){var Y=m.type;Rr(m.pendingProps.value,j.value)||(e!==null?e.push(Y):e=[Y])}}else if(m===Se.current){if(j=m.alternate,j===null)throw Error(i(387));j.memoizedState.memoizedState!==m.memoizedState.memoizedState&&(e!==null?e.push(wp):e=[wp])}m=m.return}e!==null&&gl(r,e,a,u),r.flags|=262144}function Wi(e){for(e=e.firstContext;e!==null;){if(!Rr(e.context._currentValue,e.memoizedValue))return!0;e=e.next}return!1}function Ca(e){aa=e,Cs=null,e=e.dependencies,e!==null&&(e.firstContext=null)}function vr(e){return Su(aa,e)}function Ao(e,r){return aa===null&&Ca(e),Su(e,r)}function Su(e,r){var a=r._currentValue;if(r={context:r,memoizedValue:a,next:null},Cs===null){if(e===null)throw Error(i(308));Cs=r,e.dependencies={lanes:0,firstContext:r},e.flags|=524288}else Cs=Cs.next=r;return a}var Cu=typeof AbortController<"u"?AbortController:function(){var e=[],r=this.signal={aborted:!1,addEventListener:function(a,u){e.push(u)}};this.abort=function(){r.aborted=!0,e.forEach(function(a){return a()})}},jc=t.unstable_scheduleCallback,Uc=t.unstable_NormalPriority,Yn={$$typeof:I,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function yl(){return{controller:new Cu,data:new Map,refCount:0}}function ei(e){e.refCount--,e.refCount===0&&jc(Uc,function(){e.controller.abort()})}var Hi=null,Ml=0,Pa=0,ti=null;function Vc(e,r){if(Hi===null){var a=Hi=[];Ml=0,Pa=Gl(),ti={status:"pending",value:void 0,then:function(u){a.push(u)}}}return Ml++,r.then(vl,vl),r}function vl(){if(--Ml===0&&Hi!==null){ti!==null&&(ti.status="fulfilled");var e=Hi;Hi=null,Pa=0,ti=null;for(var r=0;r<e.length;r++)(0,e[r])()}}function Gc(e,r){var a=[],u={status:"pending",value:null,reason:null,then:function(m){a.push(m)}};return e.then(function(){u.status="fulfilled",u.value=r;for(var m=0;m<a.length;m++)(0,a[m])(r)},function(m){for(u.status="rejected",u.reason=m,m=0;m<a.length;m++)(0,a[m])(void 0)}),u}var Pu=G.S;G.S=function(e,r){typeof r=="object"&&r!==null&&typeof r.then=="function"&&Vc(e,r),Pu!==null&&Pu(e,r)};var ia=U(null);function wl(){var e=ia.current;return e!==null?e:kn.pooledCache}function $o(e,r){r===null?Q(ia,ia.current):Q(ia,r.pool)}function bl(){var e=wl();return e===null?null:{parent:Yn._currentValue,pool:e}}var Ki=Error(i(460)),Au=Error(i(474)),ni=Error(i(542)),Tl={then:function(){}};function $u(e){return e=e.status,e==="fulfilled"||e==="rejected"}function qi(){}function xl(e,r,a){switch(a=e[a],a===void 0?e.push(r):a!==r&&(r.then(qi,qi),r=a),r.status){case"fulfilled":return r.value;case"rejected":throw e=r.reason,Ou(e),e;default:if(typeof r.status=="string")r.then(qi,qi);else{if(e=kn,e!==null&&100<e.shellSuspendCounter)throw Error(i(482));e=r,e.status="pending",e.then(function(u){if(r.status==="pending"){var m=r;m.status="fulfilled",m.value=u}},function(u){if(r.status==="pending"){var m=r;m.status="rejected",m.reason=u}})}switch(r.status){case"fulfilled":return r.value;case"rejected":throw e=r.reason,Ou(e),e}throw Qi=r,Ki}}var Qi=null;function El(){if(Qi===null)throw Error(i(459));var e=Qi;return Qi=null,e}function Ou(e){if(e===Ki||e===ni)throw Error(i(483))}var oa=!1;function Xi(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function Oo(e,r){e=e.updateQueue,r.updateQueue===e&&(r.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,callbacks:null})}function la(e){return{lane:e,tag:0,payload:null,callback:null,next:null}}function ua(e,r,a){var u=e.updateQueue;if(u===null)return null;if(u=u.shared,(xn&2)!==0){var m=u.pending;return m===null?r.next=r:(r.next=m.next,m.next=r),u.pending=r,r=Xa(e),pl(e,null,a),r}return Fi(e,u,r,a),Xa(e)}function Yi(e,r,a){if(r=r.updateQueue,r!==null&&(r=r.shared,(a&4194048)!==0)){var u=r.lanes;u&=e.pendingLanes,a|=u,r.lanes=a,ys(e,a)}}function ko(e,r){var a=e.updateQueue,u=e.alternate;if(u!==null&&(u=u.updateQueue,a===u)){var m=null,v=null;if(a=a.firstBaseUpdate,a!==null){do{var j={lane:a.lane,tag:a.tag,payload:a.payload,callback:null,next:null};v===null?m=v=j:v=v.next=j,a=a.next}while(a!==null);v===null?m=v=r:v=v.next=r}else m=v=r;a={baseState:u.baseState,firstBaseUpdate:m,lastBaseUpdate:v,shared:u.shared,callbacks:u.callbacks},e.updateQueue=a;return}e=a.lastBaseUpdate,e===null?a.firstBaseUpdate=r:e.next=r,a.lastBaseUpdate=r}var Do=!1;function h(){if(Do){var e=ti;if(e!==null)throw e}}function M(e,r,a,u){Do=!1;var m=e.updateQueue;oa=!1;var v=m.firstBaseUpdate,j=m.lastBaseUpdate,Y=m.shared.pending;if(Y!==null){m.shared.pending=null;var _e=Y,Ie=_e.next;_e.next=null,j===null?v=Ie:j.next=Ie,j=_e;var Qe=e.alternate;Qe!==null&&(Qe=Qe.updateQueue,Y=Qe.lastBaseUpdate,Y!==j&&(Y===null?Qe.firstBaseUpdate=Ie:Y.next=Ie,Qe.lastBaseUpdate=_e))}if(v!==null){var tt=m.baseState;j=0,Qe=Ie=_e=null,Y=v;do{var Le=Y.lane&-536870913,Re=Le!==Y.lane;if(Re?(ln&Le)===Le:(u&Le)===Le){Le!==0&&Le===Pa&&(Do=!0),Qe!==null&&(Qe=Qe.next={lane:0,tag:Y.tag,payload:Y.payload,callback:null,next:null});e:{var Kt=e,Rt=Y;Le=r;var Ln=a;switch(Rt.tag){case 1:if(Kt=Rt.payload,typeof Kt=="function"){tt=Kt.call(Ln,tt,Le);break e}tt=Kt;break e;case 3:Kt.flags=Kt.flags&-65537|128;case 0:if(Kt=Rt.payload,Le=typeof Kt=="function"?Kt.call(Ln,tt,Le):Kt,Le==null)break e;tt=g({},tt,Le);break e;case 2:oa=!0}}Le=Y.callback,Le!==null&&(e.flags|=64,Re&&(e.flags|=8192),Re=m.callbacks,Re===null?m.callbacks=[Le]:Re.push(Le))}else Re={lane:Le,tag:Y.tag,payload:Y.payload,callback:Y.callback,next:null},Qe===null?(Ie=Qe=Re,_e=tt):Qe=Qe.next=Re,j|=Le;if(Y=Y.next,Y===null){if(Y=m.shared.pending,Y===null)break;Re=Y,Y=Re.next,Re.next=null,m.lastBaseUpdate=Re,m.shared.pending=null}}while(!0);Qe===null&&(_e=tt),m.baseState=_e,m.firstBaseUpdate=Ie,m.lastBaseUpdate=Qe,v===null&&(m.shared.lanes=0),ci|=j,e.lanes=j,e.memoizedState=tt}}function $(e,r){if(typeof e!="function")throw Error(i(191,e));e.call(r)}function D(e,r){var a=e.callbacks;if(a!==null)for(e.callbacks=null,e=0;e<a.length;e++)$(a[e],r)}var R=U(null),te=U(0);function me(e,r){e=Fa,Q(te,e),Q(R,r),Fa=e|r.baseLanes}function $e(){Q(te,Fa),Q(R,R.current)}function je(){Fa=te.current,B(R),B(te)}var Ye=0,Xe=null,pt=null,vt=null,fn=!1,cr=!1,Vr=!1,ku=0,Sl=0,Io=null,Kd=0;function Zn(){throw Error(i(321))}function Wc(e,r){if(r===null)return!1;for(var a=0;a<r.length&&a<e.length;a++)if(!Rr(e[a],r[a]))return!1;return!0}function Du(e,r,a,u,m,v){return Ye=v,Xe=r,r.memoizedState=null,r.updateQueue=null,r.lanes=0,G.H=e===null||e.memoizedState===null?xf:Ef,Vr=!1,v=a(u,m),Vr=!1,cr&&(v=Qd(r,a,u,m)),qd(e),v}function qd(e){G.H=zo;var r=pt!==null&&pt.next!==null;if(Ye=0,vt=pt=Xe=null,fn=!1,Sl=0,Io=null,r)throw Error(i(300));e===null||fr||(e=e.dependencies,e!==null&&Wi(e)&&(fr=!0))}function Qd(e,r,a,u){Xe=e;var m=0;do{if(cr&&(Io=null),Sl=0,cr=!1,25<=m)throw Error(i(301));if(m+=1,vt=pt=null,e.updateQueue!=null){var v=e.updateQueue;v.lastEffect=null,v.events=null,v.stores=null,v.memoCache!=null&&(v.memoCache.index=0)}G.H=Yp,v=r(a,u)}while(cr);return v}function Wp(){var e=G.H,r=e.useState()[0];return r=typeof r.then=="function"?Pl(r):r,e=e.useState()[0],(pt!==null?pt.memoizedState:null)!==e&&(Xe.flags|=1024),r}function Hc(){var e=ku!==0;return ku=0,e}function Cl(e,r,a){r.updateQueue=e.updateQueue,r.flags&=-2053,e.lanes&=~a}function Kc(e){if(fn){for(e=e.memoizedState;e!==null;){var r=e.queue;r!==null&&(r.pending=null),e=e.next}fn=!1}Ye=0,vt=pt=Xe=null,cr=!1,Sl=ku=0,Io=null}function es(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return vt===null?Xe.memoizedState=vt=e:vt=vt.next=e,vt}function ar(){if(pt===null){var e=Xe.alternate;e=e!==null?e.memoizedState:null}else e=pt.next;var r=vt===null?Xe.memoizedState:vt.next;if(r!==null)vt=r,pt=e;else{if(e===null)throw Xe.alternate===null?Error(i(467)):Error(i(310));pt=e,e={memoizedState:pt.memoizedState,baseState:pt.baseState,baseQueue:pt.baseQueue,queue:pt.queue,next:null},vt===null?Xe.memoizedState=vt=e:vt=vt.next=e}return vt}function qc(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Pl(e){var r=Sl;return Sl+=1,Io===null&&(Io=[]),e=xl(Io,e,r),r=Xe,(vt===null?r.memoizedState:vt.next)===null&&(r=r.alternate,G.H=r===null||r.memoizedState===null?xf:Ef),e}function Iu(e){if(e!==null&&typeof e=="object"){if(typeof e.then=="function")return Pl(e);if(e.$$typeof===I)return vr(e)}throw Error(i(438,String(e)))}function Qc(e){var r=null,a=Xe.updateQueue;if(a!==null&&(r=a.memoCache),r==null){var u=Xe.alternate;u!==null&&(u=u.updateQueue,u!==null&&(u=u.memoCache,u!=null&&(r={data:u.data.map(function(m){return m.slice()}),index:0})))}if(r==null&&(r={data:[],index:0}),a===null&&(a=qc(),Xe.updateQueue=a),a.memoCache=r,a=r.data[r.index],a===void 0)for(a=r.data[r.index]=Array(e),u=0;u<e;u++)a[u]=X;return r.index++,a}function Aa(e,r){return typeof r=="function"?r(e):r}function zu(e){var r=ar();return Fu(r,pt,e)}function Fu(e,r,a){var u=e.queue;if(u===null)throw Error(i(311));u.lastRenderedReducer=a;var m=e.baseQueue,v=u.pending;if(v!==null){if(m!==null){var j=m.next;m.next=v.next,v.next=j}r.baseQueue=m=v,u.pending=null}if(v=e.baseState,m===null)e.memoizedState=v;else{r=m.next;var Y=j=null,_e=null,Ie=r,Qe=!1;do{var tt=Ie.lane&-536870913;if(tt!==Ie.lane?(ln&tt)===tt:(Ye&tt)===tt){var Le=Ie.revertLane;if(Le===0)_e!==null&&(_e=_e.next={lane:0,revertLane:0,action:Ie.action,hasEagerState:Ie.hasEagerState,eagerState:Ie.eagerState,next:null}),tt===Pa&&(Qe=!0);else if((Ye&Le)===Le){Ie=Ie.next,Le===Pa&&(Qe=!0);continue}else tt={lane:0,revertLane:Ie.revertLane,action:Ie.action,hasEagerState:Ie.hasEagerState,eagerState:Ie.eagerState,next:null},_e===null?(Y=_e=tt,j=v):_e=_e.next=tt,Xe.lanes|=Le,ci|=Le;tt=Ie.action,Vr&&a(v,tt),v=Ie.hasEagerState?Ie.eagerState:a(v,tt)}else Le={lane:tt,revertLane:Ie.revertLane,action:Ie.action,hasEagerState:Ie.hasEagerState,eagerState:Ie.eagerState,next:null},_e===null?(Y=_e=Le,j=v):_e=_e.next=Le,Xe.lanes|=tt,ci|=tt;Ie=Ie.next}while(Ie!==null&&Ie!==r);if(_e===null?j=v:_e.next=Y,!Rr(v,e.memoizedState)&&(fr=!0,Qe&&(a=ti,a!==null)))throw a;e.memoizedState=v,e.baseState=j,e.baseQueue=_e,u.lastRenderedState=v}return m===null&&(u.lanes=0),[e.memoizedState,u.dispatch]}function Xc(e){var r=ar(),a=r.queue;if(a===null)throw Error(i(311));a.lastRenderedReducer=e;var u=a.dispatch,m=a.pending,v=r.memoizedState;if(m!==null){a.pending=null;var j=m=m.next;do v=e(v,j.action),j=j.next;while(j!==m);Rr(v,r.memoizedState)||(fr=!0),r.memoizedState=v,r.baseQueue===null&&(r.baseState=v),a.lastRenderedState=v}return[v,u]}function Xd(e,r,a){var u=Xe,m=ar(),v=an;if(v){if(a===void 0)throw Error(i(407));a=a()}else a=r();var j=!Rr((pt||m).memoizedState,a);j&&(m.memoizedState=a,fr=!0),m=m.queue;var Y=Zd.bind(null,u,m,e);if(Al(2048,8,Y,[e]),m.getSnapshot!==r||j||vt!==null&&vt.memoizedState.tag&1){if(u.flags|=2048,Zi(9,Ru(),Yd.bind(null,u,m,a,r),null),kn===null)throw Error(i(349));v||(Ye&124)!==0||Yc(u,r,a)}return a}function Yc(e,r,a){e.flags|=16384,e={getSnapshot:r,value:a},r=Xe.updateQueue,r===null?(r=qc(),Xe.updateQueue=r,r.stores=[e]):(a=r.stores,a===null?r.stores=[e]:a.push(e))}function Yd(e,r,a,u){r.value=a,r.getSnapshot=u,Jd(r)&&ef(e)}function Zd(e,r,a){return a(function(){Jd(r)&&ef(e)})}function Jd(e){var r=e.getSnapshot;e=e.value;try{var a=r();return!Rr(e,a)}catch{return!0}}function ef(e){var r=xa(e,2);r!==null&&ds(r,e,2)}function Lu(e){var r=es();if(typeof e=="function"){var a=e;if(e=a(),Vr){rt(!0);try{a()}finally{rt(!1)}}}return r.memoizedState=r.baseState=e,r.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Aa,lastRenderedState:e},r}function tf(e,r,a,u){return e.baseState=a,Fu(e,pt,typeof u=="function"?u:Aa)}function Hp(e,r,a,u,m){if(Vu(e))throw Error(i(485));if(e=r.action,e!==null){var v={payload:m,action:e,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(j){v.listeners.push(j)}};G.T!==null?a(!0):v.isTransition=!1,u(v),a=r.pending,a===null?(v.next=r.pending=v,Zc(r,v)):(v.next=a.next,r.pending=a.next=v)}}function Zc(e,r){var a=r.action,u=r.payload,m=e.state;if(r.isTransition){var v=G.T,j={};G.T=j;try{var Y=a(m,u),_e=G.S;_e!==null&&_e(j,Y),nf(e,r,Y)}catch(Ie){Bu(e,r,Ie)}finally{G.T=v}}else try{v=a(m,u),nf(e,r,v)}catch(Ie){Bu(e,r,Ie)}}function nf(e,r,a){a!==null&&typeof a=="object"&&typeof a.then=="function"?a.then(function(u){rf(e,r,u)},function(u){return Bu(e,r,u)}):rf(e,r,a)}function rf(e,r,a){r.status="fulfilled",r.value=a,sf(r),e.state=a,r=e.pending,r!==null&&(a=r.next,a===r?e.pending=null:(a=a.next,r.next=a,Zc(e,a)))}function Bu(e,r,a){var u=e.pending;if(e.pending=null,u!==null){u=u.next;do r.status="rejected",r.reason=a,sf(r),r=r.next;while(r!==u)}e.action=null}function sf(e){e=e.listeners;for(var r=0;r<e.length;r++)(0,e[r])()}function af(e,r){return r}function Jc(e,r){if(an){var a=kn.formState;if(a!==null){e:{var u=Xe;if(an){if(zn){t:{for(var m=zn,v=ls;m.nodeType!==8;){if(!v){m=null;break t}if(m=hi(m.nextSibling),m===null){m=null;break t}}v=m.data,m=v==="F!"||v==="F"?m:null}if(m){zn=hi(m.nextSibling),u=m.data==="F!";break e}}sa(u)}u=!1}u&&(r=a[0])}}return a=es(),a.memoizedState=a.baseState=r,u={pending:null,lanes:0,dispatch:null,lastRenderedReducer:af,lastRenderedState:r},a.queue=u,a=wf.bind(null,Xe,u),u.dispatch=a,u=Lu(!1),v=ad.bind(null,Xe,!1,u.queue),u=es(),m={state:r,dispatch:null,action:e,pending:null},u.queue=m,a=Hp.bind(null,Xe,m,v,a),m.dispatch=a,u.memoizedState=e,[r,a,!1]}function of(e){var r=ar();return lf(r,pt,e)}function lf(e,r,a){if(r=Fu(e,r,af)[0],e=zu(Aa)[0],typeof r=="object"&&r!==null&&typeof r.then=="function")try{var u=Pl(r)}catch(j){throw j===Ki?ni:j}else u=r;r=ar();var m=r.queue,v=m.dispatch;return a!==r.memoizedState&&(Xe.flags|=2048,Zi(9,Ru(),Kp.bind(null,m,a),null)),[u,v,e]}function Kp(e,r){e.action=r}function uf(e){var r=ar(),a=pt;if(a!==null)return lf(r,a,e);ar(),r=r.memoizedState,a=ar();var u=a.queue.dispatch;return a.memoizedState=e,[r,u,!1]}function Zi(e,r,a,u){return e={tag:e,create:a,deps:u,inst:r,next:null},r=Xe.updateQueue,r===null&&(r=qc(),Xe.updateQueue=r),a=r.lastEffect,a===null?r.lastEffect=e.next=e:(u=a.next,a.next=e,e.next=u,r.lastEffect=e),e}function Ru(){return{destroy:void 0,resource:void 0}}function cf(){return ar().memoizedState}function Nu(e,r,a,u){var m=es();u=u===void 0?null:u,Xe.flags|=e,m.memoizedState=Zi(1|r,Ru(),a,u)}function Al(e,r,a,u){var m=ar();u=u===void 0?null:u;var v=m.memoizedState.inst;pt!==null&&u!==null&&Wc(u,pt.memoizedState.deps)?m.memoizedState=Zi(r,v,a,u):(Xe.flags|=e,m.memoizedState=Zi(1|r,v,a,u))}function df(e,r){Nu(8390656,8,e,r)}function ff(e,r){Al(2048,8,e,r)}function ed(e,r){return Al(4,2,e,r)}function pf(e,r){return Al(4,4,e,r)}function hf(e,r){if(typeof r=="function"){e=e();var a=r(e);return function(){typeof a=="function"?a():r(null)}}if(r!=null)return e=e(),r.current=e,function(){r.current=null}}function td(e,r,a){a=a!=null?a.concat([e]):null,Al(4,4,hf.bind(null,r,e),a)}function nd(){}function mf(e,r){var a=ar();r=r===void 0?null:r;var u=a.memoizedState;return r!==null&&Wc(r,u[1])?u[0]:(a.memoizedState=[e,r],e)}function ri(e,r){var a=ar();r=r===void 0?null:r;var u=a.memoizedState;if(r!==null&&Wc(r,u[1]))return u[0];if(u=e(),Vr){rt(!0);try{e()}finally{rt(!1)}}return a.memoizedState=[u,r],u}function rd(e,r,a){return a===void 0||(Ye&1073741824)!==0?e.memoizedState=r:(e.memoizedState=a,e=ap(),Xe.lanes|=e,ci|=e,a)}function _f(e,r,a,u){return Rr(a,r)?a:R.current!==null?(e=rd(e,a,u),Rr(e,r)||(fr=!0),e):(Ye&42)===0?(fr=!0,e.memoizedState=a):(e=ap(),Xe.lanes|=e,ci|=e,r)}function gf(e,r,a,u,m){var v=se.p;se.p=v!==0&&8>v?v:8;var j=G.T,Y={};G.T=Y,ad(e,!1,r,a);try{var _e=m(),Ie=G.S;if(Ie!==null&&Ie(Y,_e),_e!==null&&typeof _e=="object"&&typeof _e.then=="function"){var Qe=Gc(_e,u);si(e,r,Qe,cs(e))}else si(e,r,u,cs(e))}catch(tt){si(e,r,{then:function(){},status:"rejected",reason:tt},cs())}finally{se.p=v,G.T=j}}function qp(){}function ju(e,r,a,u){if(e.tag!==5)throw Error(i(476));var m=yf(e).queue;gf(e,m,r,ce,a===null?qp:function(){return Mf(e),a(u)})}function yf(e){var r=e.memoizedState;if(r!==null)return r;r={memoizedState:ce,baseState:ce,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Aa,lastRenderedState:ce},next:null};var a={};return r.next={memoizedState:a,baseState:a,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Aa,lastRenderedState:a},next:null},e.memoizedState=r,e=e.alternate,e!==null&&(e.memoizedState=r),r}function Mf(e){var r=yf(e).next.queue;si(e,r,{},cs())}function sd(){return vr(wp)}function vf(){return ar().memoizedState}function Uu(){return ar().memoizedState}function Qp(e){for(var r=e.return;r!==null;){switch(r.tag){case 24:case 3:var a=cs();e=la(a);var u=ua(r,e,a);u!==null&&(ds(u,r,a),Yi(u,r,a)),r={cache:yl()},e.payload=r;return}r=r.return}}function Xp(e,r,a){var u=cs();a={lane:u,revertLane:0,action:a,hasEagerState:!1,eagerState:null,next:null},Vu(e)?bf(r,a):(a=Li(e,r,a,u),a!==null&&(ds(a,e,u),Tf(a,r,u)))}function wf(e,r,a){var u=cs();si(e,r,a,u)}function si(e,r,a,u){var m={lane:u,revertLane:0,action:a,hasEagerState:!1,eagerState:null,next:null};if(Vu(e))bf(r,m);else{var v=e.alternate;if(e.lanes===0&&(v===null||v.lanes===0)&&(v=r.lastRenderedReducer,v!==null))try{var j=r.lastRenderedState,Y=v(j,a);if(m.hasEagerState=!0,m.eagerState=Y,Rr(Y,j))return Fi(e,r,m,0),kn===null&&zi(),!1}catch{}finally{}if(a=Li(e,r,m,u),a!==null)return ds(a,e,u),Tf(a,r,u),!0}return!1}function ad(e,r,a,u){if(u={lane:2,revertLane:Gl(),action:u,hasEagerState:!1,eagerState:null,next:null},Vu(e)){if(r)throw Error(i(479))}else r=Li(e,a,u,2),r!==null&&ds(r,e,2)}function Vu(e){var r=e.alternate;return e===Xe||r!==null&&r===Xe}function bf(e,r){cr=fn=!0;var a=e.pending;a===null?r.next=r:(r.next=a.next,a.next=r),e.pending=r}function Tf(e,r,a){if((a&4194048)!==0){var u=r.lanes;u&=e.pendingLanes,a|=u,r.lanes=a,ys(e,a)}}var zo={readContext:vr,use:Iu,useCallback:Zn,useContext:Zn,useEffect:Zn,useImperativeHandle:Zn,useLayoutEffect:Zn,useInsertionEffect:Zn,useMemo:Zn,useReducer:Zn,useRef:Zn,useState:Zn,useDebugValue:Zn,useDeferredValue:Zn,useTransition:Zn,useSyncExternalStore:Zn,useId:Zn,useHostTransitionStatus:Zn,useFormState:Zn,useActionState:Zn,useOptimistic:Zn,useMemoCache:Zn,useCacheRefresh:Zn},xf={readContext:vr,use:Iu,useCallback:function(e,r){return es().memoizedState=[e,r===void 0?null:r],e},useContext:vr,useEffect:df,useImperativeHandle:function(e,r,a){a=a!=null?a.concat([e]):null,Nu(4194308,4,hf.bind(null,r,e),a)},useLayoutEffect:function(e,r){return Nu(4194308,4,e,r)},useInsertionEffect:function(e,r){Nu(4,2,e,r)},useMemo:function(e,r){var a=es();r=r===void 0?null:r;var u=e();if(Vr){rt(!0);try{e()}finally{rt(!1)}}return a.memoizedState=[u,r],u},useReducer:function(e,r,a){var u=es();if(a!==void 0){var m=a(r);if(Vr){rt(!0);try{a(r)}finally{rt(!1)}}}else m=r;return u.memoizedState=u.baseState=m,e={pending:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:m},u.queue=e,e=e.dispatch=Xp.bind(null,Xe,e),[u.memoizedState,e]},useRef:function(e){var r=es();return e={current:e},r.memoizedState=e},useState:function(e){e=Lu(e);var r=e.queue,a=wf.bind(null,Xe,r);return r.dispatch=a,[e.memoizedState,a]},useDebugValue:nd,useDeferredValue:function(e,r){var a=es();return rd(a,e,r)},useTransition:function(){var e=Lu(!1);return e=gf.bind(null,Xe,e.queue,!0,!1),es().memoizedState=e,[!1,e]},useSyncExternalStore:function(e,r,a){var u=Xe,m=es();if(an){if(a===void 0)throw Error(i(407));a=a()}else{if(a=r(),kn===null)throw Error(i(349));(ln&124)!==0||Yc(u,r,a)}m.memoizedState=a;var v={value:a,getSnapshot:r};return m.queue=v,df(Zd.bind(null,u,v,e),[e]),u.flags|=2048,Zi(9,Ru(),Yd.bind(null,u,v,a,r),null),a},useId:function(){var e=es(),r=kn.identifierPrefix;if(an){var a=Ss,u=Es;a=(u&~(1<<32-He(u)-1)).toString(32)+a,r="«"+r+"R"+a,a=ku++,0<a&&(r+="H"+a.toString(32)),r+="»"}else a=Kd++,r="«"+r+"r"+a.toString(32)+"»";return e.memoizedState=r},useHostTransitionStatus:sd,useFormState:Jc,useActionState:Jc,useOptimistic:function(e){var r=es();r.memoizedState=r.baseState=e;var a={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return r.queue=a,r=ad.bind(null,Xe,!0,a),a.dispatch=r,[e,r]},useMemoCache:Qc,useCacheRefresh:function(){return es().memoizedState=Qp.bind(null,Xe)}},Ef={readContext:vr,use:Iu,useCallback:mf,useContext:vr,useEffect:ff,useImperativeHandle:td,useInsertionEffect:ed,useLayoutEffect:pf,useMemo:ri,useReducer:zu,useRef:cf,useState:function(){return zu(Aa)},useDebugValue:nd,useDeferredValue:function(e,r){var a=ar();return _f(a,pt.memoizedState,e,r)},useTransition:function(){var e=zu(Aa)[0],r=ar().memoizedState;return[typeof e=="boolean"?e:Pl(e),r]},useSyncExternalStore:Xd,useId:vf,useHostTransitionStatus:sd,useFormState:of,useActionState:of,useOptimistic:function(e,r){var a=ar();return tf(a,pt,e,r)},useMemoCache:Qc,useCacheRefresh:Uu},Yp={readContext:vr,use:Iu,useCallback:mf,useContext:vr,useEffect:ff,useImperativeHandle:td,useInsertionEffect:ed,useLayoutEffect:pf,useMemo:ri,useReducer:Xc,useRef:cf,useState:function(){return Xc(Aa)},useDebugValue:nd,useDeferredValue:function(e,r){var a=ar();return pt===null?rd(a,e,r):_f(a,pt.memoizedState,e,r)},useTransition:function(){var e=Xc(Aa)[0],r=ar().memoizedState;return[typeof e=="boolean"?e:Pl(e),r]},useSyncExternalStore:Xd,useId:vf,useHostTransitionStatus:sd,useFormState:uf,useActionState:uf,useOptimistic:function(e,r){var a=ar();return pt!==null?tf(a,pt,e,r):(a.baseState=e,[e,a.queue.dispatch])},useMemoCache:Qc,useCacheRefresh:Uu},$l=null,Ol=0;function Gu(e){var r=Ol;return Ol+=1,$l===null&&($l=[]),xl($l,e,r)}function kl(e,r){r=r.props.ref,e.ref=r!==void 0?r:null}function ai(e,r){throw r.$$typeof===_?Error(i(525)):(e=Object.prototype.toString.call(r),Error(i(31,e==="[object Object]"?"object with keys {"+Object.keys(r).join(", ")+"}":e)))}function Sf(e){var r=e._init;return r(e._payload)}function Cf(e){function r(Ce,be){if(e){var ke=Ce.deletions;ke===null?(Ce.deletions=[be],Ce.flags|=16):ke.push(be)}}function a(Ce,be){if(!e)return null;for(;be!==null;)r(Ce,be),be=be.sibling;return null}function u(Ce){for(var be=new Map;Ce!==null;)Ce.key!==null?be.set(Ce.key,Ce):be.set(Ce.index,Ce),Ce=Ce.sibling;return be}function m(Ce,be){return Ce=xs(Ce,be),Ce.index=0,Ce.sibling=null,Ce}function v(Ce,be,ke){return Ce.index=ke,e?(ke=Ce.alternate,ke!==null?(ke=ke.index,ke<be?(Ce.flags|=67108866,be):ke):(Ce.flags|=67108866,be)):(Ce.flags|=1048576,be)}function j(Ce){return e&&Ce.alternate===null&&(Ce.flags|=67108866),Ce}function Y(Ce,be,ke,Ze){return be===null||be.tag!==6?(be=Ri(ke,Ce.mode,Ze),be.return=Ce,be):(be=m(be,ke),be.return=Ce,be)}function _e(Ce,be,ke,Ze){var St=ke.type;return St===b?Qe(Ce,be,ke.props.children,Ze,ke.key):be!==null&&(be.elementType===St||typeof St=="object"&&St!==null&&St.$$typeof===F&&Sf(St)===be.type)?(be=m(be,ke.props),kl(be,ke),be.return=Ce,be):(be=Bi(ke.type,ke.key,ke.props,null,Ce.mode,Ze),kl(be,ke),be.return=Ce,be)}function Ie(Ce,be,ke,Ze){return be===null||be.tag!==4||be.stateNode.containerInfo!==ke.containerInfo||be.stateNode.implementation!==ke.implementation?(be=xo(ke,Ce.mode,Ze),be.return=Ce,be):(be=m(be,ke.children||[]),be.return=Ce,be)}function Qe(Ce,be,ke,Ze,St){return be===null||be.tag!==7?(be=ta(ke,Ce.mode,Ze,St),be.return=Ce,be):(be=m(be,ke),be.return=Ce,be)}function tt(Ce,be,ke){if(typeof be=="string"&&be!==""||typeof be=="number"||typeof be=="bigint")return be=Ri(""+be,Ce.mode,ke),be.return=Ce,be;if(typeof be=="object"&&be!==null){switch(be.$$typeof){case y:return ke=Bi(be.type,be.key,be.props,null,Ce.mode,ke),kl(ke,be),ke.return=Ce,ke;case T:return be=xo(be,Ce.mode,ke),be.return=Ce,be;case F:var Ze=be._init;return be=Ze(be._payload),tt(Ce,be,ke)}if(ne(be)||ie(be))return be=ta(be,Ce.mode,ke,null),be.return=Ce,be;if(typeof be.then=="function")return tt(Ce,Gu(be),ke);if(be.$$typeof===I)return tt(Ce,Ao(Ce,be),ke);ai(Ce,be)}return null}function Le(Ce,be,ke,Ze){var St=be!==null?be.key:null;if(typeof ke=="string"&&ke!==""||typeof ke=="number"||typeof ke=="bigint")return St!==null?null:Y(Ce,be,""+ke,Ze);if(typeof ke=="object"&&ke!==null){switch(ke.$$typeof){case y:return ke.key===St?_e(Ce,be,ke,Ze):null;case T:return ke.key===St?Ie(Ce,be,ke,Ze):null;case F:return St=ke._init,ke=St(ke._payload),Le(Ce,be,ke,Ze)}if(ne(ke)||ie(ke))return St!==null?null:Qe(Ce,be,ke,Ze,null);if(typeof ke.then=="function")return Le(Ce,be,Gu(ke),Ze);if(ke.$$typeof===I)return Le(Ce,be,Ao(Ce,ke),Ze);ai(Ce,ke)}return null}function Re(Ce,be,ke,Ze,St){if(typeof Ze=="string"&&Ze!==""||typeof Ze=="number"||typeof Ze=="bigint")return Ce=Ce.get(ke)||null,Y(be,Ce,""+Ze,St);if(typeof Ze=="object"&&Ze!==null){switch(Ze.$$typeof){case y:return Ce=Ce.get(Ze.key===null?ke:Ze.key)||null,_e(be,Ce,Ze,St);case T:return Ce=Ce.get(Ze.key===null?ke:Ze.key)||null,Ie(be,Ce,Ze,St);case F:var on=Ze._init;return Ze=on(Ze._payload),Re(Ce,be,ke,Ze,St)}if(ne(Ze)||ie(Ze))return Ce=Ce.get(ke)||null,Qe(be,Ce,Ze,St,null);if(typeof Ze.then=="function")return Re(Ce,be,ke,Gu(Ze),St);if(Ze.$$typeof===I)return Re(Ce,be,ke,Ao(be,Ze),St);ai(be,Ze)}return null}function Kt(Ce,be,ke,Ze){for(var St=null,on=null,Dt=be,Ut=be=0,Gr=null;Dt!==null&&Ut<ke.length;Ut++){Dt.index>Ut?(Gr=Dt,Dt=null):Gr=Dt.sibling;var Cn=Le(Ce,Dt,ke[Ut],Ze);if(Cn===null){Dt===null&&(Dt=Gr);break}e&&Dt&&Cn.alternate===null&&r(Ce,Dt),be=v(Cn,be,Ut),on===null?St=Cn:on.sibling=Cn,on=Cn,Dt=Gr}if(Ut===ke.length)return a(Ce,Dt),an&&Rs(Ce,Ut),St;if(Dt===null){for(;Ut<ke.length;Ut++)Dt=tt(Ce,ke[Ut],Ze),Dt!==null&&(be=v(Dt,be,Ut),on===null?St=Dt:on.sibling=Dt,on=Dt);return an&&Rs(Ce,Ut),St}for(Dt=u(Dt);Ut<ke.length;Ut++)Gr=Re(Dt,Ce,Ut,ke[Ut],Ze),Gr!==null&&(e&&Gr.alternate!==null&&Dt.delete(Gr.key===null?Ut:Gr.key),be=v(Gr,be,Ut),on===null?St=Gr:on.sibling=Gr,on=Gr);return e&&Dt.forEach(function(eu){return r(Ce,eu)}),an&&Rs(Ce,Ut),St}function Rt(Ce,be,ke,Ze){if(ke==null)throw Error(i(151));for(var St=null,on=null,Dt=be,Ut=be=0,Gr=null,Cn=ke.next();Dt!==null&&!Cn.done;Ut++,Cn=ke.next()){Dt.index>Ut?(Gr=Dt,Dt=null):Gr=Dt.sibling;var eu=Le(Ce,Dt,Cn.value,Ze);if(eu===null){Dt===null&&(Dt=Gr);break}e&&Dt&&eu.alternate===null&&r(Ce,Dt),be=v(eu,be,Ut),on===null?St=eu:on.sibling=eu,on=eu,Dt=Gr}if(Cn.done)return a(Ce,Dt),an&&Rs(Ce,Ut),St;if(Dt===null){for(;!Cn.done;Ut++,Cn=ke.next())Cn=tt(Ce,Cn.value,Ze),Cn!==null&&(be=v(Cn,be,Ut),on===null?St=Cn:on.sibling=Cn,on=Cn);return an&&Rs(Ce,Ut),St}for(Dt=u(Dt);!Cn.done;Ut++,Cn=ke.next())Cn=Re(Dt,Ce,Ut,Cn.value,Ze),Cn!==null&&(e&&Cn.alternate!==null&&Dt.delete(Cn.key===null?Ut:Cn.key),be=v(Cn,be,Ut),on===null?St=Cn:on.sibling=Cn,on=Cn);return e&&Dt.forEach(function(jT){return r(Ce,jT)}),an&&Rs(Ce,Ut),St}function Ln(Ce,be,ke,Ze){if(typeof ke=="object"&&ke!==null&&ke.type===b&&ke.key===null&&(ke=ke.props.children),typeof ke=="object"&&ke!==null){switch(ke.$$typeof){case y:e:{for(var St=ke.key;be!==null;){if(be.key===St){if(St=ke.type,St===b){if(be.tag===7){a(Ce,be.sibling),Ze=m(be,ke.props.children),Ze.return=Ce,Ce=Ze;break e}}else if(be.elementType===St||typeof St=="object"&&St!==null&&St.$$typeof===F&&Sf(St)===be.type){a(Ce,be.sibling),Ze=m(be,ke.props),kl(Ze,ke),Ze.return=Ce,Ce=Ze;break e}a(Ce,be);break}else r(Ce,be);be=be.sibling}ke.type===b?(Ze=ta(ke.props.children,Ce.mode,Ze,ke.key),Ze.return=Ce,Ce=Ze):(Ze=Bi(ke.type,ke.key,ke.props,null,Ce.mode,Ze),kl(Ze,ke),Ze.return=Ce,Ce=Ze)}return j(Ce);case T:e:{for(St=ke.key;be!==null;){if(be.key===St)if(be.tag===4&&be.stateNode.containerInfo===ke.containerInfo&&be.stateNode.implementation===ke.implementation){a(Ce,be.sibling),Ze=m(be,ke.children||[]),Ze.return=Ce,Ce=Ze;break e}else{a(Ce,be);break}else r(Ce,be);be=be.sibling}Ze=xo(ke,Ce.mode,Ze),Ze.return=Ce,Ce=Ze}return j(Ce);case F:return St=ke._init,ke=St(ke._payload),Ln(Ce,be,ke,Ze)}if(ne(ke))return Kt(Ce,be,ke,Ze);if(ie(ke)){if(St=ie(ke),typeof St!="function")throw Error(i(150));return ke=St.call(ke),Rt(Ce,be,ke,Ze)}if(typeof ke.then=="function")return Ln(Ce,be,Gu(ke),Ze);if(ke.$$typeof===I)return Ln(Ce,be,Ao(Ce,ke),Ze);ai(Ce,ke)}return typeof ke=="string"&&ke!==""||typeof ke=="number"||typeof ke=="bigint"?(ke=""+ke,be!==null&&be.tag===6?(a(Ce,be.sibling),Ze=m(be,ke),Ze.return=Ce,Ce=Ze):(a(Ce,be),Ze=Ri(ke,Ce.mode,Ze),Ze.return=Ce,Ce=Ze),j(Ce)):a(Ce,be)}return function(Ce,be,ke,Ze){try{Ol=0;var St=Ln(Ce,be,ke,Ze);return $l=null,St}catch(Dt){if(Dt===Ki||Dt===ni)throw Dt;var on=Sr(29,Dt,null,Ce.mode);return on.lanes=Ze,on.return=Ce,on}finally{}}}var Fo=Cf(!0),Pf=Cf(!1),Ps=U(null),ca=null;function ii(e){var r=e.alternate;Q(dr,dr.current&1),Q(Ps,e),ca===null&&(r===null||R.current!==null||r.memoizedState!==null)&&(ca=e)}function Wu(e){if(e.tag===22){if(Q(dr,dr.current),Q(Ps,e),ca===null){var r=e.alternate;r!==null&&r.memoizedState!==null&&(ca=e)}}else Ji()}function Ji(){Q(dr,dr.current),Q(Ps,Ps.current)}function $a(e){B(Ps),ca===e&&(ca=null),B(dr)}var dr=U(0);function Hu(e){for(var r=e;r!==null;){if(r.tag===13){var a=r.memoizedState;if(a!==null&&(a=a.dehydrated,a===null||a.data==="$?"||nm(a)))return r}else if(r.tag===19&&r.memoizedProps.revealOrder!==void 0){if((r.flags&128)!==0)return r}else if(r.child!==null){r.child.return=r,r=r.child;continue}if(r===e)break;for(;r.sibling===null;){if(r.return===null||r.return===e)return null;r=r.return}r.sibling.return=r.return,r=r.sibling}return null}function id(e,r,a,u){r=e.memoizedState,a=a(u,r),a=a==null?r:g({},r,a),e.memoizedState=a,e.lanes===0&&(e.updateQueue.baseState=a)}var od={enqueueSetState:function(e,r,a){e=e._reactInternals;var u=cs(),m=la(u);m.payload=r,a!=null&&(m.callback=a),r=ua(e,m,u),r!==null&&(ds(r,e,u),Yi(r,e,u))},enqueueReplaceState:function(e,r,a){e=e._reactInternals;var u=cs(),m=la(u);m.tag=1,m.payload=r,a!=null&&(m.callback=a),r=ua(e,m,u),r!==null&&(ds(r,e,u),Yi(r,e,u))},enqueueForceUpdate:function(e,r){e=e._reactInternals;var a=cs(),u=la(a);u.tag=2,r!=null&&(u.callback=r),r=ua(e,u,a),r!==null&&(ds(r,e,a),Yi(r,e,a))}};function ld(e,r,a,u,m,v,j){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(u,v,j):r.prototype&&r.prototype.isPureReactComponent?!qa(a,u)||!qa(m,v):!0}function Af(e,r,a,u){e=r.state,typeof r.componentWillReceiveProps=="function"&&r.componentWillReceiveProps(a,u),typeof r.UNSAFE_componentWillReceiveProps=="function"&&r.UNSAFE_componentWillReceiveProps(a,u),r.state!==e&&od.enqueueReplaceState(r,r.state,null)}function eo(e,r){var a=r;if("ref"in r){a={};for(var u in r)u!=="ref"&&(a[u]=r[u])}if(e=e.defaultProps){a===r&&(a=g({},a));for(var m in e)a[m]===void 0&&(a[m]=e[m])}return a}var Dl=typeof reportError=="function"?reportError:function(e){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var r=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof e=="object"&&e!==null&&typeof e.message=="string"?String(e.message):String(e),error:e});if(!window.dispatchEvent(r))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",e);return}console.error(e)};function $f(e){Dl(e)}function Of(e){console.error(e)}function ud(e){Dl(e)}function Ku(e,r){try{var a=e.onUncaughtError;a(r.value,{componentStack:r.stack})}catch(u){setTimeout(function(){throw u})}}function kf(e,r,a){try{var u=e.onCaughtError;u(a.value,{componentStack:a.stack,errorBoundary:r.tag===1?r.stateNode:null})}catch(m){setTimeout(function(){throw m})}}function Il(e,r,a){return a=la(a),a.tag=3,a.payload={element:null},a.callback=function(){Ku(e,r)},a}function Df(e){return e=la(e),e.tag=3,e}function If(e,r,a,u){var m=a.type.getDerivedStateFromError;if(typeof m=="function"){var v=u.value;e.payload=function(){return m(v)},e.callback=function(){kf(r,a,u)}}var j=a.stateNode;j!==null&&typeof j.componentDidCatch=="function"&&(e.callback=function(){kf(r,a,u),typeof m!="function"&&(di===null?di=new Set([this]):di.add(this));var Y=u.stack;this.componentDidCatch(u.value,{componentStack:Y!==null?Y:""})})}function Zp(e,r,a,u,m){if(a.flags|=32768,u!==null&&typeof u=="object"&&typeof u.then=="function"){if(r=a.alternate,r!==null&&Gi(r,a,m,!0),a=Ps.current,a!==null){switch(a.tag){case 13:return ca===null?Od():a.alternate===null&&qn===0&&(qn=3),a.flags&=-257,a.flags|=65536,a.lanes=m,u===Tl?a.flags|=16384:(r=a.updateQueue,r===null?a.updateQueue=new Set([u]):r.add(u),et(e,u,m)),!1;case 22:return a.flags|=65536,u===Tl?a.flags|=16384:(r=a.updateQueue,r===null?(r={transitions:null,markerInstances:null,retryQueue:new Set([u])},a.updateQueue=r):(a=r.retryQueue,a===null?r.retryQueue=new Set([u]):a.add(u)),et(e,u,m)),!1}throw Error(i(435,a.tag))}return et(e,u,m),Od(),!1}if(an)return r=Ps.current,r!==null?((r.flags&65536)===0&&(r.flags|=256),r.flags|=65536,r.lanes=m,u!==Vi&&(e=Error(i(422),{cause:u}),Ja(kr(e,a)))):(u!==Vi&&(r=Error(i(423),{cause:u}),Ja(kr(r,a))),e=e.current.alternate,e.flags|=65536,m&=-m,e.lanes|=m,u=kr(u,a),m=Il(e.stateNode,u,m),ko(e,m),qn!==4&&(qn=2)),!1;var v=Error(i(520),{cause:u});if(v=kr(v,a),Ro===null?Ro=[v]:Ro.push(v),qn!==4&&(qn=2),r===null)return!0;u=kr(u,a),a=r;do{switch(a.tag){case 3:return a.flags|=65536,e=m&-m,a.lanes|=e,e=Il(a.stateNode,u,e),ko(a,e),!1;case 1:if(r=a.type,v=a.stateNode,(a.flags&128)===0&&(typeof r.getDerivedStateFromError=="function"||v!==null&&typeof v.componentDidCatch=="function"&&(di===null||!di.has(v))))return a.flags|=65536,m&=-m,a.lanes|=m,m=Df(m),If(m,e,a,u),ko(a,m),!1}a=a.return}while(a!==null);return!1}var zf=Error(i(461)),fr=!1;function pr(e,r,a,u){r.child=e===null?Pf(r,null,a,u):Fo(r,e.child,a,u)}function Jp(e,r,a,u,m){a=a.render;var v=r.ref;if("ref"in u){var j={};for(var Y in u)Y!=="ref"&&(j[Y]=u[Y])}else j=u;return Ca(r),u=Du(e,r,a,j,v,m),Y=Hc(),e!==null&&!fr?(Cl(e,r,m),Oa(e,r,m)):(an&&Y&&Eo(r),r.flags|=1,pr(e,r,u,m),r.child)}function Ff(e,r,a,u,m){if(e===null){var v=a.type;return typeof v=="function"&&!bo(v)&&v.defaultProps===void 0&&a.compare===null?(r.tag=15,r.type=v,Lf(e,r,v,u,m)):(e=Bi(a.type,null,u,r,r.mode,m),e.ref=r.ref,e.return=r,r.child=e)}if(v=e.child,!zl(e,m)){var j=v.memoizedProps;if(a=a.compare,a=a!==null?a:qa,a(j,u)&&e.ref===r.ref)return Oa(e,r,m)}return r.flags|=1,e=xs(v,u),e.ref=r.ref,e.return=r,r.child=e}function Lf(e,r,a,u,m){if(e!==null){var v=e.memoizedProps;if(qa(v,u)&&e.ref===r.ref)if(fr=!1,r.pendingProps=u=v,zl(e,m))(e.flags&131072)!==0&&(fr=!0);else return r.lanes=e.lanes,Oa(e,r,m)}return Qu(e,r,a,u,m)}function cd(e,r,a){var u=r.pendingProps,m=u.children,v=e!==null?e.memoizedState:null;if(u.mode==="hidden"){if((r.flags&128)!==0){if(u=v!==null?v.baseLanes|a:a,e!==null){for(m=r.child=e.child,v=0;m!==null;)v=v|m.lanes|m.childLanes,m=m.sibling;r.childLanes=v&~u}else r.childLanes=0,r.child=null;return Bf(e,r,u,a)}if((a&536870912)!==0)r.memoizedState={baseLanes:0,cachePool:null},e!==null&&$o(r,v!==null?v.cachePool:null),v!==null?me(r,v):$e(),Wu(r);else return r.lanes=r.childLanes=536870912,Bf(e,r,v!==null?v.baseLanes|a:a,a)}else v!==null?($o(r,v.cachePool),me(r,v),Ji(),r.memoizedState=null):(e!==null&&$o(r,null),$e(),Ji());return pr(e,r,m,a),r.child}function Bf(e,r,a,u){var m=wl();return m=m===null?null:{parent:Yn._currentValue,pool:m},r.memoizedState={baseLanes:a,cachePool:m},e!==null&&$o(r,null),$e(),Wu(r),e!==null&&Gi(e,r,u,!0),null}function qu(e,r){var a=r.ref;if(a===null)e!==null&&e.ref!==null&&(r.flags|=4194816);else{if(typeof a!="function"&&typeof a!="object")throw Error(i(284));(e===null||e.ref!==a)&&(r.flags|=4194816)}}function Qu(e,r,a,u,m){return Ca(r),a=Du(e,r,a,u,void 0,m),u=Hc(),e!==null&&!fr?(Cl(e,r,m),Oa(e,r,m)):(an&&u&&Eo(r),r.flags|=1,pr(e,r,a,m),r.child)}function Rf(e,r,a,u,m,v){return Ca(r),r.updateQueue=null,a=Qd(r,u,a,m),qd(e),u=Hc(),e!==null&&!fr?(Cl(e,r,v),Oa(e,r,v)):(an&&u&&Eo(r),r.flags|=1,pr(e,r,a,v),r.child)}function Nf(e,r,a,u,m){if(Ca(r),r.stateNode===null){var v=Ea,j=a.contextType;typeof j=="object"&&j!==null&&(v=vr(j)),v=new a(u,v),r.memoizedState=v.state!==null&&v.state!==void 0?v.state:null,v.updater=od,r.stateNode=v,v._reactInternals=r,v=r.stateNode,v.props=u,v.state=r.memoizedState,v.refs={},Xi(r),j=a.contextType,v.context=typeof j=="object"&&j!==null?vr(j):Ea,v.state=r.memoizedState,j=a.getDerivedStateFromProps,typeof j=="function"&&(id(r,a,j,u),v.state=r.memoizedState),typeof a.getDerivedStateFromProps=="function"||typeof v.getSnapshotBeforeUpdate=="function"||typeof v.UNSAFE_componentWillMount!="function"&&typeof v.componentWillMount!="function"||(j=v.state,typeof v.componentWillMount=="function"&&v.componentWillMount(),typeof v.UNSAFE_componentWillMount=="function"&&v.UNSAFE_componentWillMount(),j!==v.state&&od.enqueueReplaceState(v,v.state,null),M(r,u,v,m),h(),v.state=r.memoizedState),typeof v.componentDidMount=="function"&&(r.flags|=4194308),u=!0}else if(e===null){v=r.stateNode;var Y=r.memoizedProps,_e=eo(a,Y);v.props=_e;var Ie=v.context,Qe=a.contextType;j=Ea,typeof Qe=="object"&&Qe!==null&&(j=vr(Qe));var tt=a.getDerivedStateFromProps;Qe=typeof tt=="function"||typeof v.getSnapshotBeforeUpdate=="function",Y=r.pendingProps!==Y,Qe||typeof v.UNSAFE_componentWillReceiveProps!="function"&&typeof v.componentWillReceiveProps!="function"||(Y||Ie!==j)&&Af(r,v,u,j),oa=!1;var Le=r.memoizedState;v.state=Le,M(r,u,v,m),h(),Ie=r.memoizedState,Y||Le!==Ie||oa?(typeof tt=="function"&&(id(r,a,tt,u),Ie=r.memoizedState),(_e=oa||ld(r,a,_e,u,Le,Ie,j))?(Qe||typeof v.UNSAFE_componentWillMount!="function"&&typeof v.componentWillMount!="function"||(typeof v.componentWillMount=="function"&&v.componentWillMount(),typeof v.UNSAFE_componentWillMount=="function"&&v.UNSAFE_componentWillMount()),typeof v.componentDidMount=="function"&&(r.flags|=4194308)):(typeof v.componentDidMount=="function"&&(r.flags|=4194308),r.memoizedProps=u,r.memoizedState=Ie),v.props=u,v.state=Ie,v.context=j,u=_e):(typeof v.componentDidMount=="function"&&(r.flags|=4194308),u=!1)}else{v=r.stateNode,Oo(e,r),j=r.memoizedProps,Qe=eo(a,j),v.props=Qe,tt=r.pendingProps,Le=v.context,Ie=a.contextType,_e=Ea,typeof Ie=="object"&&Ie!==null&&(_e=vr(Ie)),Y=a.getDerivedStateFromProps,(Ie=typeof Y=="function"||typeof v.getSnapshotBeforeUpdate=="function")||typeof v.UNSAFE_componentWillReceiveProps!="function"&&typeof v.componentWillReceiveProps!="function"||(j!==tt||Le!==_e)&&Af(r,v,u,_e),oa=!1,Le=r.memoizedState,v.state=Le,M(r,u,v,m),h();var Re=r.memoizedState;j!==tt||Le!==Re||oa||e!==null&&e.dependencies!==null&&Wi(e.dependencies)?(typeof Y=="function"&&(id(r,a,Y,u),Re=r.memoizedState),(Qe=oa||ld(r,a,Qe,u,Le,Re,_e)||e!==null&&e.dependencies!==null&&Wi(e.dependencies))?(Ie||typeof v.UNSAFE_componentWillUpdate!="function"&&typeof v.componentWillUpdate!="function"||(typeof v.componentWillUpdate=="function"&&v.componentWillUpdate(u,Re,_e),typeof v.UNSAFE_componentWillUpdate=="function"&&v.UNSAFE_componentWillUpdate(u,Re,_e)),typeof v.componentDidUpdate=="function"&&(r.flags|=4),typeof v.getSnapshotBeforeUpdate=="function"&&(r.flags|=1024)):(typeof v.componentDidUpdate!="function"||j===e.memoizedProps&&Le===e.memoizedState||(r.flags|=4),typeof v.getSnapshotBeforeUpdate!="function"||j===e.memoizedProps&&Le===e.memoizedState||(r.flags|=1024),r.memoizedProps=u,r.memoizedState=Re),v.props=u,v.state=Re,v.context=_e,u=Qe):(typeof v.componentDidUpdate!="function"||j===e.memoizedProps&&Le===e.memoizedState||(r.flags|=4),typeof v.getSnapshotBeforeUpdate!="function"||j===e.memoizedProps&&Le===e.memoizedState||(r.flags|=1024),u=!1)}return v=u,qu(e,r),u=(r.flags&128)!==0,v||u?(v=r.stateNode,a=u&&typeof a.getDerivedStateFromError!="function"?null:v.render(),r.flags|=1,e!==null&&u?(r.child=Fo(r,e.child,null,m),r.child=Fo(r,null,a,m)):pr(e,r,a,m),r.memoizedState=v.state,e=r.child):e=Oa(e,r,m),e}function dd(e,r,a,u){return Za(),r.flags|=256,pr(e,r,a,u),r.child}var jf={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function Uf(e){return{baseLanes:e,cachePool:bl()}}function Xu(e,r,a){return e=e!==null?e.childLanes&~a:0,r&&(e|=Vs),e}function Yu(e,r,a){var u=r.pendingProps,m=!1,v=(r.flags&128)!==0,j;if((j=v)||(j=e!==null&&e.memoizedState===null?!1:(dr.current&2)!==0),j&&(m=!0,r.flags&=-129),j=(r.flags&32)!==0,r.flags&=-33,e===null){if(an){if(m?ii(r):Ji(),an){var Y=zn,_e;if(_e=Y){e:{for(_e=Y,Y=ls;_e.nodeType!==8;){if(!Y){Y=null;break e}if(_e=hi(_e.nextSibling),_e===null){Y=null;break e}}Y=_e}Y!==null?(r.memoizedState={dehydrated:Y,treeContext:Bs!==null?{id:Es,overflow:Ss}:null,retryLane:536870912,hydrationErrors:null},_e=Sr(18,null,null,0),_e.stateNode=Y,_e.return=r,r.child=_e,Mr=r,zn=null,_e=!0):_e=!1}_e||sa(r)}if(Y=r.memoizedState,Y!==null&&(Y=Y.dehydrated,Y!==null))return nm(Y)?r.lanes=32:r.lanes=536870912,null;$a(r)}return Y=u.children,u=u.fallback,m?(Ji(),m=r.mode,Y=Zu({mode:"hidden",children:Y},m),u=ta(u,m,a,null),Y.return=r,u.return=r,Y.sibling=u,r.child=Y,m=r.child,m.memoizedState=Uf(a),m.childLanes=Xu(e,j,a),r.memoizedState=jf,u):(ii(r),fd(r,Y))}if(_e=e.memoizedState,_e!==null&&(Y=_e.dehydrated,Y!==null)){if(v)r.flags&256?(ii(r),r.flags&=-257,r=pd(e,r,a)):r.memoizedState!==null?(Ji(),r.child=e.child,r.flags|=128,r=null):(Ji(),m=u.fallback,Y=r.mode,u=Zu({mode:"visible",children:u.children},Y),m=ta(m,Y,a,null),m.flags|=2,u.return=r,m.return=r,u.sibling=m,r.child=u,Fo(r,e.child,null,a),u=r.child,u.memoizedState=Uf(a),u.childLanes=Xu(e,j,a),r.memoizedState=jf,r=m);else if(ii(r),nm(Y)){if(j=Y.nextSibling&&Y.nextSibling.dataset,j)var Ie=j.dgst;j=Ie,u=Error(i(419)),u.stack="",u.digest=j,Ja({value:u,source:null,stack:null}),r=pd(e,r,a)}else if(fr||Gi(e,r,a,!1),j=(a&e.childLanes)!==0,fr||j){if(j=kn,j!==null&&(u=a&-a,u=(u&42)!==0?1:Kr(u),u=(u&(j.suspendedLanes|a))!==0?0:u,u!==0&&u!==_e.retryLane))throw _e.retryLane=u,xa(e,u),ds(j,e,u),zf;Y.data==="$?"||Od(),r=pd(e,r,a)}else Y.data==="$?"?(r.flags|=192,r.child=e.child,r=null):(e=_e.treeContext,zn=hi(Y.nextSibling),Mr=r,an=!0,ra=null,ls=!1,e!==null&&(jr[Ur++]=Es,jr[Ur++]=Ss,jr[Ur++]=Bs,Es=e.id,Ss=e.overflow,Bs=r),r=fd(r,u.children),r.flags|=4096);return r}return m?(Ji(),m=u.fallback,Y=r.mode,_e=e.child,Ie=_e.sibling,u=xs(_e,{mode:"hidden",children:u.children}),u.subtreeFlags=_e.subtreeFlags&65011712,Ie!==null?m=xs(Ie,m):(m=ta(m,Y,a,null),m.flags|=2),m.return=r,u.return=r,u.sibling=m,r.child=u,u=m,m=r.child,Y=e.child.memoizedState,Y===null?Y=Uf(a):(_e=Y.cachePool,_e!==null?(Ie=Yn._currentValue,_e=_e.parent!==Ie?{parent:Ie,pool:Ie}:_e):_e=bl(),Y={baseLanes:Y.baseLanes|a,cachePool:_e}),m.memoizedState=Y,m.childLanes=Xu(e,j,a),r.memoizedState=jf,u):(ii(r),a=e.child,e=a.sibling,a=xs(a,{mode:"visible",children:u.children}),a.return=r,a.sibling=null,e!==null&&(j=r.deletions,j===null?(r.deletions=[e],r.flags|=16):j.push(e)),r.child=a,r.memoizedState=null,a)}function fd(e,r){return r=Zu({mode:"visible",children:r},e.mode),r.return=e,e.child=r}function Zu(e,r){return e=Sr(22,e,null,r),e.lanes=0,e.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},e}function pd(e,r,a){return Fo(r,e.child,null,a),e=fd(r,r.pendingProps.children),e.flags|=2,r.memoizedState=null,e}function Ju(e,r,a){e.lanes|=r;var u=e.alternate;u!==null&&(u.lanes|=r),_l(e.return,r,a)}function hd(e,r,a,u,m){var v=e.memoizedState;v===null?e.memoizedState={isBackwards:r,rendering:null,renderingStartTime:0,last:u,tail:a,tailMode:m}:(v.isBackwards=r,v.rendering=null,v.renderingStartTime=0,v.last=u,v.tail=a,v.tailMode=m)}function Vf(e,r,a){var u=r.pendingProps,m=u.revealOrder,v=u.tail;if(pr(e,r,u.children,a),u=dr.current,(u&2)!==0)u=u&1|2,r.flags|=128;else{if(e!==null&&(e.flags&128)!==0)e:for(e=r.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&Ju(e,a,r);else if(e.tag===19)Ju(e,a,r);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===r)break e;for(;e.sibling===null;){if(e.return===null||e.return===r)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}u&=1}switch(Q(dr,u),m){case"forwards":for(a=r.child,m=null;a!==null;)e=a.alternate,e!==null&&Hu(e)===null&&(m=a),a=a.sibling;a=m,a===null?(m=r.child,r.child=null):(m=a.sibling,a.sibling=null),hd(r,!1,m,a,v);break;case"backwards":for(a=null,m=r.child,r.child=null;m!==null;){if(e=m.alternate,e!==null&&Hu(e)===null){r.child=m;break}e=m.sibling,m.sibling=a,a=m,m=e}hd(r,!0,a,null,v);break;case"together":hd(r,!1,null,null,void 0);break;default:r.memoizedState=null}return r.child}function Oa(e,r,a){if(e!==null&&(r.dependencies=e.dependencies),ci|=r.lanes,(a&r.childLanes)===0)if(e!==null){if(Gi(e,r,a,!1),(a&r.childLanes)===0)return null}else return null;if(e!==null&&r.child!==e.child)throw Error(i(153));if(r.child!==null){for(e=r.child,a=xs(e,e.pendingProps),r.child=a,a.return=r;e.sibling!==null;)e=e.sibling,a=a.sibling=xs(e,e.pendingProps),a.return=r;a.sibling=null}return r.child}function zl(e,r){return(e.lanes&r)!==0?!0:(e=e.dependencies,!!(e!==null&&Wi(e)))}function eh(e,r,a){switch(r.tag){case 3:Be(r,r.stateNode.containerInfo),Ns(r,Yn,e.memoizedState.cache),Za();break;case 27:case 5:Oe(r);break;case 4:Be(r,r.stateNode.containerInfo);break;case 10:Ns(r,r.type,r.memoizedProps.value);break;case 13:var u=r.memoizedState;if(u!==null)return u.dehydrated!==null?(ii(r),r.flags|=128,null):(a&r.child.childLanes)!==0?Yu(e,r,a):(ii(r),e=Oa(e,r,a),e!==null?e.sibling:null);ii(r);break;case 19:var m=(e.flags&128)!==0;if(u=(a&r.childLanes)!==0,u||(Gi(e,r,a,!1),u=(a&r.childLanes)!==0),m){if(u)return Vf(e,r,a);r.flags|=128}if(m=r.memoizedState,m!==null&&(m.rendering=null,m.tail=null,m.lastEffect=null),Q(dr,dr.current),u)break;return null;case 22:case 23:return r.lanes=0,cd(e,r,a);case 24:Ns(r,Yn,e.memoizedState.cache)}return Oa(e,r,a)}function Gf(e,r,a){if(e!==null)if(e.memoizedProps!==r.pendingProps)fr=!0;else{if(!zl(e,a)&&(r.flags&128)===0)return fr=!1,eh(e,r,a);fr=(e.flags&131072)!==0}else fr=!1,an&&(r.flags&1048576)!==0&&hl(r,ji,r.index);switch(r.lanes=0,r.tag){case 16:e:{e=r.pendingProps;var u=r.elementType,m=u._init;if(u=m(u._payload),r.type=u,typeof u=="function")bo(u)?(e=eo(u,e),r.tag=1,r=Nf(null,r,u,e,a)):(r.tag=0,r=Qu(null,r,u,e,a));else{if(u!=null){if(m=u.$$typeof,m===O){r.tag=11,r=Jp(null,r,u,e,a);break e}else if(m===A){r.tag=14,r=Ff(null,r,u,e,a);break e}}throw r=ue(u)||u,Error(i(306,r,""))}}return r;case 0:return Qu(e,r,r.type,r.pendingProps,a);case 1:return u=r.type,m=eo(u,r.pendingProps),Nf(e,r,u,m,a);case 3:e:{if(Be(r,r.stateNode.containerInfo),e===null)throw Error(i(387));u=r.pendingProps;var v=r.memoizedState;m=v.element,Oo(e,r),M(r,u,null,a);var j=r.memoizedState;if(u=j.cache,Ns(r,Yn,u),u!==v.cache&&gl(r,[Yn],a,!0),h(),u=j.element,v.isDehydrated)if(v={element:u,isDehydrated:!1,cache:j.cache},r.updateQueue.baseState=v,r.memoizedState=v,r.flags&256){r=dd(e,r,u,a);break e}else if(u!==m){m=kr(Error(i(424)),r),Ja(m),r=dd(e,r,u,a);break e}else{switch(e=r.stateNode.containerInfo,e.nodeType){case 9:e=e.body;break;default:e=e.nodeName==="HTML"?e.ownerDocument.body:e}for(zn=hi(e.firstChild),Mr=r,an=!0,ra=null,ls=!0,a=Pf(r,null,u,a),r.child=a;a;)a.flags=a.flags&-3|4096,a=a.sibling}else{if(Za(),u===m){r=Oa(e,r,a);break e}pr(e,r,u,a)}r=r.child}return r;case 26:return qu(e,r),e===null?(a=yg(r.type,null,r.pendingProps,null))?r.memoizedState=a:an||(a=r.type,e=r.pendingProps,u=fh(ve.current).createElement(a),u[Nn]=r,u[mn]=e,rs(u,a,e),Pn(u),r.stateNode=u):r.memoizedState=yg(r.type,e.memoizedProps,r.pendingProps,e.memoizedState),null;case 27:return Oe(r),e===null&&an&&(u=r.stateNode=mg(r.type,r.pendingProps,ve.current),Mr=r,ls=!0,m=zn,Ql(r.type)?(rm=m,zn=hi(u.firstChild)):zn=m),pr(e,r,r.pendingProps.children,a),qu(e,r),e===null&&(r.flags|=4194304),r.child;case 5:return e===null&&an&&((m=u=zn)&&(u=_T(u,r.type,r.pendingProps,ls),u!==null?(r.stateNode=u,Mr=r,zn=hi(u.firstChild),ls=!1,m=!0):m=!1),m||sa(r)),Oe(r),m=r.type,v=r.pendingProps,j=e!==null?e.memoizedProps:null,u=v.children,Jh(m,v)?u=null:j!==null&&Jh(m,j)&&(r.flags|=32),r.memoizedState!==null&&(m=Du(e,r,Wp,null,null,a),wp._currentValue=m),qu(e,r),pr(e,r,u,a),r.child;case 6:return e===null&&an&&((e=a=zn)&&(a=gT(a,r.pendingProps,ls),a!==null?(r.stateNode=a,Mr=r,zn=null,e=!0):e=!1),e||sa(r)),null;case 13:return Yu(e,r,a);case 4:return Be(r,r.stateNode.containerInfo),u=r.pendingProps,e===null?r.child=Fo(r,null,u,a):pr(e,r,u,a),r.child;case 11:return Jp(e,r,r.type,r.pendingProps,a);case 7:return pr(e,r,r.pendingProps,a),r.child;case 8:return pr(e,r,r.pendingProps.children,a),r.child;case 12:return pr(e,r,r.pendingProps.children,a),r.child;case 10:return u=r.pendingProps,Ns(r,r.type,u.value),pr(e,r,u.children,a),r.child;case 9:return m=r.type._context,u=r.pendingProps.children,Ca(r),m=vr(m),u=u(m),r.flags|=1,pr(e,r,u,a),r.child;case 14:return Ff(e,r,r.type,r.pendingProps,a);case 15:return Lf(e,r,r.type,r.pendingProps,a);case 19:return Vf(e,r,a);case 31:return u=r.pendingProps,a=r.mode,u={mode:u.mode,children:u.children},e===null?(a=Zu(u,a),a.ref=r.ref,r.child=a,a.return=r,r=a):(a=xs(e.child,u),a.ref=r.ref,r.child=a,a.return=r,r=a),r;case 22:return cd(e,r,a);case 24:return Ca(r),u=vr(Yn),e===null?(m=wl(),m===null&&(m=kn,v=yl(),m.pooledCache=v,v.refCount++,v!==null&&(m.pooledCacheLanes|=a),m=v),r.memoizedState={parent:u,cache:m},Xi(r),Ns(r,Yn,m)):((e.lanes&a)!==0&&(Oo(e,r),M(r,null,null,a),h()),m=e.memoizedState,v=r.memoizedState,m.parent!==u?(m={parent:u,cache:u},r.memoizedState=m,r.lanes===0&&(r.memoizedState=r.updateQueue.baseState=m),Ns(r,Yn,u)):(u=v.cache,Ns(r,Yn,u),u!==m.cache&&gl(r,[Yn],a,!0))),pr(e,r,r.pendingProps.children,a),r.child;case 29:throw r.pendingProps}throw Error(i(156,r.tag))}function ka(e){e.flags|=4}function ec(e,r){if(r.type!=="stylesheet"||(r.state.loading&4)!==0)e.flags&=-16777217;else if(e.flags|=16777216,!Tg(r)){if(r=Ps.current,r!==null&&((ln&4194048)===ln?ca!==null:(ln&62914560)!==ln&&(ln&536870912)===0||r!==ca))throw Qi=Tl,Au;e.flags|=8192}}function tc(e,r){r!==null&&(e.flags|=4),e.flags&16384&&(r=e.tag!==22?Hr():536870912,e.lanes|=r,Bo|=r)}function Fl(e,r){if(!an)switch(e.tailMode){case"hidden":r=e.tail;for(var a=null;r!==null;)r.alternate!==null&&(a=r),r=r.sibling;a===null?e.tail=null:a.sibling=null;break;case"collapsed":a=e.tail;for(var u=null;a!==null;)a.alternate!==null&&(u=a),a=a.sibling;u===null?r||e.tail===null?e.tail=null:e.tail.sibling=null:u.sibling=null}}function Un(e){var r=e.alternate!==null&&e.alternate.child===e.child,a=0,u=0;if(r)for(var m=e.child;m!==null;)a|=m.lanes|m.childLanes,u|=m.subtreeFlags&65011712,u|=m.flags&65011712,m.return=e,m=m.sibling;else for(m=e.child;m!==null;)a|=m.lanes|m.childLanes,u|=m.subtreeFlags,u|=m.flags,m.return=e,m=m.sibling;return e.subtreeFlags|=u,e.childLanes=a,r}function th(e,r,a){var u=r.pendingProps;switch(Ui(r),r.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Un(r),null;case 1:return Un(r),null;case 3:return a=r.stateNode,u=null,e!==null&&(u=e.memoizedState.cache),r.memoizedState.cache!==u&&(r.flags|=2048),js(Yn),ut(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),(e===null||e.child===null)&&(Ya(r)?ka(r):e===null||e.memoizedState.isDehydrated&&(r.flags&256)===0||(r.flags|=1024,Co())),Un(r),null;case 26:return a=r.memoizedState,e===null?(ka(r),a!==null?(Un(r),ec(r,a)):(Un(r),r.flags&=-16777217)):a?a!==e.memoizedState?(ka(r),Un(r),ec(r,a)):(Un(r),r.flags&=-16777217):(e.memoizedProps!==u&&ka(r),Un(r),r.flags&=-16777217),null;case 27:ae(r),a=ve.current;var m=r.type;if(e!==null&&r.stateNode!=null)e.memoizedProps!==u&&ka(r);else{if(!u){if(r.stateNode===null)throw Error(i(166));return Un(r),null}e=le.current,Ya(r)?ml(r):(e=mg(m,u,a),r.stateNode=e,ka(r))}return Un(r),null;case 5:if(ae(r),a=r.type,e!==null&&r.stateNode!=null)e.memoizedProps!==u&&ka(r);else{if(!u){if(r.stateNode===null)throw Error(i(166));return Un(r),null}if(e=le.current,Ya(r))ml(r);else{switch(m=fh(ve.current),e){case 1:e=m.createElementNS("http://www.w3.org/2000/svg",a);break;case 2:e=m.createElementNS("http://www.w3.org/1998/Math/MathML",a);break;default:switch(a){case"svg":e=m.createElementNS("http://www.w3.org/2000/svg",a);break;case"math":e=m.createElementNS("http://www.w3.org/1998/Math/MathML",a);break;case"script":e=m.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild);break;case"select":e=typeof u.is=="string"?m.createElement("select",{is:u.is}):m.createElement("select"),u.multiple?e.multiple=!0:u.size&&(e.size=u.size);break;default:e=typeof u.is=="string"?m.createElement(a,{is:u.is}):m.createElement(a)}}e[Nn]=r,e[mn]=u;e:for(m=r.child;m!==null;){if(m.tag===5||m.tag===6)e.appendChild(m.stateNode);else if(m.tag!==4&&m.tag!==27&&m.child!==null){m.child.return=m,m=m.child;continue}if(m===r)break e;for(;m.sibling===null;){if(m.return===null||m.return===r)break e;m=m.return}m.sibling.return=m.return,m=m.sibling}r.stateNode=e;e:switch(rs(e,a,u),a){case"button":case"input":case"select":case"textarea":e=!!u.autoFocus;break e;case"img":e=!0;break e;default:e=!1}e&&ka(r)}}return Un(r),r.flags&=-16777217,null;case 6:if(e&&r.stateNode!=null)e.memoizedProps!==u&&ka(r);else{if(typeof u!="string"&&r.stateNode===null)throw Error(i(166));if(e=ve.current,Ya(r)){if(e=r.stateNode,a=r.memoizedProps,u=null,m=Mr,m!==null)switch(m.tag){case 27:case 5:u=m.memoizedProps}e[Nn]=r,e=!!(e.nodeValue===a||u!==null&&u.suppressHydrationWarning===!0||dh(e.nodeValue,a)),e||sa(r)}else e=fh(e).createTextNode(u),e[Nn]=r,r.stateNode=e}return Un(r),null;case 13:if(u=r.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(m=Ya(r),u!==null&&u.dehydrated!==null){if(e===null){if(!m)throw Error(i(318));if(m=r.memoizedState,m=m!==null?m.dehydrated:null,!m)throw Error(i(317));m[Nn]=r}else Za(),(r.flags&128)===0&&(r.memoizedState=null),r.flags|=4;Un(r),m=!1}else m=Co(),e!==null&&e.memoizedState!==null&&(e.memoizedState.hydrationErrors=m),m=!0;if(!m)return r.flags&256?($a(r),r):($a(r),null)}if($a(r),(r.flags&128)!==0)return r.lanes=a,r;if(a=u!==null,e=e!==null&&e.memoizedState!==null,a){u=r.child,m=null,u.alternate!==null&&u.alternate.memoizedState!==null&&u.alternate.memoizedState.cachePool!==null&&(m=u.alternate.memoizedState.cachePool.pool);var v=null;u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(v=u.memoizedState.cachePool.pool),v!==m&&(u.flags|=2048)}return a!==e&&a&&(r.child.flags|=8192),tc(r,r.updateQueue),Un(r),null;case 4:return ut(),e===null&&dc(r.stateNode.containerInfo),Un(r),null;case 10:return js(r.type),Un(r),null;case 19:if(B(dr),m=r.memoizedState,m===null)return Un(r),null;if(u=(r.flags&128)!==0,v=m.rendering,v===null)if(u)Fl(m,!1);else{if(qn!==0||e!==null&&(e.flags&128)!==0)for(e=r.child;e!==null;){if(v=Hu(e),v!==null){for(r.flags|=128,Fl(m,!1),e=v.updateQueue,r.updateQueue=e,tc(r,e),r.subtreeFlags=0,e=a,a=r.child;a!==null;)To(a,e),a=a.sibling;return Q(dr,dr.current&1|2),r.child}e=e.sibling}m.tail!==null&&We()>lc&&(r.flags|=128,u=!0,Fl(m,!1),r.lanes=4194304)}else{if(!u)if(e=Hu(v),e!==null){if(r.flags|=128,u=!0,e=e.updateQueue,r.updateQueue=e,tc(r,e),Fl(m,!0),m.tail===null&&m.tailMode==="hidden"&&!v.alternate&&!an)return Un(r),null}else 2*We()-m.renderingStartTime>lc&&a!==536870912&&(r.flags|=128,u=!0,Fl(m,!1),r.lanes=4194304);m.isBackwards?(v.sibling=r.child,r.child=v):(e=m.last,e!==null?e.sibling=v:r.child=v,m.last=v)}return m.tail!==null?(r=m.tail,m.rendering=r,m.tail=r.sibling,m.renderingStartTime=We(),r.sibling=null,e=dr.current,Q(dr,u?e&1|2:e&1),r):(Un(r),null);case 22:case 23:return $a(r),je(),u=r.memoizedState!==null,e!==null?e.memoizedState!==null!==u&&(r.flags|=8192):u&&(r.flags|=8192),u?(a&536870912)!==0&&(r.flags&128)===0&&(Un(r),r.subtreeFlags&6&&(r.flags|=8192)):Un(r),a=r.updateQueue,a!==null&&tc(r,a.retryQueue),a=null,e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(a=e.memoizedState.cachePool.pool),u=null,r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(u=r.memoizedState.cachePool.pool),u!==a&&(r.flags|=2048),e!==null&&B(ia),null;case 24:return a=null,e!==null&&(a=e.memoizedState.cache),r.memoizedState.cache!==a&&(r.flags|=2048),js(Yn),Un(r),null;case 25:return null;case 30:return null}throw Error(i(156,r.tag))}function nh(e,r){switch(Ui(r),r.tag){case 1:return e=r.flags,e&65536?(r.flags=e&-65537|128,r):null;case 3:return js(Yn),ut(),e=r.flags,(e&65536)!==0&&(e&128)===0?(r.flags=e&-65537|128,r):null;case 26:case 27:case 5:return ae(r),null;case 13:if($a(r),e=r.memoizedState,e!==null&&e.dehydrated!==null){if(r.alternate===null)throw Error(i(340));Za()}return e=r.flags,e&65536?(r.flags=e&-65537|128,r):null;case 19:return B(dr),null;case 4:return ut(),null;case 10:return js(r.type),null;case 22:case 23:return $a(r),je(),e!==null&&B(ia),e=r.flags,e&65536?(r.flags=e&-65537|128,r):null;case 24:return js(Yn),null;case 25:return null;default:return null}}function Wf(e,r){switch(Ui(r),r.tag){case 3:js(Yn),ut();break;case 26:case 27:case 5:ae(r);break;case 4:ut();break;case 13:$a(r);break;case 19:B(dr);break;case 10:js(r.type);break;case 22:case 23:$a(r),je(),e!==null&&B(ia);break;case 24:js(Yn)}}function Ll(e,r){try{var a=r.updateQueue,u=a!==null?a.lastEffect:null;if(u!==null){var m=u.next;a=m;do{if((a.tag&e)===e){u=void 0;var v=a.create,j=a.inst;u=v(),j.destroy=u}a=a.next}while(a!==m)}}catch(Y){ze(r,r.return,Y)}}function oi(e,r,a){try{var u=r.updateQueue,m=u!==null?u.lastEffect:null;if(m!==null){var v=m.next;u=v;do{if((u.tag&e)===e){var j=u.inst,Y=j.destroy;if(Y!==void 0){j.destroy=void 0,m=r;var _e=a,Ie=Y;try{Ie()}catch(Qe){ze(m,_e,Qe)}}}u=u.next}while(u!==v)}}catch(Qe){ze(r,r.return,Qe)}}function Hf(e){var r=e.updateQueue;if(r!==null){var a=e.stateNode;try{D(r,a)}catch(u){ze(e,e.return,u)}}}function Kf(e,r,a){a.props=eo(e.type,e.memoizedProps),a.state=e.memoizedState;try{a.componentWillUnmount()}catch(u){ze(e,r,u)}}function Lo(e,r){try{var a=e.ref;if(a!==null){switch(e.tag){case 26:case 27:case 5:var u=e.stateNode;break;case 30:u=e.stateNode;break;default:u=e.stateNode}typeof a=="function"?e.refCleanup=a(u):a.current=u}}catch(m){ze(e,r,m)}}function da(e,r){var a=e.ref,u=e.refCleanup;if(a!==null)if(typeof u=="function")try{u()}catch(m){ze(e,r,m)}finally{e.refCleanup=null,e=e.alternate,e!=null&&(e.refCleanup=null)}else if(typeof a=="function")try{a(null)}catch(m){ze(e,r,m)}else a.current=null}function qf(e){var r=e.type,a=e.memoizedProps,u=e.stateNode;try{e:switch(r){case"button":case"input":case"select":case"textarea":a.autoFocus&&u.focus();break e;case"img":a.src?u.src=a.src:a.srcSet&&(u.srcset=a.srcSet)}}catch(m){ze(e,e.return,m)}}function nc(e,r,a){try{var u=e.stateNode;dT(u,e.type,a,r),u[mn]=r}catch(m){ze(e,e.return,m)}}function Qf(e){return e.tag===5||e.tag===3||e.tag===26||e.tag===27&&Ql(e.type)||e.tag===4}function md(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||Qf(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.tag===27&&Ql(e.type)||e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function _d(e,r,a){var u=e.tag;if(u===5||u===6)e=e.stateNode,r?(a.nodeType===9?a.body:a.nodeName==="HTML"?a.ownerDocument.body:a).insertBefore(e,r):(r=a.nodeType===9?a.body:a.nodeName==="HTML"?a.ownerDocument.body:a,r.appendChild(e),a=a._reactRootContainer,a!=null||r.onclick!==null||(r.onclick=Fd));else if(u!==4&&(u===27&&Ql(e.type)&&(a=e.stateNode,r=null),e=e.child,e!==null))for(_d(e,r,a),e=e.sibling;e!==null;)_d(e,r,a),e=e.sibling}function rc(e,r,a){var u=e.tag;if(u===5||u===6)e=e.stateNode,r?a.insertBefore(e,r):a.appendChild(e);else if(u!==4&&(u===27&&Ql(e.type)&&(a=e.stateNode),e=e.child,e!==null))for(rc(e,r,a),e=e.sibling;e!==null;)rc(e,r,a),e=e.sibling}function sc(e){var r=e.stateNode,a=e.memoizedProps;try{for(var u=e.type,m=r.attributes;m.length;)r.removeAttributeNode(m[0]);rs(r,u,a),r[Nn]=e,r[mn]=a}catch(v){ze(e,e.return,v)}}var Da=!1,Jn=!1,gd=!1,Xf=typeof WeakSet=="function"?WeakSet:Set,wr=null;function yd(e,r){if(e=e.containerInfo,Yh=yh,e=Je(e),ul(e)){if("selectionStart"in e)var a={start:e.selectionStart,end:e.selectionEnd};else e:{a=(a=e.ownerDocument)&&a.defaultView||window;var u=a.getSelection&&a.getSelection();if(u&&u.rangeCount!==0){a=u.anchorNode;var m=u.anchorOffset,v=u.focusNode;u=u.focusOffset;try{a.nodeType,v.nodeType}catch{a=null;break e}var j=0,Y=-1,_e=-1,Ie=0,Qe=0,tt=e,Le=null;t:for(;;){for(var Re;tt!==a||m!==0&&tt.nodeType!==3||(Y=j+m),tt!==v||u!==0&&tt.nodeType!==3||(_e=j+u),tt.nodeType===3&&(j+=tt.nodeValue.length),(Re=tt.firstChild)!==null;)Le=tt,tt=Re;for(;;){if(tt===e)break t;if(Le===a&&++Ie===m&&(Y=j),Le===v&&++Qe===u&&(_e=j),(Re=tt.nextSibling)!==null)break;tt=Le,Le=tt.parentNode}tt=Re}a=Y===-1||_e===-1?null:{start:Y,end:_e}}else a=null}a=a||{start:0,end:0}}else a=null;for(Zh={focusedElem:e,selectionRange:a},yh=!1,wr=r;wr!==null;)if(r=wr,e=r.child,(r.subtreeFlags&1024)!==0&&e!==null)e.return=r,wr=e;else for(;wr!==null;){switch(r=wr,v=r.alternate,e=r.flags,r.tag){case 0:break;case 11:case 15:break;case 1:if((e&1024)!==0&&v!==null){e=void 0,a=r,m=v.memoizedProps,v=v.memoizedState,u=a.stateNode;try{var Kt=eo(a.type,m,a.elementType===a.type);e=u.getSnapshotBeforeUpdate(Kt,v),u.__reactInternalSnapshotBeforeUpdate=e}catch(Rt){ze(a,a.return,Rt)}}break;case 3:if((e&1024)!==0){if(e=r.stateNode.containerInfo,a=e.nodeType,a===9)tm(e);else if(a===1)switch(e.nodeName){case"HEAD":case"HTML":case"BODY":tm(e);break;default:e.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((e&1024)!==0)throw Error(i(163))}if(e=r.sibling,e!==null){e.return=r.return,wr=e;break}wr=r.return}}function Yf(e,r,a){var u=a.flags;switch(a.tag){case 0:case 11:case 15:za(e,a),u&4&&Ll(5,a);break;case 1:if(za(e,a),u&4)if(e=a.stateNode,r===null)try{e.componentDidMount()}catch(j){ze(a,a.return,j)}else{var m=eo(a.type,r.memoizedProps);r=r.memoizedState;try{e.componentDidUpdate(m,r,e.__reactInternalSnapshotBeforeUpdate)}catch(j){ze(a,a.return,j)}}u&64&&Hf(a),u&512&&Lo(a,a.return);break;case 3:if(za(e,a),u&64&&(e=a.updateQueue,e!==null)){if(r=null,a.child!==null)switch(a.child.tag){case 27:case 5:r=a.child.stateNode;break;case 1:r=a.child.stateNode}try{D(e,r)}catch(j){ze(a,a.return,j)}}break;case 27:r===null&&u&4&&sc(a);case 26:case 5:za(e,a),r===null&&u&4&&qf(a),u&512&&Lo(a,a.return);break;case 12:za(e,a);break;case 13:za(e,a),u&4&&Jf(e,a),u&64&&(e=a.memoizedState,e!==null&&(e=e.dehydrated,e!==null&&(a=At.bind(null,a),yT(e,a))));break;case 22:if(u=a.memoizedState!==null||Da,!u){r=r!==null&&r.memoizedState!==null||Jn,m=Da;var v=Jn;Da=u,(Jn=r)&&!v?li(e,a,(a.subtreeFlags&8772)!==0):za(e,a),Da=m,Jn=v}break;case 30:break;default:za(e,a)}}function Zf(e){var r=e.alternate;r!==null&&(e.alternate=null,Zf(r)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(r=e.stateNode,r!==null&&vs(r)),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}var Rn=null,ts=!1;function Ia(e,r,a){for(a=a.child;a!==null;)ac(e,r,a),a=a.sibling}function ac(e,r,a){if(De&&typeof De.onCommitFiberUnmount=="function")try{De.onCommitFiberUnmount(Fe,a)}catch{}switch(a.tag){case 26:Jn||da(a,r),Ia(e,r,a),a.memoizedState?a.memoizedState.count--:a.stateNode&&(a=a.stateNode,a.parentNode.removeChild(a));break;case 27:Jn||da(a,r);var u=Rn,m=ts;Ql(a.type)&&(Rn=a.stateNode,ts=!1),Ia(e,r,a),gp(a.stateNode),Rn=u,ts=m;break;case 5:Jn||da(a,r);case 6:if(u=Rn,m=ts,Rn=null,Ia(e,r,a),Rn=u,ts=m,Rn!==null)if(ts)try{(Rn.nodeType===9?Rn.body:Rn.nodeName==="HTML"?Rn.ownerDocument.body:Rn).removeChild(a.stateNode)}catch(v){ze(a,r,v)}else try{Rn.removeChild(a.stateNode)}catch(v){ze(a,r,v)}break;case 18:Rn!==null&&(ts?(e=Rn,pg(e.nodeType===9?e.body:e.nodeName==="HTML"?e.ownerDocument.body:e,a.stateNode),Ep(e)):pg(Rn,a.stateNode));break;case 4:u=Rn,m=ts,Rn=a.stateNode.containerInfo,ts=!0,Ia(e,r,a),Rn=u,ts=m;break;case 0:case 11:case 14:case 15:Jn||oi(2,a,r),Jn||oi(4,a,r),Ia(e,r,a);break;case 1:Jn||(da(a,r),u=a.stateNode,typeof u.componentWillUnmount=="function"&&Kf(a,r,u)),Ia(e,r,a);break;case 21:Ia(e,r,a);break;case 22:Jn=(u=Jn)||a.memoizedState!==null,Ia(e,r,a),Jn=u;break;default:Ia(e,r,a)}}function Jf(e,r){if(r.memoizedState===null&&(e=r.alternate,e!==null&&(e=e.memoizedState,e!==null&&(e=e.dehydrated,e!==null))))try{Ep(e)}catch(a){ze(r,r.return,a)}}function rh(e){switch(e.tag){case 13:case 19:var r=e.stateNode;return r===null&&(r=e.stateNode=new Xf),r;case 22:return e=e.stateNode,r=e._retryCache,r===null&&(r=e._retryCache=new Xf),r;default:throw Error(i(435,e.tag))}}function Md(e,r){var a=rh(e);r.forEach(function(u){var m=Nt.bind(null,e,u);a.has(u)||(a.add(u),u.then(m,m))})}function Gt(e,r){var a=r.deletions;if(a!==null)for(var u=0;u<a.length;u++){var m=a[u],v=e,j=r,Y=j;e:for(;Y!==null;){switch(Y.tag){case 27:if(Ql(Y.type)){Rn=Y.stateNode,ts=!1;break e}break;case 5:Rn=Y.stateNode,ts=!1;break e;case 3:case 4:Rn=Y.stateNode.containerInfo,ts=!0;break e}Y=Y.return}if(Rn===null)throw Error(i(160));ac(v,j,m),Rn=null,ts=!1,v=m.alternate,v!==null&&(v.return=null),m.return=null}if(r.subtreeFlags&13878)for(r=r.child;r!==null;)sh(r,e),r=r.sibling}var fa=null;function sh(e,r){var a=e.alternate,u=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:Gt(r,e),As(e),u&4&&(oi(3,e,e.return),Ll(3,e),oi(5,e,e.return));break;case 1:Gt(r,e),As(e),u&512&&(Jn||a===null||da(a,a.return)),u&64&&Da&&(e=e.updateQueue,e!==null&&(u=e.callbacks,u!==null&&(a=e.shared.hiddenCallbacks,e.shared.hiddenCallbacks=a===null?u:a.concat(u))));break;case 26:var m=fa;if(Gt(r,e),As(e),u&512&&(Jn||a===null||da(a,a.return)),u&4){var v=a!==null?a.memoizedState:null;if(u=e.memoizedState,a===null)if(u===null)if(e.stateNode===null){e:{u=e.type,a=e.memoizedProps,m=m.ownerDocument||m;t:switch(u){case"title":v=m.getElementsByTagName("title")[0],(!v||v[mr]||v[Nn]||v.namespaceURI==="http://www.w3.org/2000/svg"||v.hasAttribute("itemprop"))&&(v=m.createElement(u),m.head.insertBefore(v,m.querySelector("head > title"))),rs(v,u,a),v[Nn]=e,Pn(v),u=v;break e;case"link":var j=wg("link","href",m).get(u+(a.href||""));if(j){for(var Y=0;Y<j.length;Y++)if(v=j[Y],v.getAttribute("href")===(a.href==null||a.href===""?null:a.href)&&v.getAttribute("rel")===(a.rel==null?null:a.rel)&&v.getAttribute("title")===(a.title==null?null:a.title)&&v.getAttribute("crossorigin")===(a.crossOrigin==null?null:a.crossOrigin)){j.splice(Y,1);break t}}v=m.createElement(u),rs(v,u,a),m.head.appendChild(v);break;case"meta":if(j=wg("meta","content",m).get(u+(a.content||""))){for(Y=0;Y<j.length;Y++)if(v=j[Y],v.getAttribute("content")===(a.content==null?null:""+a.content)&&v.getAttribute("name")===(a.name==null?null:a.name)&&v.getAttribute("property")===(a.property==null?null:a.property)&&v.getAttribute("http-equiv")===(a.httpEquiv==null?null:a.httpEquiv)&&v.getAttribute("charset")===(a.charSet==null?null:a.charSet)){j.splice(Y,1);break t}}v=m.createElement(u),rs(v,u,a),m.head.appendChild(v);break;default:throw Error(i(468,u))}v[Nn]=e,Pn(v),u=v}e.stateNode=u}else bg(m,e.type,e.stateNode);else e.stateNode=vg(m,u,e.memoizedProps);else v!==u?(v===null?a.stateNode!==null&&(a=a.stateNode,a.parentNode.removeChild(a)):v.count--,u===null?bg(m,e.type,e.stateNode):vg(m,u,e.memoizedProps)):u===null&&e.stateNode!==null&&nc(e,e.memoizedProps,a.memoizedProps)}break;case 27:Gt(r,e),As(e),u&512&&(Jn||a===null||da(a,a.return)),a!==null&&u&4&&nc(e,e.memoizedProps,a.memoizedProps);break;case 5:if(Gt(r,e),As(e),u&512&&(Jn||a===null||da(a,a.return)),e.flags&32){m=e.stateNode;try{Me(m,"")}catch(Re){ze(e,e.return,Re)}}u&4&&e.stateNode!=null&&(m=e.memoizedProps,nc(e,m,a!==null?a.memoizedProps:m)),u&1024&&(gd=!0);break;case 6:if(Gt(r,e),As(e),u&4){if(e.stateNode===null)throw Error(i(162));u=e.memoizedProps,a=e.stateNode;try{a.nodeValue=u}catch(Re){ze(e,e.return,Re)}}break;case 3:if(mh=null,m=fa,fa=ph(r.containerInfo),Gt(r,e),fa=m,As(e),u&4&&a!==null&&a.memoizedState.isDehydrated)try{Ep(r.containerInfo)}catch(Re){ze(e,e.return,Re)}gd&&(gd=!1,ah(e));break;case 4:u=fa,fa=ph(e.stateNode.containerInfo),Gt(r,e),As(e),fa=u;break;case 12:Gt(r,e),As(e);break;case 13:Gt(r,e),As(e),e.child.flags&8192&&e.memoizedState!==null!=(a!==null&&a.memoizedState!==null)&&(Sd=We()),u&4&&(u=e.updateQueue,u!==null&&(e.updateQueue=null,Md(e,u)));break;case 22:m=e.memoizedState!==null;var _e=a!==null&&a.memoizedState!==null,Ie=Da,Qe=Jn;if(Da=Ie||m,Jn=Qe||_e,Gt(r,e),Jn=Qe,Da=Ie,As(e),u&8192)e:for(r=e.stateNode,r._visibility=m?r._visibility&-2:r._visibility|1,m&&(a===null||_e||Da||Jn||to(e)),a=null,r=e;;){if(r.tag===5||r.tag===26){if(a===null){_e=a=r;try{if(v=_e.stateNode,m)j=v.style,typeof j.setProperty=="function"?j.setProperty("display","none","important"):j.display="none";else{Y=_e.stateNode;var tt=_e.memoizedProps.style,Le=tt!=null&&tt.hasOwnProperty("display")?tt.display:null;Y.style.display=Le==null||typeof Le=="boolean"?"":(""+Le).trim()}}catch(Re){ze(_e,_e.return,Re)}}}else if(r.tag===6){if(a===null){_e=r;try{_e.stateNode.nodeValue=m?"":_e.memoizedProps}catch(Re){ze(_e,_e.return,Re)}}}else if((r.tag!==22&&r.tag!==23||r.memoizedState===null||r===e)&&r.child!==null){r.child.return=r,r=r.child;continue}if(r===e)break e;for(;r.sibling===null;){if(r.return===null||r.return===e)break e;a===r&&(a=null),r=r.return}a===r&&(a=null),r.sibling.return=r.return,r=r.sibling}u&4&&(u=e.updateQueue,u!==null&&(a=u.retryQueue,a!==null&&(u.retryQueue=null,Md(e,a))));break;case 19:Gt(r,e),As(e),u&4&&(u=e.updateQueue,u!==null&&(e.updateQueue=null,Md(e,u)));break;case 30:break;case 21:break;default:Gt(r,e),As(e)}}function As(e){var r=e.flags;if(r&2){try{for(var a,u=e.return;u!==null;){if(Qf(u)){a=u;break}u=u.return}if(a==null)throw Error(i(160));switch(a.tag){case 27:var m=a.stateNode,v=md(e);rc(e,v,m);break;case 5:var j=a.stateNode;a.flags&32&&(Me(j,""),a.flags&=-33);var Y=md(e);rc(e,Y,j);break;case 3:case 4:var _e=a.stateNode.containerInfo,Ie=md(e);_d(e,Ie,_e);break;default:throw Error(i(161))}}catch(Qe){ze(e,e.return,Qe)}e.flags&=-3}r&4096&&(e.flags&=-4097)}function ah(e){if(e.subtreeFlags&1024)for(e=e.child;e!==null;){var r=e;ah(r),r.tag===5&&r.flags&1024&&r.stateNode.reset(),e=e.sibling}}function za(e,r){if(r.subtreeFlags&8772)for(r=r.child;r!==null;)Yf(e,r.alternate,r),r=r.sibling}function to(e){for(e=e.child;e!==null;){var r=e;switch(r.tag){case 0:case 11:case 14:case 15:oi(4,r,r.return),to(r);break;case 1:da(r,r.return);var a=r.stateNode;typeof a.componentWillUnmount=="function"&&Kf(r,r.return,a),to(r);break;case 27:gp(r.stateNode);case 26:case 5:da(r,r.return),to(r);break;case 22:r.memoizedState===null&&to(r);break;case 30:to(r);break;default:to(r)}e=e.sibling}}function li(e,r,a){for(a=a&&(r.subtreeFlags&8772)!==0,r=r.child;r!==null;){var u=r.alternate,m=e,v=r,j=v.flags;switch(v.tag){case 0:case 11:case 15:li(m,v,a),Ll(4,v);break;case 1:if(li(m,v,a),u=v,m=u.stateNode,typeof m.componentDidMount=="function")try{m.componentDidMount()}catch(Ie){ze(u,u.return,Ie)}if(u=v,m=u.updateQueue,m!==null){var Y=u.stateNode;try{var _e=m.shared.hiddenCallbacks;if(_e!==null)for(m.shared.hiddenCallbacks=null,m=0;m<_e.length;m++)$(_e[m],Y)}catch(Ie){ze(u,u.return,Ie)}}a&&j&64&&Hf(v),Lo(v,v.return);break;case 27:sc(v);case 26:case 5:li(m,v,a),a&&u===null&&j&4&&qf(v),Lo(v,v.return);break;case 12:li(m,v,a);break;case 13:li(m,v,a),a&&j&4&&Jf(m,v);break;case 22:v.memoizedState===null&&li(m,v,a),Lo(v,v.return);break;case 30:break;default:li(m,v,a)}r=r.sibling}}function vd(e,r){var a=null;e!==null&&e.memoizedState!==null&&e.memoizedState.cachePool!==null&&(a=e.memoizedState.cachePool.pool),e=null,r.memoizedState!==null&&r.memoizedState.cachePool!==null&&(e=r.memoizedState.cachePool.pool),e!==a&&(e!=null&&e.refCount++,a!=null&&ei(a))}function wd(e,r){e=null,r.alternate!==null&&(e=r.alternate.memoizedState.cache),r=r.memoizedState.cache,r!==e&&(r.refCount++,e!=null&&ei(e))}function Us(e,r,a,u){if(r.subtreeFlags&10256)for(r=r.child;r!==null;)bd(e,r,a,u),r=r.sibling}function bd(e,r,a,u){var m=r.flags;switch(r.tag){case 0:case 11:case 15:Us(e,r,a,u),m&2048&&Ll(9,r);break;case 1:Us(e,r,a,u);break;case 3:Us(e,r,a,u),m&2048&&(e=null,r.alternate!==null&&(e=r.alternate.memoizedState.cache),r=r.memoizedState.cache,r!==e&&(r.refCount++,e!=null&&ei(e)));break;case 12:if(m&2048){Us(e,r,a,u),e=r.stateNode;try{var v=r.memoizedProps,j=v.id,Y=v.onPostCommit;typeof Y=="function"&&Y(j,r.alternate===null?"mount":"update",e.passiveEffectDuration,-0)}catch(_e){ze(r,r.return,_e)}}else Us(e,r,a,u);break;case 13:Us(e,r,a,u);break;case 23:break;case 22:v=r.stateNode,j=r.alternate,r.memoizedState!==null?v._visibility&2?Us(e,r,a,u):Rl(e,r):v._visibility&2?Us(e,r,a,u):(v._visibility|=2,Bl(e,r,a,u,(r.subtreeFlags&10256)!==0)),m&2048&&vd(j,r);break;case 24:Us(e,r,a,u),m&2048&&wd(r.alternate,r);break;default:Us(e,r,a,u)}}function Bl(e,r,a,u,m){for(m=m&&(r.subtreeFlags&10256)!==0,r=r.child;r!==null;){var v=e,j=r,Y=a,_e=u,Ie=j.flags;switch(j.tag){case 0:case 11:case 15:Bl(v,j,Y,_e,m),Ll(8,j);break;case 23:break;case 22:var Qe=j.stateNode;j.memoizedState!==null?Qe._visibility&2?Bl(v,j,Y,_e,m):Rl(v,j):(Qe._visibility|=2,Bl(v,j,Y,_e,m)),m&&Ie&2048&&vd(j.alternate,j);break;case 24:Bl(v,j,Y,_e,m),m&&Ie&2048&&wd(j.alternate,j);break;default:Bl(v,j,Y,_e,m)}r=r.sibling}}function Rl(e,r){if(r.subtreeFlags&10256)for(r=r.child;r!==null;){var a=e,u=r,m=u.flags;switch(u.tag){case 22:Rl(a,u),m&2048&&vd(u.alternate,u);break;case 24:Rl(a,u),m&2048&&wd(u.alternate,u);break;default:Rl(a,u)}r=r.sibling}}var Nl=8192;function no(e){if(e.subtreeFlags&Nl)for(e=e.child;e!==null;)ep(e),e=e.sibling}function ep(e){switch(e.tag){case 26:no(e),e.flags&Nl&&e.memoizedState!==null&&OT(fa,e.memoizedState,e.memoizedProps);break;case 5:no(e);break;case 3:case 4:var r=fa;fa=ph(e.stateNode.containerInfo),no(e),fa=r;break;case 22:e.memoizedState===null&&(r=e.alternate,r!==null&&r.memoizedState!==null?(r=Nl,Nl=16777216,no(e),Nl=r):no(e));break;default:no(e)}}function tp(e){var r=e.alternate;if(r!==null&&(e=r.child,e!==null)){r.child=null;do r=e.sibling,e.sibling=null,e=r;while(e!==null)}}function ic(e){var r=e.deletions;if((e.flags&16)!==0){if(r!==null)for(var a=0;a<r.length;a++){var u=r[a];wr=u,rp(u,e)}tp(e)}if(e.subtreeFlags&10256)for(e=e.child;e!==null;)np(e),e=e.sibling}function np(e){switch(e.tag){case 0:case 11:case 15:ic(e),e.flags&2048&&oi(9,e,e.return);break;case 3:ic(e);break;case 12:ic(e);break;case 22:var r=e.stateNode;e.memoizedState!==null&&r._visibility&2&&(e.return===null||e.return.tag!==13)?(r._visibility&=-3,oc(e)):ic(e);break;default:ic(e)}}function oc(e){var r=e.deletions;if((e.flags&16)!==0){if(r!==null)for(var a=0;a<r.length;a++){var u=r[a];wr=u,rp(u,e)}tp(e)}for(e=e.child;e!==null;){switch(r=e,r.tag){case 0:case 11:case 15:oi(8,r,r.return),oc(r);break;case 22:a=r.stateNode,a._visibility&2&&(a._visibility&=-3,oc(r));break;default:oc(r)}e=e.sibling}}function rp(e,r){for(;wr!==null;){var a=wr;switch(a.tag){case 0:case 11:case 15:oi(8,a,r);break;case 23:case 22:if(a.memoizedState!==null&&a.memoizedState.cachePool!==null){var u=a.memoizedState.cachePool.pool;u!=null&&u.refCount++}break;case 24:ei(a.memoizedState.cache)}if(u=a.child,u!==null)u.return=a,wr=u;else e:for(a=e;wr!==null;){u=wr;var m=u.sibling,v=u.return;if(Zf(u),u===a){wr=null;break e}if(m!==null){m.return=v,wr=m;break e}wr=v}}}var jl={getCacheForType:function(e){var r=vr(Yn),a=r.data.get(e);return a===void 0&&(a=e(),r.data.set(e,a)),a}},ih=typeof WeakMap=="function"?WeakMap:Map,xn=0,kn=null,tn=null,ln=0,En=0,us=null,ui=!1,Ul=!1,Td=!1,Fa=0,qn=0,ci=0,ro=0,xd=0,Vs=0,Bo=0,Ro=null,ns=null,Ed=!1,Sd=0,lc=1/0,uc=null,di=null,Cr=0,fi=null,No=null,jo=0,Cd=0,Pd=null,sp=null,Vl=0,Ad=null;function cs(){if((xn&2)!==0&&ln!==0)return ln&-ln;if(G.T!==null){var e=Pa;return e!==0?e:Gl()}return Hs()}function ap(){Vs===0&&(Vs=(ln&536870912)===0||an?ga():536870912);var e=Ps.current;return e!==null&&(e.flags|=32),Vs}function ds(e,r,a){(e===kn&&(En===2||En===9)||e.cancelPendingCommit!==null)&&(Uo(e,0),pi(e,ln,Vs,!1)),_s(e,a),((xn&2)===0||e!==kn)&&(e===kn&&((xn&2)===0&&(ro|=a),qn===4&&pi(e,ln,Vs,!1)),un(e))}function ip(e,r,a){if((xn&6)!==0)throw Error(i(327));var u=!a&&(r&124)===0&&(r&e.expiredLanes)===0||Kn(e,r),m=u?Vt(e,r):kd(e,r,!0),v=u;do{if(m===0){Ul&&!u&&pi(e,r,0,!1);break}else{if(a=e.current.alternate,v&&!oh(a)){m=kd(e,r,!1),v=!1;continue}if(m===2){if(v=r,e.errorRecoveryDisabledLanes&v)var j=0;else j=e.pendingLanes&-536870913,j=j!==0?j:j&536870912?536870912:0;if(j!==0){r=j;e:{var Y=e;m=Ro;var _e=Y.current.memoizedState.isDehydrated;if(_e&&(Uo(Y,j).flags|=256),j=kd(Y,j,!1),j!==2){if(Td&&!_e){Y.errorRecoveryDisabledLanes|=v,ro|=v,m=4;break e}v=ns,ns=m,v!==null&&(ns===null?ns=v:ns.push.apply(ns,v))}m=j}if(v=!1,m!==2)continue}}if(m===1){Uo(e,0),pi(e,r,0,!0);break}e:{switch(u=e,v=m,v){case 0:case 1:throw Error(i(345));case 4:if((r&4194048)!==r)break;case 6:pi(u,r,Vs,!ui);break e;case 2:ns=null;break;case 3:case 5:break;default:throw Error(i(329))}if((r&62914560)===r&&(m=Sd+300-We(),10<m)){if(pi(u,r,Vs,!ui),hn(u,0,!0)!==0)break e;u.timeoutHandle=dg(op.bind(null,u,a,ns,uc,Ed,r,Vs,ro,Bo,ui,v,2,-0,0),m);break e}op(u,a,ns,uc,Ed,r,Vs,ro,Bo,ui,v,0,-0,0)}}break}while(!0);un(e)}function op(e,r,a,u,m,v,j,Y,_e,Ie,Qe,tt,Le,Re){if(e.timeoutHandle=-1,tt=r.subtreeFlags,(tt&8192||(tt&16785408)===16785408)&&(vp={stylesheets:null,count:0,unsuspend:$T},ep(r),tt=kT(),tt!==null)){e.cancelPendingCommit=tt(dp.bind(null,e,r,v,a,u,m,j,Y,_e,Qe,1,Le,Re)),pi(e,v,j,!Ie);return}dp(e,r,v,a,u,m,j,Y,_e)}function oh(e){for(var r=e;;){var a=r.tag;if((a===0||a===11||a===15)&&r.flags&16384&&(a=r.updateQueue,a!==null&&(a=a.stores,a!==null)))for(var u=0;u<a.length;u++){var m=a[u],v=m.getSnapshot;m=m.value;try{if(!Rr(v(),m))return!1}catch{return!1}}if(a=r.child,r.subtreeFlags&16384&&a!==null)a.return=r,r=a;else{if(r===e)break;for(;r.sibling===null;){if(r.return===null||r.return===e)return!0;r=r.return}r.sibling.return=r.return,r=r.sibling}}return!0}function pi(e,r,a,u){r&=~xd,r&=~ro,e.suspendedLanes|=r,e.pingedLanes&=~r,u&&(e.warmLanes|=r),u=e.expirationTimes;for(var m=r;0<m;){var v=31-He(m),j=1<<v;u[v]=-1,m&=~j}a!==0&&Pt(e,a,r)}function cc(){return(xn&6)===0?(er(0),!1):!0}function $d(){if(tn!==null){if(En===0)var e=tn.return;else e=tn,Cs=aa=null,Kc(e),$l=null,Ol=0,e=tn;for(;e!==null;)Wf(e.alternate,e),e=e.return;tn=null}}function Uo(e,r){var a=e.timeoutHandle;a!==-1&&(e.timeoutHandle=-1,pT(a)),a=e.cancelPendingCommit,a!==null&&(e.cancelPendingCommit=null,a()),$d(),kn=e,tn=a=xs(e.current,null),ln=r,En=0,us=null,ui=!1,Ul=Kn(e,r),Td=!1,Bo=Vs=xd=ro=ci=qn=0,ns=Ro=null,Ed=!1,(r&8)!==0&&(r|=r&32);var u=e.entangledLanes;if(u!==0)for(e=e.entanglements,u&=r;0<u;){var m=31-He(u),v=1<<m;r|=e[m],u&=~v}return Fa=r,zi(),a}function lp(e,r){Xe=null,G.H=zo,r===Ki||r===ni?(r=El(),En=3):r===Au?(r=El(),En=4):En=r===zf?8:r!==null&&typeof r=="object"&&typeof r.then=="function"?6:1,us=r,tn===null&&(qn=1,Ku(e,kr(r,e.current)))}function up(){var e=G.H;return G.H=zo,e===null?zo:e}function cp(){var e=G.A;return G.A=jl,e}function Od(){qn=4,ui||(ln&4194048)!==ln&&Ps.current!==null||(Ul=!0),(ci&134217727)===0&&(ro&134217727)===0||kn===null||pi(kn,ln,Vs,!1)}function kd(e,r,a){var u=xn;xn|=2;var m=up(),v=cp();(kn!==e||ln!==r)&&(uc=null,Uo(e,r)),r=!1;var j=qn;e:do try{if(En!==0&&tn!==null){var Y=tn,_e=us;switch(En){case 8:$d(),j=6;break e;case 3:case 2:case 9:case 6:Ps.current===null&&(r=!0);var Ie=En;if(En=0,us=null,ir(e,Y,_e,Ie),a&&Ul){j=0;break e}break;default:Ie=En,En=0,us=null,ir(e,Y,_e,Ie)}}Xh(),j=qn;break}catch(Qe){lp(e,Qe)}while(!0);return r&&e.shellSuspendCounter++,Cs=aa=null,xn=u,G.H=m,G.A=v,tn===null&&(kn=null,ln=0,zi()),j}function Xh(){for(;tn!==null;)hr(tn)}function Vt(e,r){var a=xn;xn|=2;var u=up(),m=cp();kn!==e||ln!==r?(uc=null,lc=We()+500,Uo(e,r)):Ul=Kn(e,r);e:do try{if(En!==0&&tn!==null){r=tn;var v=us;t:switch(En){case 1:En=0,us=null,ir(e,r,v,1);break;case 2:case 9:if($u(v)){En=0,us=null,br(r);break}r=function(){En!==2&&En!==9||kn!==e||(En=7),un(e)},v.then(r,r);break e;case 3:En=7;break e;case 4:En=5;break e;case 7:$u(v)?(En=0,us=null,br(r)):(En=0,us=null,ir(e,r,v,7));break;case 5:var j=null;switch(tn.tag){case 26:j=tn.memoizedState;case 5:case 27:var Y=tn;if(!j||Tg(j)){En=0,us=null;var _e=Y.sibling;if(_e!==null)tn=_e;else{var Ie=Y.return;Ie!==null?(tn=Ie,La(Ie)):tn=null}break t}}En=0,us=null,ir(e,r,v,5);break;case 6:En=0,us=null,ir(e,r,v,6);break;case 8:$d(),qn=6;break e;default:throw Error(i(462))}}lh();break}catch(Qe){lp(e,Qe)}while(!0);return Cs=aa=null,G.H=u,G.A=m,xn=a,tn!==null?0:(kn=null,ln=0,zi(),qn)}function lh(){for(;tn!==null&&!Ue();)hr(tn)}function hr(e){var r=Gf(e.alternate,e,Fa);e.memoizedProps=e.pendingProps,r===null?La(e):tn=r}function br(e){var r=e,a=r.alternate;switch(r.tag){case 15:case 0:r=Rf(a,r,r.pendingProps,r.type,void 0,ln);break;case 11:r=Rf(a,r,r.pendingProps,r.type.render,r.ref,ln);break;case 5:Kc(r);default:Wf(a,r),r=tn=To(r,Fa),r=Gf(a,r,Fa)}e.memoizedProps=e.pendingProps,r===null?La(e):tn=r}function ir(e,r,a,u){Cs=aa=null,Kc(r),$l=null,Ol=0;var m=r.return;try{if(Zp(e,m,r,a,ln)){qn=1,Ku(e,kr(a,e.current)),tn=null;return}}catch(v){if(m!==null)throw tn=m,v;qn=1,Ku(e,kr(a,e.current)),tn=null;return}r.flags&32768?(an||u===1?e=!0:Ul||(ln&536870912)!==0?e=!1:(ui=e=!0,(u===2||u===9||u===3||u===6)&&(u=Ps.current,u!==null&&u.tag===13&&(u.flags|=16384))),uh(r,e)):La(r)}function La(e){var r=e;do{if((r.flags&32768)!==0){uh(r,ui);return}e=r.return;var a=th(r.alternate,r,Fa);if(a!==null){tn=a;return}if(r=r.sibling,r!==null){tn=r;return}tn=r=e}while(r!==null);qn===0&&(qn=5)}function uh(e,r){do{var a=nh(e.alternate,e);if(a!==null){a.flags&=32767,tn=a;return}if(a=e.return,a!==null&&(a.flags|=32768,a.subtreeFlags=0,a.deletions=null),!r&&(e=e.sibling,e!==null)){tn=e;return}tn=e=a}while(e!==null);qn=6,tn=null}function dp(e,r,a,u,m,v,j,Y,_e){e.cancelPendingCommit=null;do ye();while(Cr!==0);if((xn&6)!==0)throw Error(i(327));if(r!==null){if(r===e.current)throw Error(i(177));if(v=r.lanes|r.childLanes,v|=Ii,gs(e,a,v,j,Y,_e),e===kn&&(tn=kn=null,ln=0),No=r,fi=e,jo=a,Cd=v,Pd=m,sp=u,(r.subtreeFlags&10256)!==0||(r.flags&10256)!==0?(e.callbackNode=null,e.callbackPriority=0,bt(V,function(){return Ae(),null})):(e.callbackNode=null,e.callbackPriority=0),u=(r.flags&13878)!==0,(r.subtreeFlags&13878)!==0||u){u=G.T,G.T=null,m=se.p,se.p=2,j=xn,xn|=4;try{yd(e,r,a)}finally{xn=j,se.p=m,G.T=u}}Cr=1,fp(),P(),z()}}function fp(){if(Cr===1){Cr=0;var e=fi,r=No,a=(r.flags&13878)!==0;if((r.subtreeFlags&13878)!==0||a){a=G.T,G.T=null;var u=se.p;se.p=2;var m=xn;xn|=4;try{sh(r,e);var v=Zh,j=Je(e.containerInfo),Y=v.focusedElem,_e=v.selectionRange;if(j!==Y&&Y&&Y.ownerDocument&&ki(Y.ownerDocument.documentElement,Y)){if(_e!==null&&ul(Y)){var Ie=_e.start,Qe=_e.end;if(Qe===void 0&&(Qe=Ie),"selectionStart"in Y)Y.selectionStart=Ie,Y.selectionEnd=Math.min(Qe,Y.value.length);else{var tt=Y.ownerDocument||document,Le=tt&&tt.defaultView||window;if(Le.getSelection){var Re=Le.getSelection(),Kt=Y.textContent.length,Rt=Math.min(_e.start,Kt),Ln=_e.end===void 0?Rt:Math.min(_e.end,Kt);!Re.extend&&Rt>Ln&&(j=Ln,Ln=Rt,Rt=j);var Ce=ll(Y,Rt),be=ll(Y,Ln);if(Ce&&be&&(Re.rangeCount!==1||Re.anchorNode!==Ce.node||Re.anchorOffset!==Ce.offset||Re.focusNode!==be.node||Re.focusOffset!==be.offset)){var ke=tt.createRange();ke.setStart(Ce.node,Ce.offset),Re.removeAllRanges(),Rt>Ln?(Re.addRange(ke),Re.extend(be.node,be.offset)):(ke.setEnd(be.node,be.offset),Re.addRange(ke))}}}}for(tt=[],Re=Y;Re=Re.parentNode;)Re.nodeType===1&&tt.push({element:Re,left:Re.scrollLeft,top:Re.scrollTop});for(typeof Y.focus=="function"&&Y.focus(),Y=0;Y<tt.length;Y++){var Ze=tt[Y];Ze.element.scrollLeft=Ze.left,Ze.element.scrollTop=Ze.top}}yh=!!Yh,Zh=Yh=null}finally{xn=m,se.p=u,G.T=a}}e.current=r,Cr=2}}function P(){if(Cr===2){Cr=0;var e=fi,r=No,a=(r.flags&8772)!==0;if((r.subtreeFlags&8772)!==0||a){a=G.T,G.T=null;var u=se.p;se.p=2;var m=xn;xn|=4;try{Yf(e,r.alternate,r)}finally{xn=m,se.p=u,G.T=a}}Cr=3}}function z(){if(Cr===4||Cr===3){Cr=0,qe();var e=fi,r=No,a=jo,u=sp;(r.subtreeFlags&10256)!==0||(r.flags&10256)!==0?Cr=5:(Cr=0,No=fi=null,H(e,e.pendingLanes));var m=e.pendingLanes;if(m===0&&(di=null),Ms(a),r=r.stateNode,De&&typeof De.onCommitFiberRoot=="function")try{De.onCommitFiberRoot(Fe,r,void 0,(r.current.flags&128)===128)}catch{}if(u!==null){r=G.T,m=se.p,se.p=2,G.T=null;try{for(var v=e.onRecoverableError,j=0;j<u.length;j++){var Y=u[j];v(Y.value,{componentStack:Y.stack})}}finally{G.T=r,se.p=m}}(jo&3)!==0&&ye(),un(e),m=e.pendingLanes,(a&4194090)!==0&&(m&42)!==0?e===Ad?Vl++:(Vl=0,Ad=e):Vl=0,er(0)}}function H(e,r){(e.pooledCacheLanes&=r)===0&&(r=e.pooledCache,r!=null&&(e.pooledCache=null,ei(r)))}function ye(e){return fp(),P(),z(),Ae()}function Ae(){if(Cr!==5)return!1;var e=fi,r=Cd;Cd=0;var a=Ms(jo),u=G.T,m=se.p;try{se.p=32>a?32:a,G.T=null,a=Pd,Pd=null;var v=fi,j=jo;if(Cr=0,No=fi=null,jo=0,(xn&6)!==0)throw Error(i(331));var Y=xn;if(xn|=4,np(v.current),bd(v,v.current,j,a),xn=Y,er(0,!1),De&&typeof De.onPostCommitFiberRoot=="function")try{De.onPostCommitFiberRoot(Fe,v)}catch{}return!0}finally{se.p=m,G.T=u,H(e,r)}}function Pe(e,r,a){r=kr(a,r),r=Il(e.stateNode,r,2),e=ua(e,r,2),e!==null&&(_s(e,2),un(e))}function ze(e,r,a){if(e.tag===3)Pe(e,e,a);else for(;r!==null;){if(r.tag===3){Pe(r,e,a);break}else if(r.tag===1){var u=r.stateNode;if(typeof r.type.getDerivedStateFromError=="function"||typeof u.componentDidCatch=="function"&&(di===null||!di.has(u))){e=kr(a,e),a=Df(2),u=ua(r,a,2),u!==null&&(If(a,u,r,e),_s(u,2),un(u));break}}r=r.return}}function et(e,r,a){var u=e.pingCache;if(u===null){u=e.pingCache=new ih;var m=new Set;u.set(r,m)}else m=u.get(r),m===void 0&&(m=new Set,u.set(r,m));m.has(a)||(Td=!0,m.add(a),e=dt.bind(null,e,r,a),r.then(e,e))}function dt(e,r,a){var u=e.pingCache;u!==null&&u.delete(r),e.pingedLanes|=e.suspendedLanes&a,e.warmLanes&=~a,kn===e&&(ln&a)===a&&(qn===4||qn===3&&(ln&62914560)===ln&&300>We()-Sd?(xn&2)===0&&Uo(e,0):xd|=a,Bo===ln&&(Bo=0)),un(e)}function gt(e,r){r===0&&(r=Hr()),e=xa(e,r),e!==null&&(_s(e,r),un(e))}function At(e){var r=e.memoizedState,a=0;r!==null&&(a=r.retryLane),gt(e,a)}function Nt(e,r){var a=0;switch(e.tag){case 13:var u=e.stateNode,m=e.memoizedState;m!==null&&(a=m.retryLane);break;case 19:u=e.stateNode;break;case 22:u=e.stateNode._retryCache;break;default:throw Error(i(314))}u!==null&&u.delete(r),gt(e,a)}function bt(e,r){return Ee(e,r)}var Wt=null,wt=null,jt=!1,$t=!1,Ht=!1,rn=0;function un(e){e!==wt&&e.next===null&&(wt===null?Wt=wt=e:wt=wt.next=e),$t=!0,jt||(jt=!0,so())}function er(e,r){if(!Ht&&$t){Ht=!0;do for(var a=!1,u=Wt;u!==null;){if(e!==0){var m=u.pendingLanes;if(m===0)var v=0;else{var j=u.suspendedLanes,Y=u.pingedLanes;v=(1<<31-He(42|e)+1)-1,v&=m&~(j&~Y),v=v&201326741?v&201326741|1:v?v|2:0}v!==0&&(a=!0,fs(u,v))}else v=ln,v=hn(u,u===kn?v:0,u.cancelPendingCommit!==null||u.timeoutHandle!==-1),(v&3)===0||Kn(u,v)||(a=!0,fs(u,v));u=u.next}while(a);Ht=!1}}function Qt(){Sn()}function Sn(){$t=jt=!1;var e=0;rn!==0&&(fT()&&(e=rn),rn=0);for(var r=We(),a=null,u=Wt;u!==null;){var m=u.next,v=Vn(u,r);v===0?(u.next=null,a===null?Wt=m:a.next=m,m===null&&(wt=a)):(a=u,(e!==0||(v&3)!==0)&&($t=!0)),u=m}er(e)}function Vn(e,r){for(var a=e.suspendedLanes,u=e.pingedLanes,m=e.expirationTimes,v=e.pendingLanes&-62914561;0<v;){var j=31-He(v),Y=1<<j,_e=m[j];_e===-1?((Y&a)===0||(Y&u)!==0)&&(m[j]=Ws(Y,r)):_e<=r&&(e.expiredLanes|=Y),v&=~Y}if(r=kn,a=ln,a=hn(e,e===r?a:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),u=e.callbackNode,a===0||e===r&&(En===2||En===9)||e.cancelPendingCommit!==null)return u!==null&&u!==null&&Ve(u),e.callbackNode=null,e.callbackPriority=0;if((a&3)===0||Kn(e,a)){if(r=a&-a,r===e.callbackPriority)return r;switch(u!==null&&Ve(u),Ms(a)){case 2:case 8:a=ct;break;case 32:a=V;break;case 268435456:a=q;break;default:a=V}return u=tr.bind(null,e),a=Ee(a,u),e.callbackPriority=r,e.callbackNode=a,r}return u!==null&&u!==null&&Ve(u),e.callbackPriority=2,e.callbackNode=null,2}function tr(e,r){if(Cr!==0&&Cr!==5)return e.callbackNode=null,e.callbackPriority=0,null;var a=e.callbackNode;if(ye()&&e.callbackNode!==a)return null;var u=ln;return u=hn(e,e===kn?u:0,e.cancelPendingCommit!==null||e.timeoutHandle!==-1),u===0?null:(ip(e,u,r),Vn(e,We()),e.callbackNode!=null&&e.callbackNode===a?tr.bind(null,e):null)}function fs(e,r){if(ye())return null;ip(e,r,!0)}function so(){hT(function(){(xn&6)!==0?Ee(at,Qt):Sn()})}function Gl(){return rn===0&&(rn=ga()),rn}function Dr(e){return e==null||typeof e=="symbol"||typeof e=="boolean"?null:typeof e=="function"?e:kt(""+e)}function pa(e,r){var a=r.ownerDocument.createElement("input");return a.name=r.name,a.value=r.value,e.id&&a.setAttribute("form",e.id),r.parentNode.insertBefore(a,r),e=new FormData(e),a.parentNode.removeChild(a),e}function pp(e,r,a,u,m){if(r==="submit"&&a&&a.stateNode===m){var v=Dr((m[mn]||null).action),j=u.submitter;j&&(r=(r=j[mn]||null)?Dr(r.formAction):j.getAttribute("formAction"),r!==null&&(v=r,j=null));var Y=new In("action","action",null,u,m);e.push({event:Y,listeners:[{instance:null,listener:function(){if(u.defaultPrevented){if(rn!==0){var _e=j?pa(m,j):new FormData(m);ju(a,{pending:!0,data:_e,method:m.method,action:v},null,_e)}}else typeof v=="function"&&(Y.preventDefault(),_e=j?pa(m,j):new FormData(m),ju(a,{pending:!0,data:_e,method:m.method,action:v},v,_e))},currentTarget:m}]})}}for(var Wl=0;Wl<Di.length;Wl++){var Hl=Di[Wl],Dd=Hl.toLowerCase(),Fn=Hl[0].toUpperCase()+Hl.slice(1);Jr(Dd,"on"+Fn)}Jr(cl,"onAnimationEnd"),Jr(Lt,"onAnimationIteration"),Jr(Ta,"onAnimationStart"),Jr("dblclick","onDoubleClick"),Jr("focusin","onFocus"),Jr("focusout","onBlur"),Jr(xu,"onTransitionRun"),Jr(It,"onTransitionStart"),Jr(wo,"onTransitionCancel"),Jr(zt,"onTransitionEnd"),ws("onMouseEnter",["mouseout","mouseover"]),ws("onMouseLeave",["mouseout","mouseover"]),ws("onPointerEnter",["pointerout","pointerover"]),ws("onPointerLeave",["pointerout","pointerover"]),as("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),as("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),as("onBeforeInput",["compositionend","keypress","textInput","paste"]),as("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),as("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),as("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Gn="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),ao=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Gn));function io(e,r){r=(r&4)!==0;for(var a=0;a<e.length;a++){var u=e[a],m=u.event;u=u.listeners;e:{var v=void 0;if(r)for(var j=u.length-1;0<=j;j--){var Y=u[j],_e=Y.instance,Ie=Y.currentTarget;if(Y=Y.listener,_e!==v&&m.isPropagationStopped())break e;v=Y,m.currentTarget=Ie;try{v(m)}catch(Qe){Dl(Qe)}m.currentTarget=null,v=_e}else for(j=0;j<u.length;j++){if(Y=u[j],_e=Y.instance,Ie=Y.currentTarget,Y=Y.listener,_e!==v&&m.isPropagationStopped())break e;v=Y,m.currentTarget=Ie;try{v(m)}catch(Qe){Dl(Qe)}m.currentTarget=null,v=_e}}}}function Yt(e,r){var a=r[yt];a===void 0&&(a=r[yt]=new Set);var u=e+"__bubble";a.has(u)||(Id(r,e,2,!1),a.add(u))}function Kl(e,r,a){var u=0;r&&(u|=4),Id(a,e,u,r)}var ql="_reactListening"+Math.random().toString(36).slice(2);function dc(e){if(!e[ql]){e[ql]=!0,Ks.forEach(function(a){a!=="selectionchange"&&(ao.has(a)||Kl(a,!1,e),Kl(a,!0,e))});var r=e.nodeType===9?e:e.ownerDocument;r===null||r[ql]||(r[ql]=!0,Kl("selectionchange",!1,r))}}function Id(e,r,a,u){switch(Ag(r)){case 2:var m=zT;break;case 8:m=FT;break;default:m=lm}a=m.bind(null,r,a,e),m=void 0,!bs||r!=="touchstart"&&r!=="touchmove"&&r!=="wheel"||(m=!0),u?m!==void 0?e.addEventListener(r,a,{capture:!0,passive:m}):e.addEventListener(r,a,!0):m!==void 0?e.addEventListener(r,a,{passive:m}):e.addEventListener(r,a,!1)}function hp(e,r,a,u,m){var v=u;if((r&1)===0&&(r&2)===0&&u!==null)e:for(;;){if(u===null)return;var j=u.tag;if(j===3||j===4){var Y=u.stateNode.containerInfo;if(Y===m)break;if(j===4)for(j=u.return;j!==null;){var _e=j.tag;if((_e===3||_e===4)&&j.stateNode.containerInfo===m)return;j=j.return}for(;Y!==null;){if(j=Fr(Y),j===null)return;if(_e=j.tag,_e===5||_e===6||_e===26||_e===27){u=v=j;continue e}Y=Y.parentNode}}u=u.return}yr(function(){var Ie=v,Qe=sn(a),tt=[];e:{var Le=dl.get(e);if(Le!==void 0){var Re=In,Kt=e;switch(e){case"keypress":if(On(a)===0)break e;case"keydown":case"keyup":Re=Oc;break;case"focusin":Kt="focus",Re=Xo;break;case"focusout":Kt="blur",Re=Xo;break;case"beforeblur":case"afterblur":Re=Xo;break;case"click":if(a.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Re=Fs;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Re=Cc;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Re=Dc;break;case cl:case Lt:case Ta:Re=ou;break;case zt:Re=hu;break;case"scroll":case"scrollend":Re=Pi;break;case"wheel":Re=Ic;break;case"copy":case"cut":case"paste":Re=Ac;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Re=fu;break;case"toggle":case"beforetoggle":Re=tl}var Rt=(r&4)!==0,Ln=!Rt&&(e==="scroll"||e==="scrollend"),Ce=Rt?Le!==null?Le+"Capture":null:Le;Rt=[];for(var be=Ie,ke;be!==null;){var Ze=be;if(ke=Ze.stateNode,Ze=Ze.tag,Ze!==5&&Ze!==26&&Ze!==27||ke===null||Ce===null||(Ze=Br(be,Ce),Ze!=null&&Rt.push(Vo(be,Ze,ke))),Ln)break;be=be.return}0<Rt.length&&(Le=new Re(Le,Kt,null,a,Qe),tt.push({event:Le,listeners:Rt}))}}if((r&7)===0){e:{if(Le=e==="mouseover"||e==="pointerover",Re=e==="mouseout"||e==="pointerout",Le&&a!==Zt&&(Kt=a.relatedTarget||a.fromElement)&&(Fr(Kt)||Kt[st]))break e;if((Re||Le)&&(Le=Qe.window===Qe?Qe:(Le=Qe.ownerDocument)?Le.defaultView||Le.parentWindow:window,Re?(Kt=a.relatedTarget||a.toElement,Re=Ie,Kt=Kt?Fr(Kt):null,Kt!==null&&(Ln=o(Kt),Rt=Kt.tag,Kt!==Ln||Rt!==5&&Rt!==27&&Rt!==6)&&(Kt=null)):(Re=null,Kt=Ie),Re!==Kt)){if(Rt=Fs,Ze="onMouseLeave",Ce="onMouseEnter",be="mouse",(e==="pointerout"||e==="pointerover")&&(Rt=fu,Ze="onPointerLeave",Ce="onPointerEnter",be="pointer"),Ln=Re==null?Le:qr(Re),ke=Kt==null?Le:qr(Kt),Le=new Rt(Ze,be+"leave",Re,a,Qe),Le.target=Ln,Le.relatedTarget=ke,Ze=null,Fr(Qe)===Ie&&(Rt=new Rt(Ce,be+"enter",Kt,a,Qe),Rt.target=ke,Rt.relatedTarget=Ln,Ze=Rt),Ln=Ze,Re&&Kt)t:{for(Rt=Re,Ce=Kt,be=0,ke=Rt;ke;ke=oo(ke))be++;for(ke=0,Ze=Ce;Ze;Ze=oo(Ze))ke++;for(;0<be-ke;)Rt=oo(Rt),be--;for(;0<ke-be;)Ce=oo(Ce),ke--;for(;be--;){if(Rt===Ce||Ce!==null&&Rt===Ce.alternate)break t;Rt=oo(Rt),Ce=oo(Ce)}Rt=null}else Rt=null;Re!==null&&mp(tt,Le,Re,Rt,!1),Kt!==null&&Ln!==null&&mp(tt,Ln,Kt,Rt,!0)}}e:{if(Le=Ie?qr(Ie):window,Re=Le.nodeName&&Le.nodeName.toLowerCase(),Re==="select"||Re==="input"&&Le.type==="file")var St=Ka;else if(Mu(Le))if(nl)St=bu;else{St=al;var on=vu}else Re=Le.nodeName,!Re||Re.toLowerCase()!=="input"||Le.type!=="checkbox"&&Le.type!=="radio"?Ie&&ht(Ie.elementType)&&(St=Ka):St=wu;if(St&&(St=St(e,Ie))){mo(tt,St,a,Qe);break e}on&&on(e,Le,Ie),e==="focusout"&&Ie&&Le.type==="number"&&Ie.memoizedProps.value!=null&&Te(Le,"number",Le.value)}switch(on=Ie?qr(Ie):window,e){case"focusin":(Mu(on)||on.contentEditable==="true")&&(Ys=on,Qa=Ie,Or=null);break;case"focusout":Or=Qa=Ys=null;break;case"mousedown":ba=!0;break;case"contextmenu":case"mouseup":case"dragend":ba=!1,yo(tt,a,Qe);break;case"selectionchange":if(Tu)break;case"keydown":case"keyup":yo(tt,a,Qe)}var Dt;if(Qs)e:{switch(e){case"compositionstart":var Ut="onCompositionStart";break e;case"compositionend":Ut="onCompositionEnd";break e;case"compositionupdate":Ut="onCompositionUpdate";break e}Ut=void 0}else Ha?po(e,a)&&(Ut="onCompositionEnd"):e==="keydown"&&a.keyCode===229&&(Ut="onCompositionStart");Ut&&(zc&&a.locale!=="ko"&&(Ha||Ut!=="onCompositionStart"?Ut==="onCompositionEnd"&&Ha&&(Dt=zs()):(bn=Qe,ur="value"in bn?bn.value:bn.textContent,Ha=!0)),on=Go(Ie,Ut),0<on.length&&(Ut=new lu(Ut,e,null,a,Qe),tt.push({event:Ut,listeners:on}),Dt?Ut.data=Dt:(Dt=ho(a),Dt!==null&&(Ut.data=Dt)))),(Dt=gu?Lc(e,a):Bc(e,a))&&(Ut=Go(Ie,"onBeforeInput"),0<Ut.length&&(on=new lu("onBeforeInput","beforeinput",null,a,Qe),tt.push({event:on,listeners:Ut}),on.data=Dt)),pp(tt,e,Ie,a,Qe)}io(tt,r)})}function Vo(e,r,a){return{instance:e,listener:r,currentTarget:a}}function Go(e,r){for(var a=r+"Capture",u=[];e!==null;){var m=e,v=m.stateNode;if(m=m.tag,m!==5&&m!==26&&m!==27||v===null||(m=Br(e,a),m!=null&&u.unshift(Vo(e,m,v)),m=Br(e,r),m!=null&&u.push(Vo(e,m,v))),e.tag===3)return u;e=e.return}return[]}function oo(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5&&e.tag!==27);return e||null}function mp(e,r,a,u,m){for(var v=r._reactName,j=[];a!==null&&a!==u;){var Y=a,_e=Y.alternate,Ie=Y.stateNode;if(Y=Y.tag,_e!==null&&_e===u)break;Y!==5&&Y!==26&&Y!==27||Ie===null||(_e=Ie,m?(Ie=Br(a,v),Ie!=null&&j.unshift(Vo(a,Ie,_e))):m||(Ie=Br(a,v),Ie!=null&&j.push(Vo(a,Ie,_e)))),a=a.return}j.length!==0&&e.push({event:r,listeners:j})}var _p=/\r\n?/g,zd=/\u0000|\uFFFD/g;function ch(e){return(typeof e=="string"?e:""+e).replace(_p,`
`).replace(zd,"")}function dh(e,r){return r=ch(r),ch(e)===r}function Fd(){}function cn(e,r,a,u,m,v){switch(a){case"children":typeof u=="string"?r==="body"||r==="textarea"&&u===""||Me(e,u):(typeof u=="number"||typeof u=="bigint")&&r!=="body"&&Me(e,""+u);break;case"className":Ar(e,"class",u);break;case"tabIndex":Ar(e,"tabindex",u);break;case"dir":case"role":case"viewBox":case"width":case"height":Ar(e,a,u);break;case"style":lt(e,u,v);break;case"data":if(r!=="object"){Ar(e,"data",u);break}case"src":case"href":if(u===""&&(r!=="a"||a!=="href")){e.removeAttribute(a);break}if(u==null||typeof u=="function"||typeof u=="symbol"||typeof u=="boolean"){e.removeAttribute(a);break}u=kt(""+u),e.setAttribute(a,u);break;case"action":case"formAction":if(typeof u=="function"){e.setAttribute(a,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof v=="function"&&(a==="formAction"?(r!=="input"&&cn(e,r,"name",m.name,m,null),cn(e,r,"formEncType",m.formEncType,m,null),cn(e,r,"formMethod",m.formMethod,m,null),cn(e,r,"formTarget",m.formTarget,m,null)):(cn(e,r,"encType",m.encType,m,null),cn(e,r,"method",m.method,m,null),cn(e,r,"target",m.target,m,null)));if(u==null||typeof u=="symbol"||typeof u=="boolean"){e.removeAttribute(a);break}u=kt(""+u),e.setAttribute(a,u);break;case"onClick":u!=null&&(e.onclick=Fd);break;case"onScroll":u!=null&&Yt("scroll",e);break;case"onScrollEnd":u!=null&&Yt("scrollend",e);break;case"dangerouslySetInnerHTML":if(u!=null){if(typeof u!="object"||!("__html"in u))throw Error(i(61));if(a=u.__html,a!=null){if(m.children!=null)throw Error(i(60));e.innerHTML=a}}break;case"multiple":e.multiple=u&&typeof u!="function"&&typeof u!="symbol";break;case"muted":e.muted=u&&typeof u!="function"&&typeof u!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(u==null||typeof u=="function"||typeof u=="boolean"||typeof u=="symbol"){e.removeAttribute("xlink:href");break}a=kt(""+u),e.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",a);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":u!=null&&typeof u!="function"&&typeof u!="symbol"?e.setAttribute(a,""+u):e.removeAttribute(a);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":u&&typeof u!="function"&&typeof u!="symbol"?e.setAttribute(a,""):e.removeAttribute(a);break;case"capture":case"download":u===!0?e.setAttribute(a,""):u!==!1&&u!=null&&typeof u!="function"&&typeof u!="symbol"?e.setAttribute(a,u):e.removeAttribute(a);break;case"cols":case"rows":case"size":case"span":u!=null&&typeof u!="function"&&typeof u!="symbol"&&!isNaN(u)&&1<=u?e.setAttribute(a,u):e.removeAttribute(a);break;case"rowSpan":case"start":u==null||typeof u=="function"||typeof u=="symbol"||isNaN(u)?e.removeAttribute(a):e.setAttribute(a,u);break;case"popover":Yt("beforetoggle",e),Yt("toggle",e),qs(e,"popover",u);break;case"xlinkActuate":Tr(e,"http://www.w3.org/1999/xlink","xlink:actuate",u);break;case"xlinkArcrole":Tr(e,"http://www.w3.org/1999/xlink","xlink:arcrole",u);break;case"xlinkRole":Tr(e,"http://www.w3.org/1999/xlink","xlink:role",u);break;case"xlinkShow":Tr(e,"http://www.w3.org/1999/xlink","xlink:show",u);break;case"xlinkTitle":Tr(e,"http://www.w3.org/1999/xlink","xlink:title",u);break;case"xlinkType":Tr(e,"http://www.w3.org/1999/xlink","xlink:type",u);break;case"xmlBase":Tr(e,"http://www.w3.org/XML/1998/namespace","xml:base",u);break;case"xmlLang":Tr(e,"http://www.w3.org/XML/1998/namespace","xml:lang",u);break;case"xmlSpace":Tr(e,"http://www.w3.org/XML/1998/namespace","xml:space",u);break;case"is":qs(e,"is",u);break;case"innerText":case"textContent":break;default:(!(2<a.length)||a[0]!=="o"&&a[0]!=="O"||a[1]!=="n"&&a[1]!=="N")&&(a=ft.get(a)||a,qs(e,a,u))}}function $s(e,r,a,u,m,v){switch(a){case"style":lt(e,u,v);break;case"dangerouslySetInnerHTML":if(u!=null){if(typeof u!="object"||!("__html"in u))throw Error(i(61));if(a=u.__html,a!=null){if(m.children!=null)throw Error(i(60));e.innerHTML=a}}break;case"children":typeof u=="string"?Me(e,u):(typeof u=="number"||typeof u=="bigint")&&Me(e,""+u);break;case"onScroll":u!=null&&Yt("scroll",e);break;case"onScrollEnd":u!=null&&Yt("scrollend",e);break;case"onClick":u!=null&&(e.onclick=Fd);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Ua.hasOwnProperty(a))e:{if(a[0]==="o"&&a[1]==="n"&&(m=a.endsWith("Capture"),r=a.slice(2,m?a.length-7:void 0),v=e[mn]||null,v=v!=null?v[a]:null,typeof v=="function"&&e.removeEventListener(r,v,m),typeof u=="function")){typeof v!="function"&&v!==null&&(a in e?e[a]=null:e.hasAttribute(a)&&e.removeAttribute(a)),e.addEventListener(r,u,m);break e}a in e?e[a]=u:u===!0?e.setAttribute(a,""):qs(e,a,u)}}}function rs(e,r,a){switch(r){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":Yt("error",e),Yt("load",e);var u=!1,m=!1,v;for(v in a)if(a.hasOwnProperty(v)){var j=a[v];if(j!=null)switch(v){case"src":u=!0;break;case"srcSet":m=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(i(137,r));default:cn(e,r,v,j,a,null)}}m&&cn(e,r,"srcSet",a.srcSet,a,null),u&&cn(e,r,"src",a.src,a,null);return;case"input":Yt("invalid",e);var Y=v=j=m=null,_e=null,Ie=null;for(u in a)if(a.hasOwnProperty(u)){var Qe=a[u];if(Qe!=null)switch(u){case"name":m=Qe;break;case"type":j=Qe;break;case"checked":_e=Qe;break;case"defaultChecked":Ie=Qe;break;case"value":v=Qe;break;case"defaultValue":Y=Qe;break;case"children":case"dangerouslySetInnerHTML":if(Qe!=null)throw Error(i(137,r));break;default:cn(e,r,u,Qe,a,null)}}Ci(e,v,Y,_e,Ie,j,m,!1),Yr(e);return;case"select":Yt("invalid",e),u=j=v=null;for(m in a)if(a.hasOwnProperty(m)&&(Y=a[m],Y!=null))switch(m){case"value":v=Y;break;case"defaultValue":j=Y;break;case"multiple":u=Y;default:cn(e,r,m,Y,a,null)}r=v,a=j,e.multiple=!!u,r!=null?N(e,!!u,r,!1):a!=null&&N(e,!!u,a,!0);return;case"textarea":Yt("invalid",e),v=m=u=null;for(j in a)if(a.hasOwnProperty(j)&&(Y=a[j],Y!=null))switch(j){case"value":u=Y;break;case"defaultValue":m=Y;break;case"children":v=Y;break;case"dangerouslySetInnerHTML":if(Y!=null)throw Error(i(91));break;default:cn(e,r,j,Y,a,null)}de(e,u,m,v),Yr(e);return;case"option":for(_e in a)if(a.hasOwnProperty(_e)&&(u=a[_e],u!=null))switch(_e){case"selected":e.selected=u&&typeof u!="function"&&typeof u!="symbol";break;default:cn(e,r,_e,u,a,null)}return;case"dialog":Yt("beforetoggle",e),Yt("toggle",e),Yt("cancel",e),Yt("close",e);break;case"iframe":case"object":Yt("load",e);break;case"video":case"audio":for(u=0;u<Gn.length;u++)Yt(Gn[u],e);break;case"image":Yt("error",e),Yt("load",e);break;case"details":Yt("toggle",e);break;case"embed":case"source":case"link":Yt("error",e),Yt("load",e);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(Ie in a)if(a.hasOwnProperty(Ie)&&(u=a[Ie],u!=null))switch(Ie){case"children":case"dangerouslySetInnerHTML":throw Error(i(137,r));default:cn(e,r,Ie,u,a,null)}return;default:if(ht(r)){for(Qe in a)a.hasOwnProperty(Qe)&&(u=a[Qe],u!==void 0&&$s(e,r,Qe,u,a,void 0));return}}for(Y in a)a.hasOwnProperty(Y)&&(u=a[Y],u!=null&&cn(e,r,Y,u,a,null))}function dT(e,r,a,u){switch(r){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var m=null,v=null,j=null,Y=null,_e=null,Ie=null,Qe=null;for(Re in a){var tt=a[Re];if(a.hasOwnProperty(Re)&&tt!=null)switch(Re){case"checked":break;case"value":break;case"defaultValue":_e=tt;default:u.hasOwnProperty(Re)||cn(e,r,Re,null,u,tt)}}for(var Le in u){var Re=u[Le];if(tt=a[Le],u.hasOwnProperty(Le)&&(Re!=null||tt!=null))switch(Le){case"type":v=Re;break;case"name":m=Re;break;case"checked":Ie=Re;break;case"defaultChecked":Qe=Re;break;case"value":j=Re;break;case"defaultValue":Y=Re;break;case"children":case"dangerouslySetInnerHTML":if(Re!=null)throw Error(i(137,r));break;default:Re!==tt&&cn(e,r,Le,Re,u,tt)}}Is(e,j,Y,_e,Ie,Qe,v,m);return;case"select":Re=j=Y=Le=null;for(v in a)if(_e=a[v],a.hasOwnProperty(v)&&_e!=null)switch(v){case"value":break;case"multiple":Re=_e;default:u.hasOwnProperty(v)||cn(e,r,v,null,u,_e)}for(m in u)if(v=u[m],_e=a[m],u.hasOwnProperty(m)&&(v!=null||_e!=null))switch(m){case"value":Le=v;break;case"defaultValue":Y=v;break;case"multiple":j=v;default:v!==_e&&cn(e,r,m,v,u,_e)}r=Y,a=j,u=Re,Le!=null?N(e,!!a,Le,!1):!!u!=!!a&&(r!=null?N(e,!!a,r,!0):N(e,!!a,a?[]:"",!1));return;case"textarea":Re=Le=null;for(Y in a)if(m=a[Y],a.hasOwnProperty(Y)&&m!=null&&!u.hasOwnProperty(Y))switch(Y){case"value":break;case"children":break;default:cn(e,r,Y,null,u,m)}for(j in u)if(m=u[j],v=a[j],u.hasOwnProperty(j)&&(m!=null||v!=null))switch(j){case"value":Le=m;break;case"defaultValue":Re=m;break;case"children":break;case"dangerouslySetInnerHTML":if(m!=null)throw Error(i(91));break;default:m!==v&&cn(e,r,j,m,u,v)}ee(e,Le,Re);return;case"option":for(var Kt in a)if(Le=a[Kt],a.hasOwnProperty(Kt)&&Le!=null&&!u.hasOwnProperty(Kt))switch(Kt){case"selected":e.selected=!1;break;default:cn(e,r,Kt,null,u,Le)}for(_e in u)if(Le=u[_e],Re=a[_e],u.hasOwnProperty(_e)&&Le!==Re&&(Le!=null||Re!=null))switch(_e){case"selected":e.selected=Le&&typeof Le!="function"&&typeof Le!="symbol";break;default:cn(e,r,_e,Le,u,Re)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var Rt in a)Le=a[Rt],a.hasOwnProperty(Rt)&&Le!=null&&!u.hasOwnProperty(Rt)&&cn(e,r,Rt,null,u,Le);for(Ie in u)if(Le=u[Ie],Re=a[Ie],u.hasOwnProperty(Ie)&&Le!==Re&&(Le!=null||Re!=null))switch(Ie){case"children":case"dangerouslySetInnerHTML":if(Le!=null)throw Error(i(137,r));break;default:cn(e,r,Ie,Le,u,Re)}return;default:if(ht(r)){for(var Ln in a)Le=a[Ln],a.hasOwnProperty(Ln)&&Le!==void 0&&!u.hasOwnProperty(Ln)&&$s(e,r,Ln,void 0,u,Le);for(Qe in u)Le=u[Qe],Re=a[Qe],!u.hasOwnProperty(Qe)||Le===Re||Le===void 0&&Re===void 0||$s(e,r,Qe,Le,u,Re);return}}for(var Ce in a)Le=a[Ce],a.hasOwnProperty(Ce)&&Le!=null&&!u.hasOwnProperty(Ce)&&cn(e,r,Ce,null,u,Le);for(tt in u)Le=u[tt],Re=a[tt],!u.hasOwnProperty(tt)||Le===Re||Le==null&&Re==null||cn(e,r,tt,Le,u,Re)}var Yh=null,Zh=null;function fh(e){return e.nodeType===9?e:e.ownerDocument}function ug(e){switch(e){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function cg(e,r){if(e===0)switch(r){case"svg":return 1;case"math":return 2;default:return 0}return e===1&&r==="foreignObject"?0:e}function Jh(e,r){return e==="textarea"||e==="noscript"||typeof r.children=="string"||typeof r.children=="number"||typeof r.children=="bigint"||typeof r.dangerouslySetInnerHTML=="object"&&r.dangerouslySetInnerHTML!==null&&r.dangerouslySetInnerHTML.__html!=null}var em=null;function fT(){var e=window.event;return e&&e.type==="popstate"?e===em?!1:(em=e,!0):(em=null,!1)}var dg=typeof setTimeout=="function"?setTimeout:void 0,pT=typeof clearTimeout=="function"?clearTimeout:void 0,fg=typeof Promise=="function"?Promise:void 0,hT=typeof queueMicrotask=="function"?queueMicrotask:typeof fg<"u"?function(e){return fg.resolve(null).then(e).catch(mT)}:dg;function mT(e){setTimeout(function(){throw e})}function Ql(e){return e==="head"}function pg(e,r){var a=r,u=0,m=0;do{var v=a.nextSibling;if(e.removeChild(a),v&&v.nodeType===8)if(a=v.data,a==="/$"){if(0<u&&8>u){a=u;var j=e.ownerDocument;if(a&1&&gp(j.documentElement),a&2&&gp(j.body),a&4)for(a=j.head,gp(a),j=a.firstChild;j;){var Y=j.nextSibling,_e=j.nodeName;j[mr]||_e==="SCRIPT"||_e==="STYLE"||_e==="LINK"&&j.rel.toLowerCase()==="stylesheet"||a.removeChild(j),j=Y}}if(m===0){e.removeChild(v),Ep(r);return}m--}else a==="$"||a==="$?"||a==="$!"?m++:u=a.charCodeAt(0)-48;else u=0;a=v}while(a);Ep(r)}function tm(e){var r=e.firstChild;for(r&&r.nodeType===10&&(r=r.nextSibling);r;){var a=r;switch(r=r.nextSibling,a.nodeName){case"HTML":case"HEAD":case"BODY":tm(a),vs(a);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(a.rel.toLowerCase()==="stylesheet")continue}e.removeChild(a)}}function _T(e,r,a,u){for(;e.nodeType===1;){var m=a;if(e.nodeName.toLowerCase()!==r.toLowerCase()){if(!u&&(e.nodeName!=="INPUT"||e.type!=="hidden"))break}else if(u){if(!e[mr])switch(r){case"meta":if(!e.hasAttribute("itemprop"))break;return e;case"link":if(v=e.getAttribute("rel"),v==="stylesheet"&&e.hasAttribute("data-precedence"))break;if(v!==m.rel||e.getAttribute("href")!==(m.href==null||m.href===""?null:m.href)||e.getAttribute("crossorigin")!==(m.crossOrigin==null?null:m.crossOrigin)||e.getAttribute("title")!==(m.title==null?null:m.title))break;return e;case"style":if(e.hasAttribute("data-precedence"))break;return e;case"script":if(v=e.getAttribute("src"),(v!==(m.src==null?null:m.src)||e.getAttribute("type")!==(m.type==null?null:m.type)||e.getAttribute("crossorigin")!==(m.crossOrigin==null?null:m.crossOrigin))&&v&&e.hasAttribute("async")&&!e.hasAttribute("itemprop"))break;return e;default:return e}}else if(r==="input"&&e.type==="hidden"){var v=m.name==null?null:""+m.name;if(m.type==="hidden"&&e.getAttribute("name")===v)return e}else return e;if(e=hi(e.nextSibling),e===null)break}return null}function gT(e,r,a){if(r==="")return null;for(;e.nodeType!==3;)if((e.nodeType!==1||e.nodeName!=="INPUT"||e.type!=="hidden")&&!a||(e=hi(e.nextSibling),e===null))return null;return e}function nm(e){return e.data==="$!"||e.data==="$?"&&e.ownerDocument.readyState==="complete"}function yT(e,r){var a=e.ownerDocument;if(e.data!=="$?"||a.readyState==="complete")r();else{var u=function(){r(),a.removeEventListener("DOMContentLoaded",u)};a.addEventListener("DOMContentLoaded",u),e._reactRetry=u}}function hi(e){for(;e!=null;e=e.nextSibling){var r=e.nodeType;if(r===1||r===3)break;if(r===8){if(r=e.data,r==="$"||r==="$!"||r==="$?"||r==="F!"||r==="F")break;if(r==="/$")return null}}return e}var rm=null;function hg(e){e=e.previousSibling;for(var r=0;e;){if(e.nodeType===8){var a=e.data;if(a==="$"||a==="$!"||a==="$?"){if(r===0)return e;r--}else a==="/$"&&r++}e=e.previousSibling}return null}function mg(e,r,a){switch(r=fh(a),e){case"html":if(e=r.documentElement,!e)throw Error(i(452));return e;case"head":if(e=r.head,!e)throw Error(i(453));return e;case"body":if(e=r.body,!e)throw Error(i(454));return e;default:throw Error(i(451))}}function gp(e){for(var r=e.attributes;r.length;)e.removeAttributeNode(r[0]);vs(e)}var Ba=new Map,_g=new Set;function ph(e){return typeof e.getRootNode=="function"?e.getRootNode():e.nodeType===9?e:e.ownerDocument}var Wo=se.d;se.d={f:MT,r:vT,D:wT,C:bT,L:TT,m:xT,X:ST,S:ET,M:CT};function MT(){var e=Wo.f(),r=cc();return e||r}function vT(e){var r=rr(e);r!==null&&r.tag===5&&r.type==="form"?Mf(r):Wo.r(e)}var Ld=typeof document>"u"?null:document;function gg(e,r,a){var u=Ld;if(u&&typeof r=="string"&&r){var m=Er(r);m='link[rel="'+e+'"][href="'+m+'"]',typeof a=="string"&&(m+='[crossorigin="'+a+'"]'),_g.has(m)||(_g.add(m),e={rel:e,crossOrigin:a,href:r},u.querySelector(m)===null&&(r=u.createElement("link"),rs(r,"link",e),Pn(r),u.head.appendChild(r)))}}function wT(e){Wo.D(e),gg("dns-prefetch",e,null)}function bT(e,r){Wo.C(e,r),gg("preconnect",e,r)}function TT(e,r,a){Wo.L(e,r,a);var u=Ld;if(u&&e&&r){var m='link[rel="preload"][as="'+Er(r)+'"]';r==="image"&&a&&a.imageSrcSet?(m+='[imagesrcset="'+Er(a.imageSrcSet)+'"]',typeof a.imageSizes=="string"&&(m+='[imagesizes="'+Er(a.imageSizes)+'"]')):m+='[href="'+Er(e)+'"]';var v=m;switch(r){case"style":v=Bd(e);break;case"script":v=Rd(e)}Ba.has(v)||(e=g({rel:"preload",href:r==="image"&&a&&a.imageSrcSet?void 0:e,as:r},a),Ba.set(v,e),u.querySelector(m)!==null||r==="style"&&u.querySelector(yp(v))||r==="script"&&u.querySelector(Mp(v))||(r=u.createElement("link"),rs(r,"link",e),Pn(r),u.head.appendChild(r)))}}function xT(e,r){Wo.m(e,r);var a=Ld;if(a&&e){var u=r&&typeof r.as=="string"?r.as:"script",m='link[rel="modulepreload"][as="'+Er(u)+'"][href="'+Er(e)+'"]',v=m;switch(u){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":v=Rd(e)}if(!Ba.has(v)&&(e=g({rel:"modulepreload",href:e},r),Ba.set(v,e),a.querySelector(m)===null)){switch(u){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(a.querySelector(Mp(v)))return}u=a.createElement("link"),rs(u,"link",e),Pn(u),a.head.appendChild(u)}}}function ET(e,r,a){Wo.S(e,r,a);var u=Ld;if(u&&e){var m=Lr(u).hoistableStyles,v=Bd(e);r=r||"default";var j=m.get(v);if(!j){var Y={loading:0,preload:null};if(j=u.querySelector(yp(v)))Y.loading=5;else{e=g({rel:"stylesheet",href:e,"data-precedence":r},a),(a=Ba.get(v))&&sm(e,a);var _e=j=u.createElement("link");Pn(_e),rs(_e,"link",e),_e._p=new Promise(function(Ie,Qe){_e.onload=Ie,_e.onerror=Qe}),_e.addEventListener("load",function(){Y.loading|=1}),_e.addEventListener("error",function(){Y.loading|=2}),Y.loading|=4,hh(j,r,u)}j={type:"stylesheet",instance:j,count:1,state:Y},m.set(v,j)}}}function ST(e,r){Wo.X(e,r);var a=Ld;if(a&&e){var u=Lr(a).hoistableScripts,m=Rd(e),v=u.get(m);v||(v=a.querySelector(Mp(m)),v||(e=g({src:e,async:!0},r),(r=Ba.get(m))&&am(e,r),v=a.createElement("script"),Pn(v),rs(v,"link",e),a.head.appendChild(v)),v={type:"script",instance:v,count:1,state:null},u.set(m,v))}}function CT(e,r){Wo.M(e,r);var a=Ld;if(a&&e){var u=Lr(a).hoistableScripts,m=Rd(e),v=u.get(m);v||(v=a.querySelector(Mp(m)),v||(e=g({src:e,async:!0,type:"module"},r),(r=Ba.get(m))&&am(e,r),v=a.createElement("script"),Pn(v),rs(v,"link",e),a.head.appendChild(v)),v={type:"script",instance:v,count:1,state:null},u.set(m,v))}}function yg(e,r,a,u){var m=(m=ve.current)?ph(m):null;if(!m)throw Error(i(446));switch(e){case"meta":case"title":return null;case"style":return typeof a.precedence=="string"&&typeof a.href=="string"?(r=Bd(a.href),a=Lr(m).hoistableStyles,u=a.get(r),u||(u={type:"style",instance:null,count:0,state:null},a.set(r,u)),u):{type:"void",instance:null,count:0,state:null};case"link":if(a.rel==="stylesheet"&&typeof a.href=="string"&&typeof a.precedence=="string"){e=Bd(a.href);var v=Lr(m).hoistableStyles,j=v.get(e);if(j||(m=m.ownerDocument||m,j={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},v.set(e,j),(v=m.querySelector(yp(e)))&&!v._p&&(j.instance=v,j.state.loading=5),Ba.has(e)||(a={rel:"preload",as:"style",href:a.href,crossOrigin:a.crossOrigin,integrity:a.integrity,media:a.media,hrefLang:a.hrefLang,referrerPolicy:a.referrerPolicy},Ba.set(e,a),v||PT(m,e,a,j.state))),r&&u===null)throw Error(i(528,""));return j}if(r&&u!==null)throw Error(i(529,""));return null;case"script":return r=a.async,a=a.src,typeof a=="string"&&r&&typeof r!="function"&&typeof r!="symbol"?(r=Rd(a),a=Lr(m).hoistableScripts,u=a.get(r),u||(u={type:"script",instance:null,count:0,state:null},a.set(r,u)),u):{type:"void",instance:null,count:0,state:null};default:throw Error(i(444,e))}}function Bd(e){return'href="'+Er(e)+'"'}function yp(e){return'link[rel="stylesheet"]['+e+"]"}function Mg(e){return g({},e,{"data-precedence":e.precedence,precedence:null})}function PT(e,r,a,u){e.querySelector('link[rel="preload"][as="style"]['+r+"]")?u.loading=1:(r=e.createElement("link"),u.preload=r,r.addEventListener("load",function(){return u.loading|=1}),r.addEventListener("error",function(){return u.loading|=2}),rs(r,"link",a),Pn(r),e.head.appendChild(r))}function Rd(e){return'[src="'+Er(e)+'"]'}function Mp(e){return"script[async]"+e}function vg(e,r,a){if(r.count++,r.instance===null)switch(r.type){case"style":var u=e.querySelector('style[data-href~="'+Er(a.href)+'"]');if(u)return r.instance=u,Pn(u),u;var m=g({},a,{"data-href":a.href,"data-precedence":a.precedence,href:null,precedence:null});return u=(e.ownerDocument||e).createElement("style"),Pn(u),rs(u,"style",m),hh(u,a.precedence,e),r.instance=u;case"stylesheet":m=Bd(a.href);var v=e.querySelector(yp(m));if(v)return r.state.loading|=4,r.instance=v,Pn(v),v;u=Mg(a),(m=Ba.get(m))&&sm(u,m),v=(e.ownerDocument||e).createElement("link"),Pn(v);var j=v;return j._p=new Promise(function(Y,_e){j.onload=Y,j.onerror=_e}),rs(v,"link",u),r.state.loading|=4,hh(v,a.precedence,e),r.instance=v;case"script":return v=Rd(a.src),(m=e.querySelector(Mp(v)))?(r.instance=m,Pn(m),m):(u=a,(m=Ba.get(v))&&(u=g({},a),am(u,m)),e=e.ownerDocument||e,m=e.createElement("script"),Pn(m),rs(m,"link",u),e.head.appendChild(m),r.instance=m);case"void":return null;default:throw Error(i(443,r.type))}else r.type==="stylesheet"&&(r.state.loading&4)===0&&(u=r.instance,r.state.loading|=4,hh(u,a.precedence,e));return r.instance}function hh(e,r,a){for(var u=a.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),m=u.length?u[u.length-1]:null,v=m,j=0;j<u.length;j++){var Y=u[j];if(Y.dataset.precedence===r)v=Y;else if(v!==m)break}v?v.parentNode.insertBefore(e,v.nextSibling):(r=a.nodeType===9?a.head:a,r.insertBefore(e,r.firstChild))}function sm(e,r){e.crossOrigin==null&&(e.crossOrigin=r.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=r.referrerPolicy),e.title==null&&(e.title=r.title)}function am(e,r){e.crossOrigin==null&&(e.crossOrigin=r.crossOrigin),e.referrerPolicy==null&&(e.referrerPolicy=r.referrerPolicy),e.integrity==null&&(e.integrity=r.integrity)}var mh=null;function wg(e,r,a){if(mh===null){var u=new Map,m=mh=new Map;m.set(a,u)}else m=mh,u=m.get(a),u||(u=new Map,m.set(a,u));if(u.has(e))return u;for(u.set(e,null),a=a.getElementsByTagName(e),m=0;m<a.length;m++){var v=a[m];if(!(v[mr]||v[Nn]||e==="link"&&v.getAttribute("rel")==="stylesheet")&&v.namespaceURI!=="http://www.w3.org/2000/svg"){var j=v.getAttribute(r)||"";j=e+j;var Y=u.get(j);Y?Y.push(v):u.set(j,[v])}}return u}function bg(e,r,a){e=e.ownerDocument||e,e.head.insertBefore(a,r==="title"?e.querySelector("head > title"):null)}function AT(e,r,a){if(a===1||r.itemProp!=null)return!1;switch(e){case"meta":case"title":return!0;case"style":if(typeof r.precedence!="string"||typeof r.href!="string"||r.href==="")break;return!0;case"link":if(typeof r.rel!="string"||typeof r.href!="string"||r.href===""||r.onLoad||r.onError)break;switch(r.rel){case"stylesheet":return e=r.disabled,typeof r.precedence=="string"&&e==null;default:return!0}case"script":if(r.async&&typeof r.async!="function"&&typeof r.async!="symbol"&&!r.onLoad&&!r.onError&&r.src&&typeof r.src=="string")return!0}return!1}function Tg(e){return!(e.type==="stylesheet"&&(e.state.loading&3)===0)}var vp=null;function $T(){}function OT(e,r,a){if(vp===null)throw Error(i(475));var u=vp;if(r.type==="stylesheet"&&(typeof a.media!="string"||matchMedia(a.media).matches!==!1)&&(r.state.loading&4)===0){if(r.instance===null){var m=Bd(a.href),v=e.querySelector(yp(m));if(v){e=v._p,e!==null&&typeof e=="object"&&typeof e.then=="function"&&(u.count++,u=_h.bind(u),e.then(u,u)),r.state.loading|=4,r.instance=v,Pn(v);return}v=e.ownerDocument||e,a=Mg(a),(m=Ba.get(m))&&sm(a,m),v=v.createElement("link"),Pn(v);var j=v;j._p=new Promise(function(Y,_e){j.onload=Y,j.onerror=_e}),rs(v,"link",a),r.instance=v}u.stylesheets===null&&(u.stylesheets=new Map),u.stylesheets.set(r,e),(e=r.state.preload)&&(r.state.loading&3)===0&&(u.count++,r=_h.bind(u),e.addEventListener("load",r),e.addEventListener("error",r))}}function kT(){if(vp===null)throw Error(i(475));var e=vp;return e.stylesheets&&e.count===0&&im(e,e.stylesheets),0<e.count?function(r){var a=setTimeout(function(){if(e.stylesheets&&im(e,e.stylesheets),e.unsuspend){var u=e.unsuspend;e.unsuspend=null,u()}},6e4);return e.unsuspend=r,function(){e.unsuspend=null,clearTimeout(a)}}:null}function _h(){if(this.count--,this.count===0){if(this.stylesheets)im(this,this.stylesheets);else if(this.unsuspend){var e=this.unsuspend;this.unsuspend=null,e()}}}var gh=null;function im(e,r){e.stylesheets=null,e.unsuspend!==null&&(e.count++,gh=new Map,r.forEach(DT,e),gh=null,_h.call(e))}function DT(e,r){if(!(r.state.loading&4)){var a=gh.get(e);if(a)var u=a.get(null);else{a=new Map,gh.set(e,a);for(var m=e.querySelectorAll("link[data-precedence],style[data-precedence]"),v=0;v<m.length;v++){var j=m[v];(j.nodeName==="LINK"||j.getAttribute("media")!=="not all")&&(a.set(j.dataset.precedence,j),u=j)}u&&a.set(null,u)}m=r.instance,j=m.getAttribute("data-precedence"),v=a.get(j)||u,v===u&&a.set(null,m),a.set(j,m),this.count++,u=_h.bind(this),m.addEventListener("load",u),m.addEventListener("error",u),v?v.parentNode.insertBefore(m,v.nextSibling):(e=e.nodeType===9?e.head:e,e.insertBefore(m,e.firstChild)),r.state.loading|=4}}var wp={$$typeof:I,Provider:null,Consumer:null,_currentValue:ce,_currentValue2:ce,_threadCount:0};function IT(e,r,a,u,m,v,j,Y){this.tag=1,this.containerInfo=e,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=ms(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=ms(0),this.hiddenUpdates=ms(null),this.identifierPrefix=u,this.onUncaughtError=m,this.onCaughtError=v,this.onRecoverableError=j,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=Y,this.incompleteTransitions=new Map}function xg(e,r,a,u,m,v,j,Y,_e,Ie,Qe,tt){return e=new IT(e,r,a,j,Y,_e,Ie,tt),r=1,v===!0&&(r|=24),v=Sr(3,null,null,r),e.current=v,v.stateNode=e,r=yl(),r.refCount++,e.pooledCache=r,r.refCount++,v.memoizedState={element:u,isDehydrated:a,cache:r},Xi(v),e}function Eg(e){return e?(e=Ea,e):Ea}function Sg(e,r,a,u,m,v){m=Eg(m),u.context===null?u.context=m:u.pendingContext=m,u=la(r),u.payload={element:a},v=v===void 0?null:v,v!==null&&(u.callback=v),a=ua(e,u,r),a!==null&&(ds(a,e,r),Yi(a,e,r))}function Cg(e,r){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var a=e.retryLane;e.retryLane=a!==0&&a<r?a:r}}function om(e,r){Cg(e,r),(e=e.alternate)&&Cg(e,r)}function Pg(e){if(e.tag===13){var r=xa(e,67108864);r!==null&&ds(r,e,67108864),om(e,67108864)}}var yh=!0;function zT(e,r,a,u){var m=G.T;G.T=null;var v=se.p;try{se.p=2,lm(e,r,a,u)}finally{se.p=v,G.T=m}}function FT(e,r,a,u){var m=G.T;G.T=null;var v=se.p;try{se.p=8,lm(e,r,a,u)}finally{se.p=v,G.T=m}}function lm(e,r,a,u){if(yh){var m=um(u);if(m===null)hp(e,r,u,Mh,a),$g(e,u);else if(BT(m,e,r,a,u))u.stopPropagation();else if($g(e,u),r&4&&-1<LT.indexOf(e)){for(;m!==null;){var v=rr(m);if(v!==null)switch(v.tag){case 3:if(v=v.stateNode,v.current.memoizedState.isDehydrated){var j=Dn(v.pendingLanes);if(j!==0){var Y=v;for(Y.pendingLanes|=2,Y.entangledLanes|=2;j;){var _e=1<<31-He(j);Y.entanglements[1]|=_e,j&=~_e}un(v),(xn&6)===0&&(lc=We()+500,er(0))}}break;case 13:Y=xa(v,2),Y!==null&&ds(Y,v,2),cc(),om(v,2)}if(v=um(u),v===null&&hp(e,r,u,Mh,a),v===m)break;m=v}m!==null&&u.stopPropagation()}else hp(e,r,u,null,a)}}function um(e){return e=sn(e),cm(e)}var Mh=null;function cm(e){if(Mh=null,e=Fr(e),e!==null){var r=o(e);if(r===null)e=null;else{var a=r.tag;if(a===13){if(e=c(r),e!==null)return e;e=null}else if(a===3){if(r.stateNode.current.memoizedState.isDehydrated)return r.tag===3?r.stateNode.containerInfo:null;e=null}else r!==e&&(e=null)}}return Mh=e,null}function Ag(e){switch(e){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(nt()){case at:return 2;case ct:return 8;case V:case fe:return 32;case q:return 268435456;default:return 32}default:return 32}}var dm=!1,Xl=null,Yl=null,Zl=null,bp=new Map,Tp=new Map,Jl=[],LT="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function $g(e,r){switch(e){case"focusin":case"focusout":Xl=null;break;case"dragenter":case"dragleave":Yl=null;break;case"mouseover":case"mouseout":Zl=null;break;case"pointerover":case"pointerout":bp.delete(r.pointerId);break;case"gotpointercapture":case"lostpointercapture":Tp.delete(r.pointerId)}}function xp(e,r,a,u,m,v){return e===null||e.nativeEvent!==v?(e={blockedOn:r,domEventName:a,eventSystemFlags:u,nativeEvent:v,targetContainers:[m]},r!==null&&(r=rr(r),r!==null&&Pg(r)),e):(e.eventSystemFlags|=u,r=e.targetContainers,m!==null&&r.indexOf(m)===-1&&r.push(m),e)}function BT(e,r,a,u,m){switch(r){case"focusin":return Xl=xp(Xl,e,r,a,u,m),!0;case"dragenter":return Yl=xp(Yl,e,r,a,u,m),!0;case"mouseover":return Zl=xp(Zl,e,r,a,u,m),!0;case"pointerover":var v=m.pointerId;return bp.set(v,xp(bp.get(v)||null,e,r,a,u,m)),!0;case"gotpointercapture":return v=m.pointerId,Tp.set(v,xp(Tp.get(v)||null,e,r,a,u,m)),!0}return!1}function Og(e){var r=Fr(e.target);if(r!==null){var a=o(r);if(a!==null){if(r=a.tag,r===13){if(r=c(a),r!==null){e.blockedOn=r,ya(e.priority,function(){if(a.tag===13){var u=cs();u=Kr(u);var m=xa(a,u);m!==null&&ds(m,a,u),om(a,u)}});return}}else if(r===3&&a.stateNode.current.memoizedState.isDehydrated){e.blockedOn=a.tag===3?a.stateNode.containerInfo:null;return}}}e.blockedOn=null}function vh(e){if(e.blockedOn!==null)return!1;for(var r=e.targetContainers;0<r.length;){var a=um(e.nativeEvent);if(a===null){a=e.nativeEvent;var u=new a.constructor(a.type,a);Zt=u,a.target.dispatchEvent(u),Zt=null}else return r=rr(a),r!==null&&Pg(r),e.blockedOn=a,!1;r.shift()}return!0}function kg(e,r,a){vh(e)&&a.delete(r)}function RT(){dm=!1,Xl!==null&&vh(Xl)&&(Xl=null),Yl!==null&&vh(Yl)&&(Yl=null),Zl!==null&&vh(Zl)&&(Zl=null),bp.forEach(kg),Tp.forEach(kg)}function wh(e,r){e.blockedOn===r&&(e.blockedOn=null,dm||(dm=!0,t.unstable_scheduleCallback(t.unstable_NormalPriority,RT)))}var bh=null;function Dg(e){bh!==e&&(bh=e,t.unstable_scheduleCallback(t.unstable_NormalPriority,function(){bh===e&&(bh=null);for(var r=0;r<e.length;r+=3){var a=e[r],u=e[r+1],m=e[r+2];if(typeof u!="function"){if(cm(u||a)===null)continue;break}var v=rr(a);v!==null&&(e.splice(r,3),r-=3,ju(v,{pending:!0,data:m,method:a.method,action:u},u,m))}}))}function Ep(e){function r(_e){return wh(_e,e)}Xl!==null&&wh(Xl,e),Yl!==null&&wh(Yl,e),Zl!==null&&wh(Zl,e),bp.forEach(r),Tp.forEach(r);for(var a=0;a<Jl.length;a++){var u=Jl[a];u.blockedOn===e&&(u.blockedOn=null)}for(;0<Jl.length&&(a=Jl[0],a.blockedOn===null);)Og(a),a.blockedOn===null&&Jl.shift();if(a=(e.ownerDocument||e).$$reactFormReplay,a!=null)for(u=0;u<a.length;u+=3){var m=a[u],v=a[u+1],j=m[mn]||null;if(typeof v=="function")j||Dg(a);else if(j){var Y=null;if(v&&v.hasAttribute("formAction")){if(m=v,j=v[mn]||null)Y=j.formAction;else if(cm(m)!==null)continue}else Y=j.action;typeof Y=="function"?a[u+1]=Y:(a.splice(u,3),u-=3),Dg(a)}}}function fm(e){this._internalRoot=e}Th.prototype.render=fm.prototype.render=function(e){var r=this._internalRoot;if(r===null)throw Error(i(409));var a=r.current,u=cs();Sg(a,u,e,r,null,null)},Th.prototype.unmount=fm.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var r=e.containerInfo;Sg(e.current,2,null,e,null,null),cc(),r[st]=null}};function Th(e){this._internalRoot=e}Th.prototype.unstable_scheduleHydration=function(e){if(e){var r=Hs();e={blockedOn:null,target:e,priority:r};for(var a=0;a<Jl.length&&r!==0&&r<Jl[a].priority;a++);Jl.splice(a,0,e),a===0&&Og(e)}};var Ig=s.version;if(Ig!=="19.1.0")throw Error(i(527,Ig,"19.1.0"));se.findDOMNode=function(e){var r=e._reactInternals;if(r===void 0)throw typeof e.render=="function"?Error(i(188)):(e=Object.keys(e).join(","),Error(i(268,e)));return e=d(r),e=e!==null?f(e):null,e=e===null?null:e.stateNode,e};var NT={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:G,reconcilerVersion:"19.1.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var xh=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!xh.isDisabled&&xh.supportsFiber)try{Fe=xh.inject(NT),De=xh}catch{}}return Cp.createRoot=function(e,r){if(!l(e))throw Error(i(299));var a=!1,u="",m=$f,v=Of,j=ud,Y=null;return r!=null&&(r.unstable_strictMode===!0&&(a=!0),r.identifierPrefix!==void 0&&(u=r.identifierPrefix),r.onUncaughtError!==void 0&&(m=r.onUncaughtError),r.onCaughtError!==void 0&&(v=r.onCaughtError),r.onRecoverableError!==void 0&&(j=r.onRecoverableError),r.unstable_transitionCallbacks!==void 0&&(Y=r.unstable_transitionCallbacks)),r=xg(e,1,!1,null,null,a,u,m,v,j,Y,null),e[st]=r.current,dc(e),new fm(r)},Cp.hydrateRoot=function(e,r,a){if(!l(e))throw Error(i(299));var u=!1,m="",v=$f,j=Of,Y=ud,_e=null,Ie=null;return a!=null&&(a.unstable_strictMode===!0&&(u=!0),a.identifierPrefix!==void 0&&(m=a.identifierPrefix),a.onUncaughtError!==void 0&&(v=a.onUncaughtError),a.onCaughtError!==void 0&&(j=a.onCaughtError),a.onRecoverableError!==void 0&&(Y=a.onRecoverableError),a.unstable_transitionCallbacks!==void 0&&(_e=a.unstable_transitionCallbacks),a.formState!==void 0&&(Ie=a.formState)),r=xg(e,1,!0,r,a??null,u,m,v,j,Y,_e,Ie),r.context=Eg(null),a=r.current,u=cs(),u=Kr(u),m=la(u),m.callback=null,ua(a,m,u),a=u,r.current.lanes=a,_s(r,a),un(r),e[st]=r.current,dc(e),new Th(r)},Cp.version="19.1.0",Cp}var Gg;function ZT(){if(Gg)return mm.exports;Gg=1;function t(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(t)}catch(s){console.error(s)}}return t(),mm.exports=YT(),mm.exports}var JT=ZT();const ex=({children:t})=>Wn.jsx("div",{className:"h-dvh w-dvw",children:Wn.jsx("div",{className:"flex h-full w-full flex-col items-center justify-center bg-linear-to-br from-zinc-900 to-zinc-950",children:t})}),Rh=new Map,_c=[],tx=(t,s,n)=>{if(s&&typeof s.init=="function"&&typeof s.createInferenceSessionHandler=="function"){const i=Rh.get(t);if(i===void 0)Rh.set(t,{backend:s,priority:n});else{if(i.priority>n)return;if(i.priority===n&&i.backend!==s)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){const l=_c.indexOf(t);l!==-1&&_c.splice(l,1);for(let o=0;o<_c.length;o++)if(Rh.get(_c[o]).priority<=n){_c.splice(o,0,t);return}_c.push(t)}return}throw new TypeError("not a valid backend")},nx=async t=>{const s=Rh.get(t);if(!s)return"backend not found.";if(s.initialized)return s.backend;if(s.aborted)return s.error;{const n=!!s.initPromise;try{return n||(s.initPromise=s.backend.init(t)),await s.initPromise,s.initialized=!0,s.backend}catch(i){return n||(s.error=`${i}`,s.aborted=!0),s.error}finally{delete s.initPromise}}},Ev=async t=>{const s=t.executionProviders||[],n=s.map(d=>typeof d=="string"?d:d.name),i=n.length===0?_c:n;let l;const o=[],c=new Set;for(const d of i){const f=await nx(d);typeof f=="string"?o.push({name:d,err:f}):(l||(l=f),l===f&&c.add(d))}if(!l)throw new Error(`no available backend found. ERR: ${o.map(d=>`[${d.name}] ${d.err}`).join(", ")}`);for(const{name:d,err:f}of o)n.includes(d)&&console.warn(`removing requested execution provider "${d}" from session options because it is not available: ${f}`);const p=s.filter(d=>c.has(typeof d=="string"?d:d.name));return[l,new Proxy(t,{get:(d,f)=>f==="executionProviders"?p:Reflect.get(d,f)})]},rx="1.20.1";let Wg="warning";const bi={wasm:{},webgl:{},webgpu:{},versions:{common:rx},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);Wg=t}},get logLevel(){return Wg}};Object.defineProperty(bi,"logLevel",{enumerable:!0});const sx=bi,ax=(t,s)=>{const n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];const i=n.getContext("2d");if(i!=null){let l,o;(s==null?void 0:s.tensorLayout)!==void 0&&s.tensorLayout==="NHWC"?(l=t.dims[2],o=t.dims[3]):(l=t.dims[3],o=t.dims[2]);const c=(s==null?void 0:s.format)!==void 0?s.format:"RGB",p=s==null?void 0:s.norm;let d,f;p===void 0||p.mean===void 0?d=[255,255,255,255]:typeof p.mean=="number"?d=[p.mean,p.mean,p.mean,p.mean]:(d=[p.mean[0],p.mean[1],p.mean[2],0],p.mean[3]!==void 0&&(d[3]=p.mean[3])),p===void 0||p.bias===void 0?f=[0,0,0,0]:typeof p.bias=="number"?f=[p.bias,p.bias,p.bias,p.bias]:(f=[p.bias[0],p.bias[1],p.bias[2],0],p.bias[3]!==void 0&&(f[3]=p.bias[3]));const g=o*l;let _=0,y=g,T=g*2,b=-1;c==="RGBA"?(_=0,y=g,T=g*2,b=g*3):c==="RGB"?(_=0,y=g,T=g*2):c==="RBG"&&(_=0,T=g,y=g*2);for(let k=0;k<o;k++)for(let L=0;L<l;L++){const C=(t.data[_++]-f[0])*d[0],S=(t.data[y++]-f[1])*d[1],I=(t.data[T++]-f[2])*d[2],O=b===-1?255:(t.data[b++]-f[3])*d[3];i.fillStyle="rgba("+C+","+S+","+I+","+O+")",i.fillRect(L,k,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},ix=(t,s)=>{const n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let i;if(n!=null){let l,o,c;(s==null?void 0:s.tensorLayout)!==void 0&&s.tensorLayout==="NHWC"?(l=t.dims[2],o=t.dims[1],c=t.dims[3]):(l=t.dims[3],o=t.dims[2],c=t.dims[1]);const p=s!==void 0&&s.format!==void 0?s.format:"RGB",d=s==null?void 0:s.norm;let f,g;d===void 0||d.mean===void 0?f=[255,255,255,255]:typeof d.mean=="number"?f=[d.mean,d.mean,d.mean,d.mean]:(f=[d.mean[0],d.mean[1],d.mean[2],255],d.mean[3]!==void 0&&(f[3]=d.mean[3])),d===void 0||d.bias===void 0?g=[0,0,0,0]:typeof d.bias=="number"?g=[d.bias,d.bias,d.bias,d.bias]:(g=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(g[3]=d.bias[3]));const _=o*l;if(s!==void 0&&(s.format!==void 0&&c===4&&s.format!=="RGBA"||c===3&&s.format!=="RGB"&&s.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");const y=4;let T=0,b=1,k=2,L=3,C=0,S=_,I=_*2,O=-1;p==="RGBA"?(C=0,S=_,I=_*2,O=_*3):p==="RGB"?(C=0,S=_,I=_*2):p==="RBG"&&(C=0,I=_,S=_*2),i=n.createImageData(l,o);for(let x=0;x<o*l;T+=y,b+=y,k+=y,L+=y,x++)i.data[T]=(t.data[C++]-g[0])*f[0],i.data[b]=(t.data[S++]-g[1])*f[1],i.data[k]=(t.data[I++]-g[2])*f[2],i.data[L]=O===-1?255:(t.data[O++]-g[3])*f[3]}else throw new Error("Can not access image data");return i},Mm=(t,s)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(s.height===void 0||s.width===void 0)throw new Error("Image height and width must be defined");if(s.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");const{height:n,width:i}=s,l=s.norm??{mean:255,bias:0};let o,c;typeof l.mean=="number"?o=[l.mean,l.mean,l.mean,l.mean]:o=[l.mean[0],l.mean[1],l.mean[2],l.mean[3]??255],typeof l.bias=="number"?c=[l.bias,l.bias,l.bias,l.bias]:c=[l.bias[0],l.bias[1],l.bias[2],l.bias[3]??0];const p=s.format!==void 0?s.format:"RGBA",d=s.tensorFormat!==void 0&&s.tensorFormat!==void 0?s.tensorFormat:"RGB",f=n*i,g=d==="RGBA"?new Float32Array(f*4):new Float32Array(f*3);let _=4,y=0,T=1,b=2,k=3,L=0,C=f,S=f*2,I=-1;p==="RGB"&&(_=3,y=0,T=1,b=2,k=-1),d==="RGBA"?I=f*3:d==="RBG"?(L=0,S=f,C=f*2):d==="BGR"&&(S=0,C=f,L=f*2);for(let x=0;x<f;x++,y+=_,b+=_,T+=_,k+=_)g[L++]=(t[y]+c[0])/o[0],g[C++]=(t[T]+c[1])/o[1],g[S++]=(t[b]+c[2])/o[2],I!==-1&&k!==-1&&(g[I++]=(t[k]+c[3])/o[3]);return d==="RGBA"?new Na("float32",g,[1,4,n,i]):new Na("float32",g,[1,3,n,i])},ox=async(t,s)=>{const n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,i=typeof ImageData<"u"&&t instanceof ImageData,l=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,o=typeof t=="string";let c,p=s??{};const d=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},f=g=>typeof HTMLCanvasElement<"u"&&g instanceof HTMLCanvasElement||g instanceof OffscreenCanvas?g.getContext("2d"):null;if(n){const g=d();g.width=t.width,g.height=t.height;const _=f(g);if(_!=null){let y=t.height,T=t.width;if(s!==void 0&&s.resizedHeight!==void 0&&s.resizedWidth!==void 0&&(y=s.resizedHeight,T=s.resizedWidth),s!==void 0){if(p=s,s.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");p.tensorFormat="RGBA",p.height=y,p.width=T}else p.tensorFormat="RGBA",p.height=y,p.width=T;_.drawImage(t,0,0),c=_.getImageData(0,0,T,y).data}else throw new Error("Can not access image data")}else if(i){let g,_;if(s!==void 0&&s.resizedWidth!==void 0&&s.resizedHeight!==void 0?(g=s.resizedHeight,_=s.resizedWidth):(g=t.height,_=t.width),s!==void 0&&(p=s),p.format="RGBA",p.height=g,p.width=_,s!==void 0){const y=d();y.width=_,y.height=g;const T=f(y);if(T!=null)T.putImageData(t,0,0),c=T.getImageData(0,0,_,g).data;else throw new Error("Can not access image data")}else c=t.data}else if(l){if(s===void 0)throw new Error("Please provide image config with format for Imagebitmap");const g=d();g.width=t.width,g.height=t.height;const _=f(g);if(_!=null){const y=t.height,T=t.width;return _.drawImage(t,0,0,T,y),c=_.getImageData(0,0,T,y).data,p.height=y,p.width=T,Mm(c,p)}else throw new Error("Can not access image data")}else{if(o)return new Promise((g,_)=>{const y=d(),T=f(y);if(!t||!T)return _();const b=new Image;b.crossOrigin="Anonymous",b.src=t,b.onload=()=>{y.width=b.width,y.height=b.height,T.drawImage(b,0,0,y.width,y.height);const k=T.getImageData(0,0,y.width,y.height);p.height=y.height,p.width=y.width,g(Mm(k.data,p))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(c!==void 0)return Mm(c,p);throw new Error("Input data provided is not supported - aborted tensor creation")},lx=(t,s)=>{const{width:n,height:i,download:l,dispose:o}=s,c=[1,i,n,4];return new Na({location:"texture",type:"float32",texture:t,dims:c,download:l,dispose:o})},ux=(t,s)=>{const{dataType:n,dims:i,download:l,dispose:o}=s;return new Na({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:i,download:l,dispose:o})},cx=(t,s)=>{const{dataType:n,dims:i,download:l,dispose:o}=s;return new Na({location:"ml-tensor",type:n??"float32",mlTensor:t,dims:i,download:l,dispose:o})},dx=(t,s,n)=>new Na({location:"cpu-pinned",type:t,data:s,dims:n??[s.length]}),Ud=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Nh=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let Hg=!1;const fx=()=>{if(!Hg){Hg=!0;const t=typeof BigInt64Array<"u"&&BigInt64Array.from,s=typeof BigUint64Array<"u"&&BigUint64Array.from,n=typeof Float16Array<"u"&&Float16Array.from;t&&(Ud.set("int64",BigInt64Array),Nh.set(BigInt64Array,"int64")),s&&(Ud.set("uint64",BigUint64Array),Nh.set(BigUint64Array,"uint64")),n?(Ud.set("float16",Float16Array),Nh.set(Float16Array,"float16")):Ud.set("float16",Uint16Array)}},px=t=>{let s=1;for(let n=0;n<t.length;n++){const i=t[n];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${n}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${i}`);s*=i}return s},hx=(t,s)=>{switch(t.location){case"cpu":return new Na(t.type,t.data,s);case"cpu-pinned":return new Na({location:"cpu-pinned",data:t.data,type:t.type,dims:s});case"texture":return new Na({location:"texture",texture:t.texture,type:t.type,dims:s});case"gpu-buffer":return new Na({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:s});case"ml-tensor":return new Na({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:s});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}};let Na=class{constructor(s,n,i){fx();let l,o;if(typeof s=="object"&&"location"in s)switch(this.dataLocation=s.location,l=s.type,o=s.dims,s.location){case"cpu-pinned":{const p=Ud.get(l);if(!p)throw new TypeError(`unsupported type "${l}" to create tensor from pinned buffer`);if(!(s.data instanceof p))throw new TypeError(`buffer should be of type ${p.name}`);this.cpuData=s.data;break}case"texture":{if(l!=="float32")throw new TypeError(`unsupported type "${l}" to create tensor from texture`);this.gpuTextureData=s.texture,this.downloader=s.download,this.disposer=s.dispose;break}case"gpu-buffer":{if(l!=="float32"&&l!=="float16"&&l!=="int32"&&l!=="int64"&&l!=="uint32"&&l!=="uint8"&&l!=="bool"&&l!=="uint4"&&l!=="int4")throw new TypeError(`unsupported type "${l}" to create tensor from gpu buffer`);this.gpuBufferData=s.gpuBuffer,this.downloader=s.download,this.disposer=s.dispose;break}case"ml-tensor":{if(l!=="float32"&&l!=="float16"&&l!=="int32"&&l!=="int64"&&l!=="uint32"&&l!=="uint64"&&l!=="int8"&&l!=="uint8"&&l!=="bool")throw new TypeError(`unsupported type "${l}" to create tensor from MLTensor`);this.mlTensorData=s.mlTensor,this.downloader=s.download,this.disposer=s.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let p,d;if(typeof s=="string")if(l=s,d=i,s==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");p=n}else{const f=Ud.get(s);if(f===void 0)throw new TypeError(`Unsupported tensor type: ${s}.`);if(Array.isArray(n)){if(s==="float16"&&f===Uint16Array||s==="uint4"||s==="int4")throw new TypeError(`Creating a ${s} tensor from number array is not supported. Please use ${f.name} as data.`);s==="uint64"||s==="int64"?p=f.from(n,BigInt):p=f.from(n)}else if(n instanceof f)p=n;else if(n instanceof Uint8ClampedArray)if(s==="uint8")p=Uint8Array.from(n);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${l} tensor's data must be type of ${f}`)}else if(d=n,Array.isArray(s)){if(s.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");const f=typeof s[0];if(f==="string")l="string",p=s;else if(f==="boolean")l="bool",p=Uint8Array.from(s);else throw new TypeError(`Invalid element type of data array: ${f}.`)}else if(s instanceof Uint8ClampedArray)l="uint8",p=Uint8Array.from(s);else{const f=Nh.get(s.constructor);if(f===void 0)throw new TypeError(`Unsupported type for tensor data: ${s.constructor}.`);l=f,p=s}if(d===void 0)d=[p.length];else if(!Array.isArray(d))throw new TypeError("A tensor's dims must be a number array");o=d,this.cpuData=p,this.dataLocation="cpu"}const c=px(o);if(this.cpuData&&c!==this.cpuData.length&&!((l==="uint4"||l==="int4")&&Math.ceil(c/2)===this.cpuData.length))throw new Error(`Tensor's size(${c}) does not match data length(${this.cpuData.length}).`);this.type=l,this.dims=o,this.size=c}static async fromImage(s,n){return ox(s,n)}static fromTexture(s,n){return lx(s,n)}static fromGpuBuffer(s,n){return ux(s,n)}static fromMLTensor(s,n){return cx(s,n)}static fromPinnedBuffer(s,n,i){return dx(s,n,i)}toDataURL(s){return ax(this,s)}toImageData(s){return ix(this,s)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(s){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,s&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(s){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return hx(this,s)}};const vi=Na,Sv=(t,s)=>{(typeof bi.trace>"u"?!bi.wasm.trace:!bi.trace)||console.timeStamp(`${t}::ORT::${s}`)},Cv=(t,s)=>{var l;const n=((l=new Error().stack)==null?void 0:l.split(/\r\n|\r|\n/g))||[];let i=!1;for(let o=0;o<n.length;o++){if(i&&!n[o].includes("TRACE_FUNC")){let c=`FUNC_${t}::${n[o].trim().split(" ")[1]}`;s&&(c+=`::${s}`),Sv("CPU",c);return}n[o].includes("TRACE_FUNC")&&(i=!0)}},m_=t=>{(typeof bi.trace>"u"?!bi.wasm.trace:!bi.trace)||Cv("BEGIN",t)},__=t=>{(typeof bi.trace>"u"?!bi.wasm.trace:!bi.trace)||Cv("END",t)};let mx=class Pv{constructor(s){this.handler=s}async run(s,n,i){m_();const l={};let o={};if(typeof s!="object"||s===null||s instanceof vi||Array.isArray(s))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof vi)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(const f of n){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);l[f]=null}if(typeof i=="object"&&i!==null)o=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let f=!1;const g=Object.getOwnPropertyNames(n);for(const _ of this.outputNames)if(g.indexOf(_)!==-1){const y=n[_];(y===null||y instanceof vi)&&(f=!0,c=!1,l[_]=y)}if(f){if(typeof i=="object"&&i!==null)o=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else o=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const f of this.inputNames)if(typeof s[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(c)for(const f of this.outputNames)l[f]=null;const p=await this.handler.run(s,l,o),d={};for(const f in p)if(Object.hasOwnProperty.call(p,f)){const g=p[f];g instanceof vi?d[f]=g:d[f]=new vi(g.type,g.data,g.dims)}return __(),d}async release(){return this.handler.dispose()}static async create(s,n,i,l){m_();let o,c={};if(typeof s=="string"){if(o=s,typeof n=="object"&&n!==null)c=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(s instanceof Uint8Array){if(o=s,typeof n=="object"&&n!==null)c=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(s instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&s instanceof SharedArrayBuffer){const g=s;let _=0,y=s.byteLength;if(typeof n=="object"&&n!==null)c=n;else if(typeof n=="number"){if(_=n,!Number.isSafeInteger(_))throw new RangeError("'byteOffset' must be an integer.");if(_<0||_>=g.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${g.byteLength}).`);if(y=s.byteLength-_,typeof i=="number"){if(y=i,!Number.isSafeInteger(y))throw new RangeError("'byteLength' must be an integer.");if(y<=0||_+y>g.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${g.byteLength-_}].`);if(typeof l=="object"&&l!==null)c=l;else if(typeof l<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");o=new Uint8Array(g,_,y)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");const[p,d]=await Ev(c),f=await p.createInferenceSessionHandler(o,d);return __(),new Pv(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const _x=mx,gx="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";let yx=class Av{constructor(s,n,i){this.handler=s,this.hasOptimizerModel=n,this.hasEvalModel=i}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(s,n){const i=s.evalModel||"",l=s.optimizerModel||"",o=n||{},[c,p]=await Ev(o);if(c.createTrainingSessionHandler){const d=await c.createTrainingSessionHandler(s.checkpointState,s.trainModel,i,l,p);return new Av(d,!!s.optimizerModel,!!s.evalModel)}else throw new Error(gx)}typeNarrowingForRunStep(s,n,i,l,o){const c={};let p={};if(typeof i!="object"||i===null||i instanceof vi||Array.isArray(i))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let d=!0;if(typeof l=="object"){if(l===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(l instanceof vi)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(l)){if(l.length===0)throw new TypeError("'fetches' cannot be an empty array.");d=!1;for(const f of l){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(n.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);c[f]=null}if(typeof o=="object"&&o!==null)p=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let f=!1;const g=Object.getOwnPropertyNames(l);for(const _ of n)if(g.indexOf(_)!==-1){const y=l[_];(y===null||y instanceof vi)&&(f=!0,d=!1,c[_]=y)}if(f){if(typeof o=="object"&&o!==null)p=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else p=l}}else if(typeof l<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const f of s)if(typeof i[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(d)for(const f of n)c[f]=null;return[c,p]}convertHandlerReturnTypeToMapOfTensors(s){const n={};for(const i in s)if(Object.hasOwnProperty.call(s,i)){const l=s[i];l instanceof vi?n[i]=l:n[i]=new vi(l.type,l.data,l.dims)}return n}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(s,n,i){const[l,o]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,s,n,i),c=await this.handler.runTrainStep(s,l,o);return this.convertHandlerReturnTypeToMapOfTensors(c)}async runOptimizerStep(s){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(s||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(s,n,i){if(this.hasEvalModel){const[l,o]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,s,n,i),c=await this.handler.runEvalStep(s,l,o);return this.convertHandlerReturnTypeToMapOfTensors(c)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(s=!0){return this.handler.getParametersSize(s)}async loadParametersBuffer(s,n=!0){const i=await this.getParametersSize(n);if(s.length!==4*i)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(s,n)}async getContiguousParameters(s=!0){return this.handler.getContiguousParameters(s)}async release(){return this.handler.dispose()}};const Mx=yx,vx=Object.freeze(Object.defineProperty({__proto__:null,InferenceSession:_x,TRACE:Sv,TRACE_FUNC_BEGIN:m_,TRACE_FUNC_END:__,Tensor:vi,TrainingSession:Mx,env:sx,registerBackend:tx},Symbol.toStringTag,{value:"Module"}));/*!
 * ONNX Runtime Web v1.22.0-dev.20250306-ccf8fdd9ea
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var D_=Object.defineProperty,wx=Object.getOwnPropertyDescriptor,bx=Object.getOwnPropertyNames,Tx=Object.prototype.hasOwnProperty,xx=(t=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(t,{get:(s,n)=>(typeof require<"u"?require:s)[n]}):t)(function(t){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')}),ot=(t,s)=>()=>(t&&(s=t(t=0)),s),Gp=(t,s)=>{for(var n in s)D_(t,n,{get:s[n],enumerable:!0})},Ex=(t,s,n,i)=>{if(s&&typeof s=="object"||typeof s=="function")for(let l of bx(s))!Tx.call(t,l)&&l!==n&&D_(t,l,{get:()=>s[l],enumerable:!(i=wx(s,l))||i.enumerable});return t},Vh=t=>Ex(D_({},"__esModule",{value:!0}),t),Pp,tu,vc,Kg,$v,Ov=ot(()=>{Pp=new Map,tu=[],vc=(t,s,n)=>{if(s&&typeof s.init=="function"&&typeof s.createInferenceSessionHandler=="function"){let i=Pp.get(t);if(i===void 0)Pp.set(t,{backend:s,priority:n});else{if(i.priority>n)return;if(i.priority===n&&i.backend!==s)throw new Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){let l=tu.indexOf(t);l!==-1&&tu.splice(l,1);for(let o=0;o<tu.length;o++)if(Pp.get(tu[o]).priority<=n){tu.splice(o,0,t);return}tu.push(t)}return}throw new TypeError("not a valid backend")},Kg=async t=>{let s=Pp.get(t);if(!s)return"backend not found.";if(s.initialized)return s.backend;if(s.aborted)return s.error;{let n=!!s.initPromise;try{return n||(s.initPromise=s.backend.init(t)),await s.initPromise,s.initialized=!0,s.backend}catch(i){return n||(s.error=`${i}`,s.aborted=!0),s.error}finally{delete s.initPromise}}},$v=async t=>{let s=t.executionProviders||[],n=s.map(d=>typeof d=="string"?d:d.name),i=n.length===0?tu:n,l,o=[],c=new Set;for(let d of i){let f=await Kg(d);typeof f=="string"?o.push({name:d,err:f}):(l||(l=f),l===f&&c.add(d))}if(!l)throw new Error(`no available backend found. ERR: ${o.map(d=>`[${d.name}] ${d.err}`).join(", ")}`);for(let{name:d,err:f}of o)n.includes(d)&&console.warn(`removing requested execution provider "${d}" from session options because it is not available: ${f}`);let p=s.filter(d=>c.has(typeof d=="string"?d:d.name));return[l,new Proxy(t,{get:(d,f)=>f==="executionProviders"?p:Reflect.get(d,f)})]}}),Sx=ot(()=>{Ov()}),kv,Cx=ot(()=>{kv="1.22.0-dev.20250306-aafa8d170a"}),vm,Ra,Dv=ot(()=>{Cx(),vm="warning",Ra={wasm:{},webgl:{},webgpu:{},versions:{common:kv},set logLevel(t){if(t!==void 0){if(typeof t!="string"||["verbose","info","warning","error","fatal"].indexOf(t)===-1)throw new Error(`Unsupported logging level: ${t}`);vm=t}},get logLevel(){return vm}},Object.defineProperty(Ra,"logLevel",{enumerable:!0})}),Hn,Px=ot(()=>{Dv(),Hn=Ra}),Iv,zv,Ax=ot(()=>{Iv=(t,s)=>{let n=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];let i=n.getContext("2d");if(i!=null){let l,o;(s==null?void 0:s.tensorLayout)!==void 0&&s.tensorLayout==="NHWC"?(l=t.dims[2],o=t.dims[3]):(l=t.dims[3],o=t.dims[2]);let c=(s==null?void 0:s.format)!==void 0?s.format:"RGB",p=s==null?void 0:s.norm,d,f;p===void 0||p.mean===void 0?d=[255,255,255,255]:typeof p.mean=="number"?d=[p.mean,p.mean,p.mean,p.mean]:(d=[p.mean[0],p.mean[1],p.mean[2],0],p.mean[3]!==void 0&&(d[3]=p.mean[3])),p===void 0||p.bias===void 0?f=[0,0,0,0]:typeof p.bias=="number"?f=[p.bias,p.bias,p.bias,p.bias]:(f=[p.bias[0],p.bias[1],p.bias[2],0],p.bias[3]!==void 0&&(f[3]=p.bias[3]));let g=o*l,_=0,y=g,T=g*2,b=-1;c==="RGBA"?(_=0,y=g,T=g*2,b=g*3):c==="RGB"?(_=0,y=g,T=g*2):c==="RBG"&&(_=0,T=g,y=g*2);for(let k=0;k<o;k++)for(let L=0;L<l;L++){let C=(t.data[_++]-f[0])*d[0],S=(t.data[y++]-f[1])*d[1],I=(t.data[T++]-f[2])*d[2],O=b===-1?255:(t.data[b++]-f[3])*d[3];i.fillStyle="rgba("+C+","+S+","+I+","+O+")",i.fillRect(L,k,1,1)}if("toDataURL"in n)return n.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},zv=(t,s)=>{let n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),i;if(n!=null){let l,o,c;(s==null?void 0:s.tensorLayout)!==void 0&&s.tensorLayout==="NHWC"?(l=t.dims[2],o=t.dims[1],c=t.dims[3]):(l=t.dims[3],o=t.dims[2],c=t.dims[1]);let p=s!==void 0&&s.format!==void 0?s.format:"RGB",d=s==null?void 0:s.norm,f,g;d===void 0||d.mean===void 0?f=[255,255,255,255]:typeof d.mean=="number"?f=[d.mean,d.mean,d.mean,d.mean]:(f=[d.mean[0],d.mean[1],d.mean[2],255],d.mean[3]!==void 0&&(f[3]=d.mean[3])),d===void 0||d.bias===void 0?g=[0,0,0,0]:typeof d.bias=="number"?g=[d.bias,d.bias,d.bias,d.bias]:(g=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(g[3]=d.bias[3]));let _=o*l;if(s!==void 0&&(s.format!==void 0&&c===4&&s.format!=="RGBA"||c===3&&s.format!=="RGB"&&s.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let y=4,T=0,b=1,k=2,L=3,C=0,S=_,I=_*2,O=-1;p==="RGBA"?(C=0,S=_,I=_*2,O=_*3):p==="RGB"?(C=0,S=_,I=_*2):p==="RBG"&&(C=0,I=_,S=_*2),i=n.createImageData(l,o);for(let x=0;x<o*l;T+=y,b+=y,k+=y,L+=y,x++)i.data[T]=(t.data[C++]-g[0])*f[0],i.data[b]=(t.data[S++]-g[1])*f[1],i.data[k]=(t.data[I++]-g[2])*f[2],i.data[L]=O===-1?255:(t.data[O++]-g[3])*f[3]}else throw new Error("Can not access image data");return i}}),Eh,Fv,Lv,Bv,Rv,Nv,$x=ot(()=>{I_(),Eh=(t,s)=>{if(t===void 0)throw new Error("Image buffer must be defined");if(s.height===void 0||s.width===void 0)throw new Error("Image height and width must be defined");if(s.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:n,width:i}=s,l=s.norm??{mean:255,bias:0},o,c;typeof l.mean=="number"?o=[l.mean,l.mean,l.mean,l.mean]:o=[l.mean[0],l.mean[1],l.mean[2],l.mean[3]??255],typeof l.bias=="number"?c=[l.bias,l.bias,l.bias,l.bias]:c=[l.bias[0],l.bias[1],l.bias[2],l.bias[3]??0];let p=s.format!==void 0?s.format:"RGBA",d=s.tensorFormat!==void 0&&s.tensorFormat!==void 0?s.tensorFormat:"RGB",f=n*i,g=d==="RGBA"?new Float32Array(f*4):new Float32Array(f*3),_=4,y=0,T=1,b=2,k=3,L=0,C=f,S=f*2,I=-1;p==="RGB"&&(_=3,y=0,T=1,b=2,k=-1),d==="RGBA"?I=f*3:d==="RBG"?(L=0,S=f,C=f*2):d==="BGR"&&(S=0,C=f,L=f*2);for(let O=0;O<f;O++,y+=_,b+=_,T+=_,k+=_)g[L++]=(t[y]+c[0])/o[0],g[C++]=(t[T]+c[1])/o[1],g[S++]=(t[b]+c[2])/o[2],I!==-1&&k!==-1&&(g[I++]=(t[k]+c[3])/o[3]);return d==="RGBA"?new ma("float32",g,[1,4,n,i]):new ma("float32",g,[1,3,n,i])},Fv=async(t,s)=>{let n=typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement,i=typeof ImageData<"u"&&t instanceof ImageData,l=typeof ImageBitmap<"u"&&t instanceof ImageBitmap,o=typeof t=="string",c,p=s??{},d=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},f=g=>typeof HTMLCanvasElement<"u"&&g instanceof HTMLCanvasElement||g instanceof OffscreenCanvas?g.getContext("2d"):null;if(n){let g=d();g.width=t.width,g.height=t.height;let _=f(g);if(_!=null){let y=t.height,T=t.width;if(s!==void 0&&s.resizedHeight!==void 0&&s.resizedWidth!==void 0&&(y=s.resizedHeight,T=s.resizedWidth),s!==void 0){if(p=s,s.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");p.tensorFormat="RGBA",p.height=y,p.width=T}else p.tensorFormat="RGBA",p.height=y,p.width=T;_.drawImage(t,0,0),c=_.getImageData(0,0,T,y).data}else throw new Error("Can not access image data")}else if(i){let g,_;if(s!==void 0&&s.resizedWidth!==void 0&&s.resizedHeight!==void 0?(g=s.resizedHeight,_=s.resizedWidth):(g=t.height,_=t.width),s!==void 0&&(p=s),p.format="RGBA",p.height=g,p.width=_,s!==void 0){let y=d();y.width=_,y.height=g;let T=f(y);if(T!=null)T.putImageData(t,0,0),c=T.getImageData(0,0,_,g).data;else throw new Error("Can not access image data")}else c=t.data}else if(l){if(s===void 0)throw new Error("Please provide image config with format for Imagebitmap");let g=d();g.width=t.width,g.height=t.height;let _=f(g);if(_!=null){let y=t.height,T=t.width;return _.drawImage(t,0,0,T,y),c=_.getImageData(0,0,T,y).data,p.height=y,p.width=T,Eh(c,p)}else throw new Error("Can not access image data")}else{if(o)return new Promise((g,_)=>{let y=d(),T=f(y);if(!t||!T)return _();let b=new Image;b.crossOrigin="Anonymous",b.src=t,b.onload=()=>{y.width=b.width,y.height=b.height,T.drawImage(b,0,0,y.width,y.height);let k=T.getImageData(0,0,y.width,y.height);p.height=y.height,p.width=y.width,g(Eh(k.data,p))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(c!==void 0)return Eh(c,p);throw new Error("Input data provided is not supported - aborted tensor creation")},Lv=(t,s)=>{let{width:n,height:i,download:l,dispose:o}=s,c=[1,i,n,4];return new ma({location:"texture",type:"float32",texture:t,dims:c,download:l,dispose:o})},Bv=(t,s)=>{let{dataType:n,dims:i,download:l,dispose:o}=s;return new ma({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:i,download:l,dispose:o})},Rv=(t,s)=>{let{dataType:n,dims:i,download:l,dispose:o}=s;return new ma({location:"ml-tensor",type:n??"float32",mlTensor:t,dims:i,download:l,dispose:o})},Nv=(t,s,n)=>new ma({location:"cpu-pinned",type:t,data:s,dims:n??[s.length]})}),gc,Lp,wm,jv,Ox=ot(()=>{gc=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Lp=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),wm=!1,jv=()=>{if(!wm){wm=!0;let t=typeof BigInt64Array<"u"&&BigInt64Array.from,s=typeof BigUint64Array<"u"&&BigUint64Array.from,n=globalThis.Float16Array,i=typeof n<"u"&&n.from;t&&(gc.set("int64",BigInt64Array),Lp.set(BigInt64Array,"int64")),s&&(gc.set("uint64",BigUint64Array),Lp.set(BigUint64Array,"uint64")),i?(gc.set("float16",n),Lp.set(n,"float16")):gc.set("float16",Uint16Array)}}}),Uv,Vv,kx=ot(()=>{I_(),Uv=t=>{let s=1;for(let n=0;n<t.length;n++){let i=t[n];if(typeof i!="number"||!Number.isSafeInteger(i))throw new TypeError(`dims[${n}] must be an integer, got: ${i}`);if(i<0)throw new RangeError(`dims[${n}] must be a non-negative integer, got: ${i}`);s*=i}return s},Vv=(t,s)=>{switch(t.location){case"cpu":return new ma(t.type,t.data,s);case"cpu-pinned":return new ma({location:"cpu-pinned",data:t.data,type:t.type,dims:s});case"texture":return new ma({location:"texture",texture:t.texture,type:t.type,dims:s});case"gpu-buffer":return new ma({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:s});case"ml-tensor":return new ma({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:s});default:throw new Error(`tensorReshape: tensor location ${t.location} is not supported`)}}}),ma,I_=ot(()=>{Ax(),$x(),Ox(),kx(),ma=class{constructor(t,s,n){jv();let i,l;if(typeof t=="object"&&"location"in t)switch(this.dataLocation=t.location,i=t.type,l=t.dims,t.location){case"cpu-pinned":{let c=gc.get(i);if(!c)throw new TypeError(`unsupported type "${i}" to create tensor from pinned buffer`);if(!(t.data instanceof c))throw new TypeError(`buffer should be of type ${c.name}`);this.cpuData=t.data;break}case"texture":{if(i!=="float32")throw new TypeError(`unsupported type "${i}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break}case"gpu-buffer":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break}case"ml-tensor":{if(i!=="float32"&&i!=="float16"&&i!=="int32"&&i!=="int64"&&i!=="uint32"&&i!=="uint64"&&i!=="int8"&&i!=="uint8"&&i!=="bool"&&i!=="uint4"&&i!=="int4")throw new TypeError(`unsupported type "${i}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let c,p;if(typeof t=="string")if(i=t,p=n,t==="string"){if(!Array.isArray(s))throw new TypeError("A string tensor's data must be a string array.");c=s}else{let d=gc.get(t);if(d===void 0)throw new TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(s)){if(t==="float16"&&d===Uint16Array||t==="uint4"||t==="int4")throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${d.name} as data.`);t==="uint64"||t==="int64"?c=d.from(s,BigInt):c=d.from(s)}else if(s instanceof d)c=s;else if(s instanceof Uint8ClampedArray)if(t==="uint8")c=Uint8Array.from(s);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if(t==="float16"&&s instanceof Uint16Array&&d!==Uint16Array)c=new globalThis.Float16Array(s.buffer,s.byteOffset,s.length);else throw new TypeError(`A ${i} tensor's data must be type of ${d}`)}else if(p=s,Array.isArray(t)){if(t.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let d=typeof t[0];if(d==="string")i="string",c=t;else if(d==="boolean")i="bool",c=Uint8Array.from(t);else throw new TypeError(`Invalid element type of data array: ${d}.`)}else if(t instanceof Uint8ClampedArray)i="uint8",c=Uint8Array.from(t);else{let d=Lp.get(t.constructor);if(d===void 0)throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);i=d,c=t}if(p===void 0)p=[c.length];else if(!Array.isArray(p))throw new TypeError("A tensor's dims must be a number array");l=p,this.cpuData=c,this.dataLocation="cpu"}let o=Uv(l);if(this.cpuData&&o!==this.cpuData.length&&!((i==="uint4"||i==="int4")&&Math.ceil(o/2)===this.cpuData.length))throw new Error(`Tensor's size(${o}) does not match data length(${this.cpuData.length}).`);this.type=i,this.dims=l,this.size=o}static async fromImage(t,s){return Fv(t,s)}static fromTexture(t,s){return Lv(t,s)}static fromGpuBuffer(t,s){return Bv(t,s)}static fromMLTensor(t,s){return Rv(t,s)}static fromPinnedBuffer(t,s,n){return Nv(t,s,n)}toDataURL(t){return Iv(this,t)}toImageData(t){return zv(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let s=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=s,t&&this.disposer&&(this.disposer(),this.disposer=void 0),s}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return Vv(this,t)}}}),wi,Gv=ot(()=>{I_(),wi=ma}),Up,bm,Ti,ja,Wv=ot(()=>{Dv(),Up=(t,s)=>{(typeof Ra.trace>"u"?!Ra.wasm.trace:!Ra.trace)||console.timeStamp(`${t}::ORT::${s}`)},bm=(t,s)=>{var l;let n=((l=new Error().stack)==null?void 0:l.split(/\r\n|\r|\n/g))||[],i=!1;for(let o=0;o<n.length;o++){if(i&&!n[o].includes("TRACE_FUNC")){let c=`FUNC_${t}::${n[o].trim().split(" ")[1]}`;s&&(c+=`::${s}`),Up("CPU",c);return}n[o].includes("TRACE_FUNC")&&(i=!0)}},Ti=t=>{(typeof Ra.trace>"u"?!Ra.wasm.trace:!Ra.trace)||bm("BEGIN",t)},ja=t=>{(typeof Ra.trace>"u"?!Ra.wasm.trace:!Ra.trace)||bm("END",t)}}),Hv,Dx=ot(()=>{Ov(),Gv(),Wv(),Hv=class Kv{constructor(s){this.handler=s}async run(s,n,i){Ti();let l={},o={};if(typeof s!="object"||s===null||s instanceof wi||Array.isArray(s))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof n=="object"){if(n===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof wi)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(n.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(let f of n){if(typeof f!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(f)===-1)throw new RangeError(`'fetches' contains invalid output name: ${f}.`);l[f]=null}if(typeof i=="object"&&i!==null)o=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else{let f=!1,g=Object.getOwnPropertyNames(n);for(let _ of this.outputNames)if(g.indexOf(_)!==-1){let y=n[_];(y===null||y instanceof wi)&&(f=!0,c=!1,l[_]=y)}if(f){if(typeof i=="object"&&i!==null)o=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else o=n}}else if(typeof n<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let f of this.inputNames)if(typeof s[f]>"u")throw new Error(`input '${f}' is missing in 'feeds'.`);if(c)for(let f of this.outputNames)l[f]=null;let p=await this.handler.run(s,l,o),d={};for(let f in p)if(Object.hasOwnProperty.call(p,f)){let g=p[f];g instanceof wi?d[f]=g:d[f]=new wi(g.type,g.data,g.dims)}return ja(),d}async release(){return this.handler.dispose()}static async create(s,n,i,l){Ti();let o,c={};if(typeof s=="string"){if(o=s,typeof n=="object"&&n!==null)c=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(s instanceof Uint8Array){if(o=s,typeof n=="object"&&n!==null)c=n;else if(typeof n<"u")throw new TypeError("'options' must be an object.")}else if(s instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&s instanceof SharedArrayBuffer){let g=s,_=0,y=s.byteLength;if(typeof n=="object"&&n!==null)c=n;else if(typeof n=="number"){if(_=n,!Number.isSafeInteger(_))throw new RangeError("'byteOffset' must be an integer.");if(_<0||_>=g.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${g.byteLength}).`);if(y=s.byteLength-_,typeof i=="number"){if(y=i,!Number.isSafeInteger(y))throw new RangeError("'byteLength' must be an integer.");if(y<=0||_+y>g.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${g.byteLength-_}].`);if(typeof l=="object"&&l!==null)c=l;else if(typeof l<"u")throw new TypeError("'options' must be an object.")}else if(typeof i<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof n<"u")throw new TypeError("'options' must be an object.");o=new Uint8Array(g,_,y)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[p,d]=await $v(c),f=await p.createInferenceSessionHandler(o,d);return ja(),new Kv(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),z_,Ix=ot(()=>{Dx(),z_=Hv}),zx=ot(()=>{}),Fx=ot(()=>{}),Lx=ot(()=>{}),Bx=ot(()=>{}),qv={};Gp(qv,{InferenceSession:()=>z_,TRACE:()=>Up,TRACE_FUNC_BEGIN:()=>Ti,TRACE_FUNC_END:()=>ja,Tensor:()=>wi,env:()=>Hn,registerBackend:()=>vc});var xi=ot(()=>{Sx(),Px(),Ix(),Gv(),zx(),Fx(),Wv(),Lx(),Bx()}),F_=ot(()=>{}),Qv={};Gp(Qv,{default:()=>Xv});var Tm,xm,Xv,Rx=ot(()=>{var t;J1(),xc(),L_(),Tm="ort-wasm-proxy-worker",xm=((t=globalThis.self)==null?void 0:t.name)===Tm,xm&&(self.onmessage=s=>{let{type:n,in:i}=s.data;try{switch(n){case"init-wasm":B_(i.wasm).then(()=>{ng(i).then(()=>{postMessage({type:n})},l=>{postMessage({type:n,err:l})})},l=>{postMessage({type:n,err:l})});break;case"init-ep":{let{epName:l,env:o}=i;rg(o,l).then(()=>{postMessage({type:n})},c=>{postMessage({type:n,err:c})});break}case"copy-from":{let{buffer:l}=i,o=Qh(l);postMessage({type:n,out:o});break}case"create":{let{model:l,options:o}=i;sg(l,o).then(c=>{postMessage({type:n,out:c})},c=>{postMessage({type:n,err:c})});break}case"release":ag(i),postMessage({type:n});break;case"run":{let{sessionId:l,inputIndices:o,inputs:c,outputIndices:p,options:d}=i;ig(l,o,c,p,new Array(p.length).fill(null),d).then(f=>{f.some(g=>g[3]!=="cpu")?postMessage({type:n,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:n,out:f},lg([...c,...f]))},f=>{postMessage({type:n,err:f})});break}case"end-profiling":og(i),postMessage({type:n});break;default:}}catch(l){postMessage({type:n,err:l})}}),Xv=xm?null:s=>new Worker(s??ha,{type:"module",name:Tm})}),Yv={};Gp(Yv,{default:()=>Zv});var Em,Sm,Zv,qg,Nx=ot(()=>{var t,s;Sm=(Em=import.meta.url,async function(n={}){var Do;var i,l,o=n,c=new Promise((h,M)=>{i=h,l=M}),p=typeof window=="object",d=typeof WorkerGlobalScope<"u",f=d&&((Do=self.name)==null?void 0:Do.startsWith("em-pthread"));o.mountExternalData=(h,M)=>{h.startsWith("./")&&(h=h.substring(2)),(o.Bd||(o.Bd=new Map)).set(h,M)},o.unmountExternalData=()=>{delete o.Bd};var g=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let _=()=>{let h=($,D,R)=>(...te)=>{let me=Tn,$e=D==null?void 0:D();te=$(...te);let je=D==null?void 0:D();return $e!==je&&($=je,R($e),D=R=null),Tn!=me?new Promise((Ye,Xe)=>{wa={resolve:Ye,reject:Xe}}):te},M=$=>async(...D)=>{var R;try{if(o.Cd)throw Error("Session already started");let te=o.Cd={be:D[0],errors:[]},me=await $(...D);if(o.Cd!==te)throw Error("Session mismatch");(R=o.Dd)==null||R.flush();let $e=te.errors;if(0<$e.length){let je=await Promise.all($e);if(je=je.filter(Ye=>Ye),0<je.length)throw Error(je.join(`
`))}return me}finally{o.Cd=null}};o._OrtCreateSession=h(o._OrtCreateSession,()=>o._OrtCreateSession,$=>o._OrtCreateSession=$),o._OrtRun=M(h(o._OrtRun,()=>o._OrtRun,$=>o._OrtRun=$)),o._OrtRunWithBinding=M(h(o._OrtRunWithBinding,()=>o._OrtRunWithBinding,$=>o._OrtRunWithBinding=$)),o._OrtBindInput=h(o._OrtBindInput,()=>o._OrtBindInput,$=>o._OrtBindInput=$),_=void 0};o.jsepInit=(h,M)=>{if(_==null||_(),h==="webgpu"){[o.Dd,o.Rd,o.Vd,o.Hd,o.Ud,o.hc,o.Wd,o.Zd,o.Sd,o.Td,o.Xd]=M;let $=o.Dd;o.jsepRegisterBuffer=(D,R,te,me)=>$.registerBuffer(D,R,te,me),o.jsepGetBuffer=D=>$.getBuffer(D),o.jsepCreateDownloader=(D,R,te)=>$.createDownloader(D,R,te),o.jsepOnCreateSession=D=>{$.onCreateSession(D)},o.jsepOnReleaseSession=D=>{$.onReleaseSession(D)},o.jsepOnRunStart=D=>$.onRunStart(D),o.$d=(D,R)=>{$.upload(D,R)}}else if(h==="webnn"){[o.Dd,o.Yd,o.Id,o.jsepEnsureTensor,o.Jd,o.jsepDownloadTensor]=M,o.jsepReleaseTensorId=o.Id,o.jsepUploadTensor=o.Jd;let $=o.Dd;o.jsepOnRunStart=D=>$.onRunStart(D),o.jsepOnRunEnd=$.onRunEnd.bind($),o.jsepRegisterMLContext=(D,R)=>{$.registerMLContext(D,R)},o.jsepOnReleaseSession=D=>{$.onReleaseSession(D)},o.jsepCreateMLTensorDownloader=(D,R)=>$.createMLTensorDownloader(D,R),o.jsepRegisterMLTensor=(D,R,te,me)=>$.registerMLTensor(D,R,te,me),o.jsepCreateMLContext=D=>$.createMLContext(D),o.jsepRegisterMLConstant=(D,R,te,me,$e)=>$.registerMLConstant(D,R,te,me,$e,o.Bd),o.jsepRegisterGraphInput=$.registerGraphInput.bind($),o.jsepIsGraphInput=$.isGraphInput.bind($),o.jsepCreateTemporaryTensor=$.createTemporaryTensor.bind($)}};var y,T,b=Object.assign({},o),k=(h,M)=>{throw M},L="";(p||d)&&(d?L=self.location.href:typeof document<"u"&&document.currentScript&&(L=document.currentScript.src),Em&&(L=Em),L=L.startsWith("blob:")?"":L.slice(0,L.replace(/[?#].*/,"").lastIndexOf("/")+1),d&&(T=h=>{var M=new XMLHttpRequest;return M.open("GET",h,!1),M.responseType="arraybuffer",M.send(null),new Uint8Array(M.response)}),y=async h=>{if(W(h))return new Promise(($,D)=>{var R=new XMLHttpRequest;R.open("GET",h,!0),R.responseType="arraybuffer",R.onload=()=>{R.status==200||R.status==0&&R.response?$(R.response):D(R.status)},R.onerror=D,R.send(null)});var M=await fetch(h,{credentials:"same-origin"});if(M.ok)return M.arrayBuffer();throw Error(M.status+" : "+M.url)});var C=console.log.bind(console),S=console.error.bind(console),I=C,O=S;Object.assign(o,b),b=null;var x,E,A,F,K,X,oe,ie,J,ue,ne,G,se,ce=o.wasmBinary,ge=!1,W=h=>h.startsWith("file://");function U(){return x.buffer!=F.buffer&&ae(),F}function B(){return x.buffer!=F.buffer&&ae(),K}function Q(){return x.buffer!=F.buffer&&ae(),X}function le(){return x.buffer!=F.buffer&&ae(),oe}function re(){return x.buffer!=F.buffer&&ae(),ie}function ve(){return x.buffer!=F.buffer&&ae(),J}function Se(){return x.buffer!=F.buffer&&ae(),ue}function Be(){return x.buffer!=F.buffer&&ae(),se}if(f){let h=function(M){try{var $=M.data,D=$.yd;if(D==="load"){let R=[];self.onmessage=te=>R.push(te),self.startWorker=()=>{postMessage({yd:"loaded"});for(let te of R)h(te);self.onmessage=h};for(let te of $.Od)o[te]&&!o[te].proxy||(o[te]=(...me)=>{postMessage({yd:"callHandler",Nd:te,args:me})},te=="print"&&(I=o[te]),te=="printErr"&&(O=o[te]));x=$.he,ae(),ut($.ie)}else if(D==="run"){ga($.xd),yo($.xd,0,0,1,0,0),hn(),en($.xd),Oe||(Ys(),Oe=!0);try{Hr($.de,$.Fd)}catch(R){if(R!="unwind")throw R}}else $.target!=="setimmediate"&&(D==="checkMailbox"?Oe&&$n():D&&(O(`worker: received unknown command ${D}`),O($)))}catch(R){throw Zs(),R}};var ut,Oe=!1;O=function(...M){M=M.join(" "),console.error(M)},self.alert=function(...M){postMessage({yd:"alert",text:M.join(" "),fe:Qa()})},self.onunhandledrejection=M=>{throw M.reason||M},self.onmessage=h}function ae(){var h=x.buffer;o.HEAP8=F=new Int8Array(h),o.HEAP16=X=new Int16Array(h),o.HEAPU8=K=new Uint8Array(h),o.HEAPU16=oe=new Uint16Array(h),o.HEAP32=ie=new Int32Array(h),o.HEAPU32=J=new Uint32Array(h),o.HEAPF32=ue=new Float32Array(h),o.HEAPF64=se=new Float64Array(h),o.HEAP64=ne=new BigInt64Array(h),o.HEAPU64=G=new BigUint64Array(h)}function Z(){f?startWorker(o):Je.Bb()}f||(x=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),ae());var Ee,Ve=0,Ue=null;function qe(){if(--Ve==0&&Ue){var h=Ue;Ue=null,h()}}function We(h){throw O(h="Aborted("+h+")"),ge=!0,h=new WebAssembly.RuntimeError(h+". Build with -sASSERTIONS for more info."),l(h),h}function nt(){return{a:{Ta:V,Va:ct,W:_s,la:Pt,b:Hs,u:ya,R:Pr,Za:Nn,d:mn,pb:yt,g:Kr,T:mr,Ga:vs,lb:qr,nb:Lr,Ha:Pn,Ea:Ks,wb:Ua,Da:as,pa:ws,mb:Ei,jb:Ds,Fa:Va,kb:Si,Ma:Tr,za:uo,eb:xr,cb:Is,ya:Te,V:N,N:ee,db:de,ma:kt,fb:Zt,zb:sn,hb:gr,qb:Br,ab:Bn,Aa:bs,yb:en,Ja:wn,S:Zr,Wa:zs,$:co,H:Sc,E:Xo,l:Yr,F:ou,B:lu,X:uu,J:$c,v:cu,O:Hd,D:Zo,t:du,A:Oc,z:Jo,w:fu,r:kc,tb:Dc,ub:Ic,vb:el,rb:tl,sb:_u,bb:gu,Oa:zc,La:Fc,y:Ha,ja:Lc,Ba:Bc,Ka:yu,qa:Rc,Ia:Mu,ib:mo,U:Ts,fa:Ai,Sa:$i,gb:Nc,Qa:_o,Pa:rl,Ab:vu,Ca:al,ob:it,aa:wu,oa:bu,xb:il,na:qa,$a:Pu,ia:El,sa:la,ga:vl,da:Au,ua:Xi,p:ti,e:gl,c:js,ea:bl,f:Gi,n:Ca,k:ei,Y:Ao,ka:Hi,j:Vc,wa:$o,Ra:ko,ca:xl,Ua:Yi,P:Ki,K:Cu,_:qi,Q:Gc,Z:Ou,x:Su,m:_l,va:$u,i:Ns,h:vr,ra:ua,ta:Oo,o:Wi,q:jc,s:Yn,I:yl,C:Pa,L:Ml,xa:wl,_a:ia,G:Qi,Ya:ni,ba:oa,M:Uc,Xa:Tl,ha:ol,a:x,Na:rt}}}var at={1320978:()=>typeof wasmOffsetConverter<"u",1321035:(h,M,$,D,R)=>{if(o===void 0||!o.Bd)return 1;if((h=_n(Number(h>>>0))).startsWith("./")&&(h=h.substring(2)),!(h=o.Bd.get(h)))return 2;if(M=Number(M>>>0),$=Number($>>>0),D=Number(D>>>0),M+$>h.byteLength)return 3;try{let te=h.subarray(M,M+$);switch(R){case 0:B().set(te,D>>>0);break;case 1:o.$d(D,te);break;default:return 4}return 0}catch{return 4}},1321750:(h,M,$)=>{o.Jd(h,B().subarray(M>>>0,M+$>>>0))},1321813:()=>o.Yd(),1321854:h=>{o.Id(h)},1321890:()=>{o.Sd()},1321921:()=>{o.Td()},1321950:()=>{o.Xd()},1321975:h=>o.Rd(h),1322008:h=>o.Vd(h),1322040:(h,M,$)=>{o.Hd(Number(h),Number(M),Number($),!0)},1322103:(h,M,$)=>{o.Hd(Number(h),Number(M),Number($))},1322160:h=>{o.hc("Abs",h,void 0)},1322211:h=>{o.hc("Neg",h,void 0)},1322262:h=>{o.hc("Floor",h,void 0)},1322315:h=>{o.hc("Ceil",h,void 0)},1322367:h=>{o.hc("Reciprocal",h,void 0)},1322425:h=>{o.hc("Sqrt",h,void 0)},1322477:h=>{o.hc("Exp",h,void 0)},1322528:h=>{o.hc("Erf",h,void 0)},1322579:h=>{o.hc("Sigmoid",h,void 0)},1322634:(h,M,$)=>{o.hc("HardSigmoid",h,{alpha:M,beta:$})},1322713:h=>{o.hc("Log",h,void 0)},1322764:h=>{o.hc("Sin",h,void 0)},1322815:h=>{o.hc("Cos",h,void 0)},1322866:h=>{o.hc("Tan",h,void 0)},1322917:h=>{o.hc("Asin",h,void 0)},1322969:h=>{o.hc("Acos",h,void 0)},1323021:h=>{o.hc("Atan",h,void 0)},1323073:h=>{o.hc("Sinh",h,void 0)},1323125:h=>{o.hc("Cosh",h,void 0)},1323177:h=>{o.hc("Asinh",h,void 0)},1323230:h=>{o.hc("Acosh",h,void 0)},1323283:h=>{o.hc("Atanh",h,void 0)},1323336:h=>{o.hc("Tanh",h,void 0)},1323388:h=>{o.hc("Not",h,void 0)},1323439:(h,M,$)=>{o.hc("Clip",h,{min:M,max:$})},1323508:h=>{o.hc("Clip",h,void 0)},1323560:(h,M)=>{o.hc("Elu",h,{alpha:M})},1323618:h=>{o.hc("Gelu",h,void 0)},1323670:h=>{o.hc("Relu",h,void 0)},1323722:(h,M)=>{o.hc("LeakyRelu",h,{alpha:M})},1323786:(h,M)=>{o.hc("ThresholdedRelu",h,{alpha:M})},1323856:(h,M)=>{o.hc("Cast",h,{to:M})},1323914:h=>{o.hc("Add",h,void 0)},1323965:h=>{o.hc("Sub",h,void 0)},1324016:h=>{o.hc("Mul",h,void 0)},1324067:h=>{o.hc("Div",h,void 0)},1324118:h=>{o.hc("Pow",h,void 0)},1324169:h=>{o.hc("Equal",h,void 0)},1324222:h=>{o.hc("Greater",h,void 0)},1324277:h=>{o.hc("GreaterOrEqual",h,void 0)},1324339:h=>{o.hc("Less",h,void 0)},1324391:h=>{o.hc("LessOrEqual",h,void 0)},1324450:(h,M,$,D,R)=>{o.hc("ReduceMean",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1324625:(h,M,$,D,R)=>{o.hc("ReduceMax",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1324799:(h,M,$,D,R)=>{o.hc("ReduceMin",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1324973:(h,M,$,D,R)=>{o.hc("ReduceProd",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1325148:(h,M,$,D,R)=>{o.hc("ReduceSum",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1325322:(h,M,$,D,R)=>{o.hc("ReduceL1",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1325495:(h,M,$,D,R)=>{o.hc("ReduceL2",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1325668:(h,M,$,D,R)=>{o.hc("ReduceLogSum",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1325845:(h,M,$,D,R)=>{o.hc("ReduceSumSquare",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1326025:(h,M,$,D,R)=>{o.hc("ReduceLogSumExp",h,{keepDims:!!M,noopWithEmptyAxes:!!$,axes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1326205:h=>{o.hc("Where",h,void 0)},1326258:(h,M,$)=>{o.hc("Transpose",h,{perm:M?Array.from(re().subarray(Number(M)>>>0,Number($)>>>0)):[]})},1326382:(h,M,$,D)=>{o.hc("DepthToSpace",h,{blocksize:M,mode:_n($),format:D?"NHWC":"NCHW"})},1326515:(h,M,$,D)=>{o.hc("DepthToSpace",h,{blocksize:M,mode:_n($),format:D?"NHWC":"NCHW"})},1326648:(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn,cr)=>{o.hc("ConvTranspose",h,{format:je?"NHWC":"NCHW",autoPad:M,dilations:[$],group:D,kernelShape:[R],pads:[te,me],strides:[$e],wIsConst:()=>!!U()[Ye>>>0],outputPadding:Xe?Array.from(re().subarray(Number(Xe)>>>0,Number(pt)>>>0)):[],outputShape:vt?Array.from(re().subarray(Number(vt)>>>0,Number(fn)>>>0)):[],activation:_n(cr)})},1327081:(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn)=>{o.hc("ConvTranspose",h,{format:$e?"NHWC":"NCHW",autoPad:M,dilations:Array.from(re().subarray(Number($)>>>0,2+(Number($)>>>0)>>>0)),group:D,kernelShape:Array.from(re().subarray(Number(R)>>>0,2+(Number(R)>>>0)>>>0)),pads:Array.from(re().subarray(Number(te)>>>0,4+(Number(te)>>>0)>>>0)),strides:Array.from(re().subarray(Number(me)>>>0,2+(Number(me)>>>0)>>>0)),wIsConst:()=>!!U()[je>>>0],outputPadding:Ye?Array.from(re().subarray(Number(Ye)>>>0,Number(Xe)>>>0)):[],outputShape:pt?Array.from(re().subarray(Number(pt)>>>0,Number(vt)>>>0)):[],activation:_n(fn)})},1327742:(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn,cr)=>{o.hc("ConvTranspose",h,{format:je?"NHWC":"NCHW",autoPad:M,dilations:[$],group:D,kernelShape:[R],pads:[te,me],strides:[$e],wIsConst:()=>!!U()[Ye>>>0],outputPadding:Xe?Array.from(re().subarray(Number(Xe)>>>0,Number(pt)>>>0)):[],outputShape:vt?Array.from(re().subarray(Number(vt)>>>0,Number(fn)>>>0)):[],activation:_n(cr)})},1328175:(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn)=>{o.hc("ConvTranspose",h,{format:$e?"NHWC":"NCHW",autoPad:M,dilations:Array.from(re().subarray(Number($)>>>0,2+(Number($)>>>0)>>>0)),group:D,kernelShape:Array.from(re().subarray(Number(R)>>>0,2+(Number(R)>>>0)>>>0)),pads:Array.from(re().subarray(Number(te)>>>0,4+(Number(te)>>>0)>>>0)),strides:Array.from(re().subarray(Number(me)>>>0,2+(Number(me)>>>0)>>>0)),wIsConst:()=>!!U()[je>>>0],outputPadding:Ye?Array.from(re().subarray(Number(Ye)>>>0,Number(Xe)>>>0)):[],outputShape:pt?Array.from(re().subarray(Number(pt)>>>0,Number(vt)>>>0)):[],activation:_n(fn)})},1328836:(h,M)=>{o.hc("GlobalAveragePool",h,{format:M?"NHWC":"NCHW"})},1328927:(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn)=>{o.hc("AveragePool",h,{format:fn?"NHWC":"NCHW",auto_pad:M,ceil_mode:$,count_include_pad:D,storage_order:R,dilations:te?Array.from(re().subarray(Number(te)>>>0,Number(me)>>>0)):[],kernel_shape:$e?Array.from(re().subarray(Number($e)>>>0,Number(je)>>>0)):[],pads:Ye?Array.from(re().subarray(Number(Ye)>>>0,Number(Xe)>>>0)):[],strides:pt?Array.from(re().subarray(Number(pt)>>>0,Number(vt)>>>0)):[]})},1329406:(h,M)=>{o.hc("GlobalAveragePool",h,{format:M?"NHWC":"NCHW"})},1329497:(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn)=>{o.hc("AveragePool",h,{format:fn?"NHWC":"NCHW",auto_pad:M,ceil_mode:$,count_include_pad:D,storage_order:R,dilations:te?Array.from(re().subarray(Number(te)>>>0,Number(me)>>>0)):[],kernel_shape:$e?Array.from(re().subarray(Number($e)>>>0,Number(je)>>>0)):[],pads:Ye?Array.from(re().subarray(Number(Ye)>>>0,Number(Xe)>>>0)):[],strides:pt?Array.from(re().subarray(Number(pt)>>>0,Number(vt)>>>0)):[]})},1329976:(h,M)=>{o.hc("GlobalMaxPool",h,{format:M?"NHWC":"NCHW"})},1330063:(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn)=>{o.hc("MaxPool",h,{format:fn?"NHWC":"NCHW",auto_pad:M,ceil_mode:$,count_include_pad:D,storage_order:R,dilations:te?Array.from(re().subarray(Number(te)>>>0,Number(me)>>>0)):[],kernel_shape:$e?Array.from(re().subarray(Number($e)>>>0,Number(je)>>>0)):[],pads:Ye?Array.from(re().subarray(Number(Ye)>>>0,Number(Xe)>>>0)):[],strides:pt?Array.from(re().subarray(Number(pt)>>>0,Number(vt)>>>0)):[]})},1330538:(h,M)=>{o.hc("GlobalMaxPool",h,{format:M?"NHWC":"NCHW"})},1330625:(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn)=>{o.hc("MaxPool",h,{format:fn?"NHWC":"NCHW",auto_pad:M,ceil_mode:$,count_include_pad:D,storage_order:R,dilations:te?Array.from(re().subarray(Number(te)>>>0,Number(me)>>>0)):[],kernel_shape:$e?Array.from(re().subarray(Number($e)>>>0,Number(je)>>>0)):[],pads:Ye?Array.from(re().subarray(Number(Ye)>>>0,Number(Xe)>>>0)):[],strides:pt?Array.from(re().subarray(Number(pt)>>>0,Number(vt)>>>0)):[]})},1331100:(h,M,$,D,R)=>{o.hc("Gemm",h,{alpha:M,beta:$,transA:D,transB:R})},1331204:h=>{o.hc("MatMul",h,void 0)},1331258:(h,M,$,D)=>{o.hc("ArgMax",h,{keepDims:!!M,selectLastIndex:!!$,axis:D})},1331366:(h,M,$,D)=>{o.hc("ArgMin",h,{keepDims:!!M,selectLastIndex:!!$,axis:D})},1331474:(h,M)=>{o.hc("Softmax",h,{axis:M})},1331537:(h,M)=>{o.hc("Concat",h,{axis:M})},1331597:(h,M,$,D,R)=>{o.hc("Split",h,{axis:M,numOutputs:$,splitSizes:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1331753:h=>{o.hc("Expand",h,void 0)},1331807:(h,M)=>{o.hc("Gather",h,{axis:Number(M)})},1331878:(h,M)=>{o.hc("GatherElements",h,{axis:Number(M)})},1331957:(h,M)=>{o.hc("GatherND",h,{batch_dims:Number(M)})},1332036:(h,M,$,D,R,te,me,$e,je,Ye,Xe)=>{o.hc("Resize",h,{antialias:M,axes:$?Array.from(re().subarray(Number($)>>>0,Number(D)>>>0)):[],coordinateTransformMode:_n(R),cubicCoeffA:te,excludeOutside:me,extrapolationValue:$e,keepAspectRatioPolicy:_n(je),mode:_n(Ye),nearestMode:_n(Xe)})},1332398:(h,M,$,D,R,te,me)=>{o.hc("Slice",h,{starts:M?Array.from(re().subarray(Number(M)>>>0,Number($)>>>0)):[],ends:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[],axes:te?Array.from(re().subarray(Number(te)>>>0,Number(me)>>>0)):[]})},1332662:h=>{o.hc("Tile",h,void 0)},1332714:(h,M,$)=>{o.hc("InstanceNormalization",h,{epsilon:M,format:$?"NHWC":"NCHW"})},1332828:(h,M,$)=>{o.hc("InstanceNormalization",h,{epsilon:M,format:$?"NHWC":"NCHW"})},1332942:h=>{o.hc("Range",h,void 0)},1332995:(h,M)=>{o.hc("Einsum",h,{equation:_n(M)})},1333076:(h,M,$,D,R)=>{o.hc("Pad",h,{mode:M,value:$,pads:D?Array.from(re().subarray(Number(D)>>>0,Number(R)>>>0)):[]})},1333219:(h,M,$,D,R,te)=>{o.hc("BatchNormalization",h,{epsilon:M,momentum:$,spatial:!!R,trainingMode:!!D,format:te?"NHWC":"NCHW"})},1333388:(h,M,$,D,R,te)=>{o.hc("BatchNormalization",h,{epsilon:M,momentum:$,spatial:!!R,trainingMode:!!D,format:te?"NHWC":"NCHW"})},1333557:(h,M,$)=>{o.hc("CumSum",h,{exclusive:Number(M),reverse:Number($)})},1333654:(h,M,$)=>{o.hc("DequantizeLinear",h,{axis:M,blockSize:$})},1333744:(h,M,$,D,R)=>{o.hc("GridSample",h,{align_corners:M,mode:_n($),padding_mode:_n(D),format:R?"NHWC":"NCHW"})},1333914:(h,M,$,D,R)=>{o.hc("GridSample",h,{align_corners:M,mode:_n($),padding_mode:_n(D),format:R?"NHWC":"NCHW"})},1334084:(h,M)=>{o.hc("ScatterND",h,{reduction:_n(M)})},1334169:(h,M,$,D,R,te,me,$e,je)=>{o.hc("Attention",h,{numHeads:M,isUnidirectional:$,maskFilterValue:D,scale:R,doRotary:te,qkvHiddenSizes:me?Array.from(re().subarray(Number($e)>>>0,Number($e)+me>>>0)):[],pastPresentShareBuffer:!!je})},1334441:h=>{o.hc("BiasAdd",h,void 0)},1334496:h=>{o.hc("BiasSplitGelu",h,void 0)},1334557:h=>{o.hc("FastGelu",h,void 0)},1334613:(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn,cr,Vr)=>{o.hc("Conv",h,{format:pt?"NHWC":"NCHW",auto_pad:M,dilations:$?Array.from(re().subarray(Number($)>>>0,Number(D)>>>0)):[],group:R,kernel_shape:te?Array.from(re().subarray(Number(te)>>>0,Number(me)>>>0)):[],pads:$e?Array.from(re().subarray(Number($e)>>>0,Number(je)>>>0)):[],strides:Ye?Array.from(re().subarray(Number(Ye)>>>0,Number(Xe)>>>0)):[],w_is_const:()=>!!U()[Number(vt)>>>0],activation:_n(fn),activation_params:cr?Array.from(Se().subarray(Number(cr)>>>0,Number(Vr)>>>0)):[]})},1335197:h=>{o.hc("Gelu",h,void 0)},1335249:(h,M,$,D,R,te,me,$e,je)=>{o.hc("GroupQueryAttention",h,{numHeads:M,kvNumHeads:$,scale:D,softcap:R,doRotary:te,rotaryInterleaved:me,smoothSoftmax:$e,localWindowSize:je})},1335466:(h,M,$,D)=>{o.hc("LayerNormalization",h,{axis:M,epsilon:$,simplified:!!D})},1335577:(h,M,$,D)=>{o.hc("LayerNormalization",h,{axis:M,epsilon:$,simplified:!!D})},1335688:(h,M,$,D,R,te)=>{o.hc("MatMulNBits",h,{k:M,n:$,accuracyLevel:D,bits:R,blockSize:te})},1335815:(h,M,$,D,R,te)=>{o.hc("MultiHeadAttention",h,{numHeads:M,isUnidirectional:$,maskFilterValue:D,scale:R,doRotary:te})},1335974:(h,M)=>{o.hc("QuickGelu",h,{alpha:M})},1336038:(h,M,$,D,R)=>{o.hc("RotaryEmbedding",h,{interleaved:!!M,numHeads:$,rotaryEmbeddingDim:D,scale:R})},1336177:(h,M,$)=>{o.hc("SkipLayerNormalization",h,{epsilon:M,simplified:!!$})},1336279:(h,M,$)=>{o.hc("SkipLayerNormalization",h,{epsilon:M,simplified:!!$})},1336381:(h,M,$,D)=>{o.hc("GatherBlockQuantized",h,{gatherAxis:M,quantizeAxis:$,blockSize:D})},1336502:h=>{o.Wd(h)},1336536:(h,M)=>o.Zd(Number(h),Number(M),o.Cd.be,o.Cd.errors)};function ct(h,M,$){return Wa(async()=>{await o.Ud(Number(h),Number(M),Number($))})}function V(){return typeof wasmOffsetConverter<"u"}class fe{constructor(M){he(this,"name","ExitStatus");this.message=`Program terminated with exit(${M})`,this.status=M}}var q=h=>{h.terminate(),h.onmessage=()=>{}},pe=[],we=h=>{mt.length==0&&(Ws(),Kn(mt[0]));var M=mt.pop();if(!M)return 6;_t.push(M),Ft[h.xd]=M,M.xd=h.xd;var $={yd:"run",de:h.ce,Fd:h.Fd,xd:h.xd};return M.postMessage($,h.Ld),0},Fe=0,De=(h,M,...$)=>{for(var D=2*$.length,R=zt(),te=wo(8*D),me=te>>>3,$e=0;$e<$.length;$e++){var je=$[$e];typeof je=="bigint"?(ne[me+2*$e]=1n,ne[me+2*$e+1]=je):(ne[me+2*$e]=0n,Be()[me+2*$e+1>>>0]=je)}return h=Js(h,0,D,te,M),It(R),h};function rt(h){if(f)return De(0,1,h);if(A=h,!(0<Fe)){for(var M of _t)q(M);for(M of mt)q(M);mt=[],_t=[],Ft={},ge=!0}k(0,new fe(h))}function He(h){if(f)return De(1,0,h);it(h)}var it=h=>{if(A=h,f)throw He(h),"unwind";rt(h)},mt=[],_t=[],Ot=[],Ft={},Dn=h=>{var M=h.xd;delete Ft[M],mt.push(h),_t.splice(_t.indexOf(h),1),h.xd=0,Mo(M)};function hn(){Ot.forEach(h=>h())}var Kn=h=>new Promise(M=>{h.onmessage=R=>{var te=(R=R.data).yd;if(R.Ed&&R.Ed!=Qa()){var me=Ft[R.Ed];me?me.postMessage(R,R.Ld):O(`Internal error! Worker sent a message "${te}" to target pthread ${R.Ed}, but that thread no longer exists!`)}else te==="checkMailbox"?$n():te==="spawnThread"?we(R):te==="cleanupThread"?Dn(Ft[R.ee]):te==="loaded"?(h.loaded=!0,M(h)):te==="alert"?alert(`Thread ${R.fe}: ${R.text}`):R.target==="setimmediate"?h.postMessage(R):te==="callHandler"?o[R.Nd](...R.args):te&&O(`worker sent an unknown command ${te}`)},h.onerror=R=>{throw O(`worker sent an error! ${R.filename}:${R.lineno}: ${R.message}`),R};var $,D=[];for($ of[])o.propertyIsEnumerable($)&&D.push($);h.postMessage({yd:"load",Od:D,he:x,ie:E})});function Ws(){var h=new Worker((()=>{let M=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new M("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});mt.push(h)}var ga=h=>{ae();var M=ve()[h+52>>>2>>>0];h=ve()[h+56>>>2>>>0],xu(M,M-h),It(M)},Hr=(h,M)=>{Fe=0,h=ea(h,M),0<Fe?A=h:vo(h)},ms=[];function _s(h){var M=new ys(h>>>=0);if(U()[M.wd+12>>>0]==0){var $=1;U()[M.wd+12>>>0]=$}return $=0,U()[M.wd+13>>>0]=$,ms.push(M),Di(h),fl(h)}var gs=0,Pt=()=>{Lt(0,0);var h=ms.pop();dl(h.Gd),gs=0};class ys{constructor(M){this.Gd=M,this.wd=M-24}}function Kr(h){throw gs||(gs=h>>>0),gs}var Ms=h=>{var M=gs;if(!M)return Ta(0),0;var $=new ys(M);ve()[$.wd+16>>>2>>>0]=M;var D=ve()[$.wd+4>>>2>>>0];if(!D)return Ta(0),M;for(var R of h){if(R===0||R===D)break;if(Jr(R,D,$.wd+16))return Ta(R),M}return Ta(D),M};function Hs(){return Ms([])}function ya(h){return Ms([h>>>0])}function Pr(h,M){return Ms([h>>>0,M>>>0])}var Nn=()=>{var h=ms.pop();h||We("no exception to throw");var M=h.Gd;if(U()[h.wd+13>>>0]==0){ms.push(h);var $=1;U()[h.wd+13>>>0]=$,$=0,U()[h.wd+12>>>0]=$}throw gs=M};function mn(h,M,$){var D=new ys(h>>>=0);throw M>>>=0,$>>>=0,ve()[D.wd+16>>>2>>>0]=0,ve()[D.wd+4>>>2>>>0]=M,ve()[D.wd+8>>>2>>>0]=$,gs=h}function st(h,M,$,D){return f?De(2,1,h,M,$,D):yt(h,M,$,D)}function yt(h,M,$,D){if(h>>>=0,$>>>=0,D>>>=0,g===void 0)return 6;var R=[];return f&&R.length===0?st(h,M>>>=0,$,D):(h={ce:$,xd:h,Fd:D,Ld:R},f?(h.yd="spawnThread",postMessage(h,R),0):we(h))}var Et=typeof TextDecoder<"u"?new TextDecoder:void 0,Qn=(h,M=0,$=NaN)=>{var D=(M>>>=0)+$;for($=M;h[$]&&!($>=D);)++$;if(16<$-M&&h.buffer&&Et)return Et.decode(h.buffer instanceof ArrayBuffer?h.subarray(M,$):h.slice(M,$));for(D="";M<$;){var R=h[M++];if(128&R){var te=63&h[M++];if((224&R)==192)D+=String.fromCharCode((31&R)<<6|te);else{var me=63&h[M++];65536>(R=(240&R)==224?(15&R)<<12|te<<6|me:(7&R)<<18|te<<12|me<<6|63&h[M++])?D+=String.fromCharCode(R):(R-=65536,D+=String.fromCharCode(55296|R>>10,56320|1023&R))}}else D+=String.fromCharCode(R)}return D},_n=(h,M)=>(h>>>=0)?Qn(B(),h,M):"";function mr(h,M,$){return f?De(3,1,h,M,$):0}function vs(h,M){if(f)return De(4,1,h,M)}var Fr=h=>{for(var M=0,$=0;$<h.length;++$){var D=h.charCodeAt($);127>=D?M++:2047>=D?M+=2:55296<=D&&57343>=D?(M+=4,++$):M+=3}return M},rr=(h,M,$)=>{var D=B();if(M>>>=0,0<$){var R=M;$=M+$-1;for(var te=0;te<h.length;++te){var me=h.charCodeAt(te);if(55296<=me&&57343>=me&&(me=65536+((1023&me)<<10)|1023&h.charCodeAt(++te)),127>=me){if(M>=$)break;D[M++>>>0]=me}else{if(2047>=me){if(M+1>=$)break;D[M++>>>0]=192|me>>6}else{if(65535>=me){if(M+2>=$)break;D[M++>>>0]=224|me>>12}else{if(M+3>=$)break;D[M++>>>0]=240|me>>18,D[M++>>>0]=128|me>>12&63}D[M++>>>0]=128|me>>6&63}D[M++>>>0]=128|63&me}}D[M>>>0]=0,h=M-R}else h=0;return h};function qr(h,M){if(f)return De(5,1,h,M)}function Lr(h,M,$){if(f)return De(6,1,h,M,$)}function Pn(h,M,$){return f?De(7,1,h,M,$):0}function Ks(h,M){if(f)return De(8,1,h,M)}function Ua(h,M,$){if(f)return De(9,1,h,M,$)}function as(h,M,$,D){if(f)return De(10,1,h,M,$,D)}function ws(h,M,$,D){if(f)return De(11,1,h,M,$,D)}function Ei(h,M,$,D){if(f)return De(12,1,h,M,$,D)}function Ds(h){if(f)return De(13,1,h)}function Va(h,M){if(f)return De(14,1,h,M)}function Si(h,M,$){if(f)return De(15,1,h,M,$)}var qs,Ar,Tr=()=>We(""),_r=h=>{for(var M="";B()[h>>>0];)M+=qs[B()[h++>>>0]];return M},Ma={},is={};function $r(h,M,$={}){return function(D,R,te={}){var me=R.name;if(!D)throw new Ar(`type "${me}" must have a positive integer typeid pointer`);if(is.hasOwnProperty(D)){if(te.Pd)return;throw new Ar(`Cannot register type '${me}' twice`)}is[D]=R,Ma.hasOwnProperty(D)&&(R=Ma[D],delete Ma[D],R.forEach($e=>$e()))}(h,M,$)}var os=(h,M,$)=>{switch(M){case 1:return $?D=>U()[D>>>0]:D=>B()[D>>>0];case 2:return $?D=>Q()[D>>>1>>>0]:D=>le()[D>>>1>>>0];case 4:return $?D=>re()[D>>>2>>>0]:D=>ve()[D>>>2>>>0];case 8:return $?D=>ne[D>>>3]:D=>G[D>>>3];default:throw new TypeError(`invalid integer width (${M}): ${h}`)}};function uo(h,M,$){$>>>=0,$r(h>>>=0,{name:M=_r(M>>>0),fromWireType:D=>D,toWireType:function(D,R){if(typeof R!="bigint"&&typeof R!="number")throw R=R===null?"null":(D=typeof R)=="object"||D==="array"||D==="function"?R.toString():""+R,new TypeError(`Cannot convert "${R}" to ${this.name}`);return typeof R=="number"&&(R=BigInt(R)),R},zd:Qr,readValueFromPointer:os(M,$,M.indexOf("u")==-1),Ad:null})}var Qr=8;function xr(h,M,$,D){$r(h>>>=0,{name:M=_r(M>>>0),fromWireType:function(R){return!!R},toWireType:function(R,te){return te?$:D},zd:Qr,readValueFromPointer:function(R){return this.fromWireType(B()[R>>>0])},Ad:null})}var va=[],Xr=[];function Yr(h){9<(h>>>=0)&&--Xr[h+1]==0&&(Xr[h]=void 0,va.push(h))}var lr=h=>{if(!h)throw new Ar("Cannot use deleted val. handle = "+h);return Xr[h]},sr=h=>{switch(h){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let M=va.pop()||Xr.length;return Xr[M]=h,Xr[M+1]=1,M}};function Ga(h){return this.fromWireType(ve()[h>>>2>>>0])}var Er={name:"emscripten::val",fromWireType:h=>{var M=lr(h);return Yr(h),M},toWireType:(h,M)=>sr(M),zd:Qr,readValueFromPointer:Ga,Ad:null};function Is(h){return $r(h>>>0,Er)}var Ci=(h,M)=>{switch(M){case 4:return function($){return this.fromWireType(Se()[$>>>2>>>0])};case 8:return function($){return this.fromWireType(Be()[$>>>3>>>0])};default:throw new TypeError(`invalid float width (${M}): ${h}`)}};function Te(h,M,$){$>>>=0,$r(h>>>=0,{name:M=_r(M>>>0),fromWireType:D=>D,toWireType:(D,R)=>R,zd:Qr,readValueFromPointer:Ci(M,$),Ad:null})}function N(h,M,$,D,R){if(h>>>=0,$>>>=0,M=_r(M>>>0),R===-1&&(R=4294967295),R=$e=>$e,D===0){var te=32-8*$;R=$e=>$e<<te>>>te}var me=M.includes("unsigned")?function($e,je){return je>>>0}:function($e,je){return je};$r(h,{name:M,fromWireType:R,toWireType:me,zd:Qr,readValueFromPointer:os(M,$,D!==0),Ad:null})}function ee(h,M,$){function D(te){var me=ve()[te>>>2>>>0];return te=ve()[te+4>>>2>>>0],new R(U().buffer,te,me)}var R=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][M];$r(h>>>=0,{name:$=_r($>>>0),fromWireType:D,zd:Qr,readValueFromPointer:D},{Pd:!0})}function de(h,M){$r(h>>>=0,{name:M=_r(M>>>0),fromWireType:function($){for(var D,R=ve()[$>>>2>>>0],te=$+4,me=te,$e=0;$e<=R;++$e){var je=te+$e;$e!=R&&B()[je>>>0]!=0||(me=_n(me,je-me),D===void 0?D=me:(D+="\0",D+=me),me=je+1)}return Or($),D},toWireType:function($,D){D instanceof ArrayBuffer&&(D=new Uint8Array(D));var R=typeof D=="string";if(!(R||D instanceof Uint8Array||D instanceof Uint8ClampedArray||D instanceof Int8Array))throw new Ar("Cannot pass non-string to std::string");var te=R?Fr(D):D.length,me=ba(4+te+1),$e=me+4;if(ve()[me>>>2>>>0]=te,R)rr(D,$e,te+1);else if(R)for(R=0;R<te;++R){var je=D.charCodeAt(R);if(255<je)throw Or(me),new Ar("String has UTF-16 code units that do not fit in 8 bits");B()[$e+R>>>0]=je}else for(R=0;R<te;++R)B()[$e+R>>>0]=D[R];return $!==null&&$.push(Or,me),me},zd:Qr,readValueFromPointer:Ga,Ad($){Or($)}})}var Me=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,xe=(h,M)=>{for(var $=h>>1,D=$+M/2;!($>=D)&&le()[$>>>0];)++$;if(32<($<<=1)-h&&Me)return Me.decode(B().slice(h,$));for($="",D=0;!(D>=M/2);++D){var R=Q()[h+2*D>>>1>>>0];if(R==0)break;$+=String.fromCharCode(R)}return $},Ge=(h,M,$)=>{if($??($=2147483647),2>$)return 0;var D=M;$=($-=2)<2*h.length?$/2:h.length;for(var R=0;R<$;++R){var te=h.charCodeAt(R);Q()[M>>>1>>>0]=te,M+=2}return Q()[M>>>1>>>0]=0,M-D},lt=h=>2*h.length,ht=(h,M)=>{for(var $=0,D="";!($>=M/4);){var R=re()[h+4*$>>>2>>>0];if(R==0)break;++$,65536<=R?(R-=65536,D+=String.fromCharCode(55296|R>>10,56320|1023&R)):D+=String.fromCharCode(R)}return D},ft=(h,M,$)=>{if(M>>>=0,$??($=2147483647),4>$)return 0;var D=M;$=D+$-4;for(var R=0;R<h.length;++R){var te=h.charCodeAt(R);if(55296<=te&&57343>=te&&(te=65536+((1023&te)<<10)|1023&h.charCodeAt(++R)),re()[M>>>2>>>0]=te,(M+=4)+4>$)break}return re()[M>>>2>>>0]=0,M-D},Mt=h=>{for(var M=0,$=0;$<h.length;++$){var D=h.charCodeAt($);55296<=D&&57343>=D&&++$,M+=4}return M};function kt(h,M,$){if(h>>>=0,M>>>=0,$=_r($>>>=0),M===2)var D=xe,R=Ge,te=lt,me=$e=>le()[$e>>>1>>>0];else M===4&&(D=ht,R=ft,te=Mt,me=$e=>ve()[$e>>>2>>>0]);$r(h,{name:$,fromWireType:$e=>{for(var je,Ye=ve()[$e>>>2>>>0],Xe=$e+4,pt=0;pt<=Ye;++pt){var vt=$e+4+pt*M;pt!=Ye&&me(vt)!=0||(Xe=D(Xe,vt-Xe),je===void 0?je=Xe:(je+="\0",je+=Xe),Xe=vt+M)}return Or($e),je},toWireType:($e,je)=>{if(typeof je!="string")throw new Ar(`Cannot pass non-string to C++ string type ${$}`);var Ye=te(je),Xe=ba(4+Ye+M);return ve()[Xe>>>2>>>0]=Ye/M,R(je,Xe+4,Ye+M),$e!==null&&$e.push(Or,Xe),Xe},zd:Qr,readValueFromPointer:Ga,Ad($e){Or($e)}})}function Zt(h,M){$r(h>>>=0,{Qd:!0,name:M=_r(M>>>0),zd:0,fromWireType:()=>{},toWireType:()=>{}})}function sn(h){yo(h>>>0,!d,1,!p,131072,!1),hn()}var gn=h=>{if(!ge)try{if(h(),!(0<Fe))try{f?vo(A):it(A)}catch(M){M instanceof fe||M=="unwind"||k(0,M)}}catch(M){M instanceof fe||M=="unwind"||k(0,M)}};function en(h){h>>>=0,typeof Atomics.ge=="function"&&(Atomics.ge(re(),h>>>2,h).value.then($n),h+=128,Atomics.store(re(),h>>>2,1))}var $n=()=>{var h=Qa();h&&(en(h),gn(cl))};function gr(h,M){(h>>>=0)==M>>>0?setTimeout($n):f?postMessage({Ed:h,yd:"checkMailbox"}):(h=Ft[h])&&h.postMessage({yd:"checkMailbox"})}var yr=[];function Br(h,M,$,D,R){for(M>>>=0,D/=2,yr.length=D,$=R>>>0>>>3,R=0;R<D;R++)yr[R]=ne[$+2*R]?ne[$+2*R+1]:Be()[$+2*R+1>>>0];return(M?at[M]:ul[h])(...yr)}var Bn=()=>{Fe=0};function bs(h){h>>>=0,f?postMessage({yd:"cleanupThread",ee:h}):Dn(Ft[h])}function wn(h){}var bn=(h,M)=>{var $=is[h];if($===void 0)throw h=Tu(h),$=_r(h),Or(h),new Ar(`${M} has unknown type ${$}`);return $},ur=(h,M,$)=>{var D=[];return h=h.toWireType(D,$),D.length&&(ve()[M>>>2>>>0]=sr(D)),h};function Zr(h,M,$){return M>>>=0,$>>>=0,h=lr(h>>>0),M=bn(M,"emval::as"),ur(M,$,h)}function zs(h,M){return M>>>=0,h=lr(h>>>0),(M=bn(M,"emval::as")).toWireType(null,h)}var On=h=>{try{h()}catch(M){We(M)}},Xn=0,Tn=null,nn=0,yn=[],In={},jn={},Pi=0,wa=null,Qo=[];function Wa(h){return function(M){if(!ge){if(Xn===0){var $=!1,D=!1;M((R=0)=>{if(!ge&&(nn=R,$=!0,D)){Xn=2,On(()=>aa(Tn)),typeof MainLoop<"u"&&MainLoop.Md&&MainLoop.resume(),R=!1;try{var te=function(){var je=re()[Tn+8>>>2>>>0];return je=Je[jn[je]],--Fe,je()}()}catch(je){te=je,R=!0}var me=!1;if(!Tn){var $e=wa;$e&&(wa=null,(R?$e.reject:$e.resolve)(te),me=!0)}if(R&&!me)throw te}}),D=!0,$||(Xn=1,Tn=function(){var R=ba(65548),te=R+12;ve()[R>>>2>>>0]=te,ve()[R+4>>>2>>>0]=te+65536,te=yn[0];var me=In[te];return me===void 0&&(me=Pi++,In[te]=me,jn[me]=te),te=me,re()[R+8>>>2>>>0]=te,R}(),typeof MainLoop<"u"&&MainLoop.Md&&MainLoop.pause(),On(()=>Ja(Tn)))}else Xn===2?(Xn=0,On(Cs),Or(Tn),Tn=null,Qo.forEach(gn)):We(`invalid state: ${Xn}`);return nn}}(M=>{h().then(M)})}function co(h){return h>>>=0,Wa(async()=>{var M=await lr(h);return sr(M)})}var Fs=[];function Sc(h,M,$,D){return $>>>=0,D>>>=0,(h=Fs[h>>>0])(null,M=lr(M>>>0),$,D)}var Cc={},fo=h=>{var M=Cc[h];return M===void 0?_r(h):M};function Xo(h,M,$,D,R){return $>>>=0,D>>>=0,R>>>=0,(h=Fs[h>>>0])(M=lr(M>>>0),M[$=fo($)],D,R)}var iu=()=>typeof globalThis=="object"?globalThis:Function("return this")();function ou(h){return(h>>>=0)==0?sr(iu()):(h=fo(h),sr(iu()[h]))}var Pc=h=>{var M=Fs.length;return Fs.push(h),M},Ac=(h,M)=>{for(var $=Array(h),D=0;D<h;++D)$[D]=bn(ve()[M+4*D>>>2>>>0],"parameter "+D);return $},Yo=(h,M)=>Object.defineProperty(M,"name",{value:h});function lu(h,M,$){var D=(M=Ac(h,M>>>0)).shift();h--;var R=`return function (obj, func, destructorsRef, args) {
`,te=0,me=[];$===0&&me.push("obj");for(var $e=["retType"],je=[D],Ye=0;Ye<h;++Ye)me.push("arg"+Ye),$e.push("argType"+Ye),je.push(M[Ye]),R+=`  var arg${Ye} = argType${Ye}.readValueFromPointer(args${te?"+"+te:""});
`,te+=M[Ye].zd;return R+=`  var rv = ${$===1?"new func":"func.call"}(${me.join(", ")});
`,D.Qd||($e.push("emval_returnValue"),je.push(ur),R+=`  return emval_returnValue(retType, destructorsRef, rv);
`),$e.push(R+`};
`),h=function(Xe){var pt=Function;if(!(pt instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof pt} which is not a function`);var vt=Yo(pt.name||"unknownFunctionName",function(){});return vt.prototype=pt.prototype,vt=new vt,(Xe=pt.apply(vt,Xe))instanceof Object?Xe:vt}($e)(...je),$=`methodCaller<(${M.map(Xe=>Xe.name).join(", ")}) => ${D.name}>`,Pc(Yo($,h))}function uu(h){return h=fo(h>>>0),sr(o[h])}function $c(h,M){return M>>>=0,h=lr(h>>>0),M=lr(M),sr(h[M])}function cu(h){9<(h>>>=0)&&(Xr[h+1]+=1)}function Hd(){return sr([])}function Zo(h){h=lr(h>>>0);for(var M=Array(h.length),$=0;$<h.length;$++)M[$]=h[$];return sr(M)}function du(h){return sr(fo(h>>>0))}function Oc(){return sr({})}function Jo(h){for(var M=lr(h>>>=0);M.length;){var $=M.pop();M.pop()($)}Yr(h)}function fu(h,M,$){M>>>=0,$>>>=0,h=lr(h>>>0),M=lr(M),$=lr($),h[M]=$}function kc(h,M){return M>>>=0,h=(h=bn(h>>>0,"_emval_take_value")).readValueFromPointer(M),sr(h)}function Dc(h,M){h=-9007199254740992>h||9007199254740992<h?NaN:Number(h),M>>>=0,h=new Date(1e3*h),re()[M>>>2>>>0]=h.getUTCSeconds(),re()[M+4>>>2>>>0]=h.getUTCMinutes(),re()[M+8>>>2>>>0]=h.getUTCHours(),re()[M+12>>>2>>>0]=h.getUTCDate(),re()[M+16>>>2>>>0]=h.getUTCMonth(),re()[M+20>>>2>>>0]=h.getUTCFullYear()-1900,re()[M+24>>>2>>>0]=h.getUTCDay(),h=(h.getTime()-Date.UTC(h.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,re()[M+28>>>2>>>0]=h}var pu=h=>h%4==0&&(h%100!=0||h%400==0),hu=[0,31,60,91,121,152,182,213,244,274,305,335],mu=[0,31,59,90,120,151,181,212,243,273,304,334];function Ic(h,M){h=-9007199254740992>h||9007199254740992<h?NaN:Number(h),M>>>=0,h=new Date(1e3*h),re()[M>>>2>>>0]=h.getSeconds(),re()[M+4>>>2>>>0]=h.getMinutes(),re()[M+8>>>2>>>0]=h.getHours(),re()[M+12>>>2>>>0]=h.getDate(),re()[M+16>>>2>>>0]=h.getMonth(),re()[M+20>>>2>>>0]=h.getFullYear()-1900,re()[M+24>>>2>>>0]=h.getDay();var $=(pu(h.getFullYear())?hu:mu)[h.getMonth()]+h.getDate()-1|0;re()[M+28>>>2>>>0]=$,re()[M+36>>>2>>>0]=-60*h.getTimezoneOffset(),$=new Date(h.getFullYear(),6,1).getTimezoneOffset();var D=new Date(h.getFullYear(),0,1).getTimezoneOffset();h=0|($!=D&&h.getTimezoneOffset()==Math.min(D,$)),re()[M+32>>>2>>>0]=h}function el(h){h>>>=0;var M=new Date(re()[h+20>>>2>>>0]+1900,re()[h+16>>>2>>>0],re()[h+12>>>2>>>0],re()[h+8>>>2>>>0],re()[h+4>>>2>>>0],re()[h>>>2>>>0],0),$=re()[h+32>>>2>>>0],D=M.getTimezoneOffset(),R=new Date(M.getFullYear(),6,1).getTimezoneOffset(),te=new Date(M.getFullYear(),0,1).getTimezoneOffset(),me=Math.min(te,R);return 0>$?re()[h+32>>>2>>>0]=+(R!=te&&me==D):0<$!=(me==D)&&(R=Math.max(te,R),M.setTime(M.getTime()+6e4*((0<$?me:R)-D))),re()[h+24>>>2>>>0]=M.getDay(),$=(pu(M.getFullYear())?hu:mu)[M.getMonth()]+M.getDate()-1|0,re()[h+28>>>2>>>0]=$,re()[h>>>2>>>0]=M.getSeconds(),re()[h+4>>>2>>>0]=M.getMinutes(),re()[h+8>>>2>>>0]=M.getHours(),re()[h+12>>>2>>>0]=M.getDate(),re()[h+16>>>2>>>0]=M.getMonth(),re()[h+20>>>2>>>0]=M.getYear(),h=M.getTime(),BigInt(isNaN(h)?-1:h/1e3)}function tl(h,M,$,D,R,te,me){return f?De(16,1,h,M,$,D,R,te,me):-52}function _u(h,M,$,D,R,te){if(f)return De(17,1,h,M,$,D,R,te)}var Qs={},Ts=()=>performance.timeOrigin+performance.now();function gu(h,M){if(f)return De(18,1,h,M);if(Qs[h]&&(clearTimeout(Qs[h].id),delete Qs[h]),!M)return 0;var $=setTimeout(()=>{delete Qs[h],gn(()=>Ls(h,performance.timeOrigin+performance.now()))},M);return Qs[h]={id:$,ke:M},0}function zc(h,M,$,D){h>>>=0,M>>>=0,$>>>=0,D>>>=0;var R=new Date().getFullYear(),te=new Date(R,0,1).getTimezoneOffset();R=new Date(R,6,1).getTimezoneOffset();var me=Math.max(te,R);ve()[h>>>2>>>0]=60*me,re()[M>>>2>>>0]=+(te!=R),h=(M=$e=>{var je=Math.abs($e);return`UTC${0<=$e?"-":"+"}${String(Math.floor(je/60)).padStart(2,"0")}${String(je%60).padStart(2,"0")}`})(te),M=M(R),R<te?(rr(h,$,17),rr(M,D,17)):(rr(h,D,17),rr(M,$,17))}var yu=()=>Date.now();function Fc(h,M,$){return 0<=h&&3>=h?(h===0?h=Date.now():h=performance.timeOrigin+performance.now(),ne[$>>>0>>>3]=BigInt(Math.round(1e6*h)),0):28}var po=[],ho=(h,M)=>{po.length=0;for(var $;$=B()[h++>>>0];){var D=$!=105;M+=(D&=$!=112)&&M%8?4:0,po.push($==112?ve()[M>>>2>>>0]:$==106?ne[M>>>3]:$==105?re()[M>>>2>>>0]:Be()[M>>>3>>>0]),M+=D?8:4}return po};function Ha(h,M,$){return h>>>=0,M=ho(M>>>0,$>>>0),at[h](...M)}function Lc(h,M,$){return h>>>=0,M=ho(M>>>0,$>>>0),at[h](...M)}var Bc=()=>{};function Rc(h,M){return O(_n(h>>>0,M>>>0))}var Mu=()=>{throw Fe+=1,"unwind"};function mo(){return 4294901760}var Ai=()=>navigator.hardwareConcurrency;function $i(){return We("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Nc(h){h>>>=0;var M=B().length;if(h<=M||4294901760<h)return!1;for(var $=1;4>=$;$*=2){var D=M*(1+.2/$);D=Math.min(D,h+100663296);e:{D=(Math.min(4294901760,65536*Math.ceil(Math.max(h,D)/65536))-x.buffer.byteLength+65535)/65536|0;try{x.grow(D),ae();var R=1;break e}catch{}R=void 0}if(R)return!0}return!1}var Xs=()=>(We("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),Ka={},nl=h=>{h.forEach(M=>{Xs()})};function _o(){var h=Error().stack.toString().split(`
`);return h[0]=="Error"&&h.shift(),nl(h),Ka.Kd=Xs(),Ka.ae=h,Ka.Kd}function rl(h,M,$){if(h>>>=0,M>>>=0,Ka.Kd==h)var D=Ka.ae;else(D=Error().stack.toString().split(`
`))[0]=="Error"&&D.shift(),nl(D);for(var R=3;D[R]&&Xs()!=h;)++R;for(h=0;h<$&&D[h+R];++h)re()[M+4*h>>>2>>>0]=Xs();return h}var go,Oi={},sl=()=>{if(!go){var h,M={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(h in Oi)Oi[h]===void 0?delete M[h]:M[h]=Oi[h];var $=[];for(h in M)$.push(`${h}=${M[h]}`);go=$}return go};function vu(h,M){if(f)return De(19,1,h,M);h>>>=0,M>>>=0;var $=0;return sl().forEach((D,R)=>{var te=M+$;for(R=ve()[h+4*R>>>2>>>0]=te,te=0;te<D.length;++te)U()[R++>>>0]=D.charCodeAt(te);U()[R>>>0]=0,$+=D.length+1}),0}function al(h,M){if(f)return De(20,1,h,M);h>>>=0,M>>>=0;var $=sl();ve()[h>>>2>>>0]=$.length;var D=0;return $.forEach(R=>D+=R.length+1),ve()[M>>>2>>>0]=D,0}function wu(h){return f?De(21,1,h):52}function bu(h,M,$,D){return f?De(22,1,h,M,$,D):52}function il(h,M,$,D){return f?De(23,1,h,M,$,D):70}var Rr=[null,[],[]];function qa(h,M,$,D){if(f)return De(24,1,h,M,$,D);M>>>=0,$>>>=0,D>>>=0;for(var R=0,te=0;te<$;te++){var me=ve()[M>>>2>>>0],$e=ve()[M+4>>>2>>>0];M+=8;for(var je=0;je<$e;je++){var Ye=B()[me+je>>>0],Xe=Rr[h];Ye===0||Ye===10?((h===1?I:O)(Qn(Xe)),Xe.length=0):Xe.push(Ye)}R+=$e}return ve()[D>>>2>>>0]=R,0}function ol(h){return h>>>0}f||function(){for(var h=o.numThreads-1;h--;)Ws();pe.unshift(()=>{Ve++,function(M){f?M():Promise.all(mt.map(Kn)).then(M)}(()=>qe())})}();for(var ll=Array(256),ki=0;256>ki;++ki)ll[ki]=String.fromCharCode(ki);qs=ll,Ar=o.BindingError=class extends Error{constructor(h){super(h),this.name="BindingError"}},o.InternalError=class extends Error{constructor(h){super(h),this.name="InternalError"}},Xr.push(0,1,void 0,1,null,1,!0,1,!1,1),o.count_emval_handles=()=>Xr.length/2-5-va.length;var Je,ul=[rt,He,st,mr,vs,qr,Lr,Pn,Ks,Ua,as,ws,Ei,Ds,Va,Si,tl,_u,gu,vu,al,wu,bu,il,qa];(async function(){function h(D,R){return Je=D.exports,Je=function(){var te=Je,me={};for(let[$e,je]of Object.entries(te))me[$e]=typeof je=="function"?(...Ye)=>{yn.push($e);try{return je(...Ye)}finally{ge||(yn.pop(),Tn&&Xn===1&&yn.length===0&&(Xn=0,Fe+=1,On(Po),typeof Fibers<"u"&&Fibers.le()))}}:je;return me}(),Je=function(){var te=Je,me=je=>Ye=>je(Ye)>>>0,$e=je=>()=>je()>>>0;return(te=Object.assign({},te)).Cb=me(te.Cb),te.fc=$e(te.fc),te.ic=me(te.ic),te.vc=me(te.vc),te.wc=$e(te.wc),te.Ac=me(te.Ac),te}(),Ot.push(Je.jc),E=R,qe(),Je}Ve++;var M=nt();if(o.instantiateWasm)return new Promise(D=>{o.instantiateWasm(M,(R,te)=>{h(R,te),D(R.exports)})});if(f)return new Promise(D=>{ut=R=>{var te=new WebAssembly.Instance(R,nt());D(h(te,R))}});Ee??(Ee=o.locateFile?o.locateFile?o.locateFile("ort-wasm-simd-threaded.jsep.wasm",L):L+"ort-wasm-simd-threaded.jsep.wasm":new URL("/whisper-in-browser/assets/ort-wasm-simd-threaded.jsep-BAR87mbD.wasm",import.meta.url).href);try{var $=await async function(D){var R=Ee;if(!ce&&typeof WebAssembly.instantiateStreaming=="function"&&!W(R))try{var te=fetch(R,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(te,D)}catch(me){O(`wasm streaming compile failed: ${me}`),O("falling back to ArrayBuffer instantiation")}return async function(me,$e){try{var je=await async function(Ye){if(!ce)try{var Xe=await y(Ye);return new Uint8Array(Xe)}catch{}if(Ye==Ee&&ce)Ye=new Uint8Array(ce);else{if(!T)throw"both async and sync fetching of the wasm failed";Ye=T(Ye)}return Ye}(me);return await WebAssembly.instantiate(je,$e)}catch(Ye){O(`failed to asynchronously prepare wasm: ${Ye}`),We(Ye)}}(R,D)}(M);return h($.instance,$.module)}catch(D){return l(D),Promise.reject(D)}})();var Tu=h=>(Tu=Je.Cb)(h),Ys=()=>(Ys=Je.Db)();o._OrtInit=(h,M)=>(o._OrtInit=Je.Eb)(h,M),o._OrtGetLastError=(h,M)=>(o._OrtGetLastError=Je.Fb)(h,M),o._OrtCreateSessionOptions=(h,M,$,D,R,te,me,$e,je,Ye)=>(o._OrtCreateSessionOptions=Je.Gb)(h,M,$,D,R,te,me,$e,je,Ye),o._OrtAppendExecutionProvider=(h,M)=>(o._OrtAppendExecutionProvider=Je.Hb)(h,M),o._OrtAddFreeDimensionOverride=(h,M,$)=>(o._OrtAddFreeDimensionOverride=Je.Ib)(h,M,$),o._OrtAddSessionConfigEntry=(h,M,$)=>(o._OrtAddSessionConfigEntry=Je.Jb)(h,M,$),o._OrtReleaseSessionOptions=h=>(o._OrtReleaseSessionOptions=Je.Kb)(h),o._OrtCreateSession=(h,M,$)=>(o._OrtCreateSession=Je.Lb)(h,M,$),o._OrtReleaseSession=h=>(o._OrtReleaseSession=Je.Mb)(h),o._OrtGetInputOutputCount=(h,M,$)=>(o._OrtGetInputOutputCount=Je.Nb)(h,M,$),o._OrtGetInputName=(h,M)=>(o._OrtGetInputName=Je.Ob)(h,M),o._OrtGetOutputName=(h,M)=>(o._OrtGetOutputName=Je.Pb)(h,M),o._OrtFree=h=>(o._OrtFree=Je.Qb)(h),o._OrtCreateTensor=(h,M,$,D,R,te)=>(o._OrtCreateTensor=Je.Rb)(h,M,$,D,R,te),o._OrtGetTensorData=(h,M,$,D,R)=>(o._OrtGetTensorData=Je.Sb)(h,M,$,D,R),o._OrtReleaseTensor=h=>(o._OrtReleaseTensor=Je.Tb)(h),o._OrtCreateRunOptions=(h,M,$,D)=>(o._OrtCreateRunOptions=Je.Ub)(h,M,$,D),o._OrtAddRunConfigEntry=(h,M,$)=>(o._OrtAddRunConfigEntry=Je.Vb)(h,M,$),o._OrtReleaseRunOptions=h=>(o._OrtReleaseRunOptions=Je.Wb)(h),o._OrtCreateBinding=h=>(o._OrtCreateBinding=Je.Xb)(h),o._OrtBindInput=(h,M,$)=>(o._OrtBindInput=Je.Yb)(h,M,$),o._OrtBindOutput=(h,M,$,D)=>(o._OrtBindOutput=Je.Zb)(h,M,$,D),o._OrtClearBoundOutputs=h=>(o._OrtClearBoundOutputs=Je._b)(h),o._OrtReleaseBinding=h=>(o._OrtReleaseBinding=Je.$b)(h),o._OrtRunWithBinding=(h,M,$,D,R)=>(o._OrtRunWithBinding=Je.ac)(h,M,$,D,R),o._OrtRun=(h,M,$,D,R,te,me,$e)=>(o._OrtRun=Je.bc)(h,M,$,D,R,te,me,$e),o._OrtEndProfiling=h=>(o._OrtEndProfiling=Je.cc)(h),o._JsepOutput=(h,M,$)=>(o._JsepOutput=Je.dc)(h,M,$),o._JsepGetNodeName=h=>(o._JsepGetNodeName=Je.ec)(h);var Qa=()=>(Qa=Je.fc)(),Or=o._free=h=>(Or=o._free=Je.gc)(h),ba=o._malloc=h=>(ba=o._malloc=Je.ic)(h),yo=(h,M,$,D,R,te)=>(yo=Je.kc)(h,M,$,D,R,te),Zs=()=>(Zs=Je.lc)(),Js=(h,M,$,D,R)=>(Js=Je.mc)(h,M,$,D,R),Mo=h=>(Mo=Je.nc)(h),vo=h=>(vo=Je.oc)(h),Ls=(h,M)=>(Ls=Je.pc)(h,M),cl=()=>(cl=Je.qc)(),Lt=(h,M)=>(Lt=Je.rc)(h,M),Ta=h=>(Ta=Je.sc)(h),xu=(h,M)=>(xu=Je.tc)(h,M),It=h=>(It=Je.uc)(h),wo=h=>(wo=Je.vc)(h),zt=()=>(zt=Je.wc)(),dl=h=>(dl=Je.xc)(h),Di=h=>(Di=Je.yc)(h),Jr=(h,M,$)=>(Jr=Je.zc)(h,M,$),fl=h=>(fl=Je.Ac)(h),kr=o.dynCall_iii=(h,M,$)=>(kr=o.dynCall_iii=Je.Bc)(h,M,$),Nr=o.dynCall_vi=(h,M)=>(Nr=o.dynCall_vi=Je.Cc)(h,M),ea=o.dynCall_ii=(h,M)=>(ea=o.dynCall_ii=Je.Dc)(h,M),Ii=o.dynCall_vii=(h,M,$)=>(Ii=o.dynCall_vii=Je.Ec)(h,M,$),zi=o.dynCall_iiii=(h,M,$,D)=>(zi=o.dynCall_iiii=Je.Fc)(h,M,$,D),Fi=o.dynCall_viii=(h,M,$,D)=>(Fi=o.dynCall_viii=Je.Gc)(h,M,$,D),Li=o.dynCall_iiiii=(h,M,$,D,R)=>(Li=o.dynCall_iiiii=Je.Hc)(h,M,$,D,R),xa=o.dynCall_viiii=(h,M,$,D,R)=>(xa=o.dynCall_viiii=Je.Ic)(h,M,$,D,R),pl=o.dynCall_viiiiii=(h,M,$,D,R,te,me)=>(pl=o.dynCall_viiiiii=Je.Jc)(h,M,$,D,R,te,me),Xa=o.dynCall_viiiiiii=(h,M,$,D,R,te,me,$e)=>(Xa=o.dynCall_viiiiiii=Je.Kc)(h,M,$,D,R,te,me,$e),Ea=o.dynCall_ji=(h,M)=>(Ea=o.dynCall_ji=Je.Lc)(h,M),Eu=o.dynCall_v=h=>(Eu=o.dynCall_v=Je.Mc)(h),Sr=o.dynCall_viiiii=(h,M,$,D,R,te)=>(Sr=o.dynCall_viiiii=Je.Nc)(h,M,$,D,R,te),bo=o.dynCall_i=h=>(bo=o.dynCall_i=Je.Oc)(h),xs=o.dynCall_fii=(h,M,$)=>(xs=o.dynCall_fii=Je.Pc)(h,M,$),To=o.dynCall_viiiiiiii=(h,M,$,D,R,te,me,$e,je)=>(To=o.dynCall_viiiiiiii=Je.Qc)(h,M,$,D,R,te,me,$e,je),Bi=o.dynCall_viiiiiiiiii=(h,M,$,D,R,te,me,$e,je,Ye,Xe)=>(Bi=o.dynCall_viiiiiiiiii=Je.Rc)(h,M,$,D,R,te,me,$e,je,Ye,Xe),ta=o.dynCall_jiii=(h,M,$,D)=>(ta=o.dynCall_jiii=Je.Sc)(h,M,$,D),Ri=o.dynCall_dii=(h,M,$)=>(Ri=o.dynCall_dii=Je.Tc)(h,M,$),xo=o.dynCall_viiiiiiiii=(h,M,$,D,R,te,me,$e,je,Ye)=>(xo=o.dynCall_viiiiiiiii=Je.Uc)(h,M,$,D,R,te,me,$e,je,Ye),Sa=o.dynCall_viiiiiiiiiii=(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt)=>(Sa=o.dynCall_viiiiiiiiiii=Je.Vc)(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt),na=o.dynCall_iiiiii=(h,M,$,D,R,te)=>(na=o.dynCall_iiiiii=Je.Wc)(h,M,$,D,R,te),Ni=o.dynCall_iij=(h,M,$)=>(Ni=o.dynCall_iij=Je.Xc)(h,M,$),ji=o.dynCall_iiiiiiiiii=(h,M,$,D,R,te,me,$e,je,Ye)=>(ji=o.dynCall_iiiiiiiiii=Je.Yc)(h,M,$,D,R,te,me,$e,je,Ye),jr=o.dynCall_iiiiiiiiiii=(h,M,$,D,R,te,me,$e,je,Ye,Xe)=>(jr=o.dynCall_iiiiiiiiiii=Je.Zc)(h,M,$,D,R,te,me,$e,je,Ye,Xe),Ur=o.dynCall_vij=(h,M,$)=>(Ur=o.dynCall_vij=Je._c)(h,M,$),Bs=o.dynCall_iiif=(h,M,$,D)=>(Bs=o.dynCall_iiif=Je.$c)(h,M,$,D),Es=o.dynCall_iiij=(h,M,$,D)=>(Es=o.dynCall_iiij=Je.ad)(h,M,$,D),Ss=o.dynCall_fiii=(h,M,$,D)=>(Ss=o.dynCall_fiii=Je.bd)(h,M,$,D),Rs=o.dynCall_viiiiiiiiiiiii=(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn)=>(Rs=o.dynCall_viiiiiiiiiiiii=Je.cd)(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn),hl=o.dynCall_vjiii=(h,M,$,D,R)=>(hl=o.dynCall_vjiii=Je.dd)(h,M,$,D,R),Eo=o.dynCall_vif=(h,M,$)=>(Eo=o.dynCall_vif=Je.ed)(h,M,$),Ui=o.dynCall_iiiiiii=(h,M,$,D,R,te,me)=>(Ui=o.dynCall_iiiiiii=Je.fd)(h,M,$,D,R,te,me),Mr=o.dynCall_iiiij=(h,M,$,D,R)=>(Mr=o.dynCall_iiiij=Je.gd)(h,M,$,D,R),zn=o.dynCall_iiiiiiii=(h,M,$,D,R,te,me,$e)=>(zn=o.dynCall_iiiiiiii=Je.hd)(h,M,$,D,R,te,me,$e),an=o.dynCall_viiiiiiiiiiii=(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt)=>(an=o.dynCall_viiiiiiiiiiii=Je.id)(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt),ra=o.dynCall_diii=(h,M,$,D)=>(ra=o.dynCall_diii=Je.jd)(h,M,$,D),ls=o.dynCall_jiiii=(h,M,$,D,R)=>(ls=o.dynCall_jiiii=Je.kd)(h,M,$,D,R),Vi=o.dynCall_viiij=(h,M,$,D,R)=>(Vi=o.dynCall_viiij=Je.ld)(h,M,$,D,R),sa=o.dynCall_fiiii=(h,M,$,D,R)=>(sa=o.dynCall_fiiii=Je.md)(h,M,$,D,R),ml=o.dynCall_viiif=(h,M,$,D,R)=>(ml=o.dynCall_viiif=Je.nd)(h,M,$,D,R),So=o.dynCall_diiii=(h,M,$,D,R)=>(So=o.dynCall_diiii=Je.od)(h,M,$,D,R),Ya=o.dynCall_viiid=(h,M,$,D,R)=>(Ya=o.dynCall_viiid=Je.pd)(h,M,$,D,R),Za=o.dynCall_iiiijii=(h,M,$,D,R,te,me)=>(Za=o.dynCall_iiiijii=Je.qd)(h,M,$,D,R,te,me),Co=o.dynCall_iiiiiij=(h,M,$,D,R,te,me)=>(Co=o.dynCall_iiiiiij=Je.rd)(h,M,$,D,R,te,me),Ja=h=>(Ja=Je.sd)(h),Po=()=>(Po=Je.td)(),aa=h=>(aa=Je.ud)(h),Cs=()=>(Cs=Je.vd)();function Ns(h,M,$){var D=zt();try{Ii(h,M,$)}catch(R){if(It(D),R!==R+0)throw R;Lt(1,0)}}function js(h,M,$){var D=zt();try{return kr(h,M,$)}catch(R){if(It(D),R!==R+0)throw R;Lt(1,0)}}function _l(h,M){var $=zt();try{Nr(h,M)}catch(D){if(It($),D!==D+0)throw D;Lt(1,0)}}function gl(h,M){var $=zt();try{return ea(h,M)}catch(D){if(It($),D!==D+0)throw D;Lt(1,0)}}function Gi(h,M,$,D){var R=zt();try{return zi(h,M,$,D)}catch(te){if(It(R),te!==te+0)throw te;Lt(1,0)}}function Wi(h,M,$,D,R){var te=zt();try{xa(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;Lt(1,0)}}function Ca(h,M,$,D,R){var te=zt();try{return Li(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;Lt(1,0)}}function vr(h,M,$,D){var R=zt();try{Fi(h,M,$,D)}catch(te){if(It(R),te!==te+0)throw te;Lt(1,0)}}function Ao(h,M,$,D,R,te,me){var $e=zt();try{return Ui(h,M,$,D,R,te,me)}catch(je){if(It($e),je!==je+0)throw je;Lt(1,0)}}function Su(h){var M=zt();try{Eu(h)}catch($){if(It(M),$!==$+0)throw $;Lt(1,0)}}function Cu(h,M,$){var D=zt();try{return Ni(h,M,$)}catch(R){if(It(D),R!==R+0)throw R;Lt(1,0)}}function jc(h,M,$,D,R,te){var me=zt();try{Sr(h,M,$,D,R,te)}catch($e){if(It(me),$e!==$e+0)throw $e;Lt(1,0)}}function Uc(h,M,$){var D=zt();try{Ur(h,M,$)}catch(R){if(It(D),R!==R+0)throw R;Lt(1,0)}}function Yn(h,M,$,D,R,te,me){var $e=zt();try{pl(h,M,$,D,R,te,me)}catch(je){if(It($e),je!==je+0)throw je;Lt(1,0)}}function yl(h,M,$,D,R,te,me,$e){var je=zt();try{Xa(h,M,$,D,R,te,me,$e)}catch(Ye){if(It(je),Ye!==Ye+0)throw Ye;Lt(1,0)}}function ei(h,M,$,D,R,te){var me=zt();try{return na(h,M,$,D,R,te)}catch($e){if(It(me),$e!==$e+0)throw $e;Lt(1,0)}}function Hi(h,M,$,D,R,te,me,$e){var je=zt();try{return zn(h,M,$,D,R,te,me,$e)}catch(Ye){if(It(je),Ye!==Ye+0)throw Ye;Lt(1,0)}}function Ml(h,M,$,D,R,te,me,$e,je,Ye){var Xe=zt();try{xo(h,M,$,D,R,te,me,$e,je,Ye)}catch(pt){if(It(Xe),pt!==pt+0)throw pt;Lt(1,0)}}function Pa(h,M,$,D,R,te,me,$e,je){var Ye=zt();try{To(h,M,$,D,R,te,me,$e,je)}catch(Xe){if(It(Ye),Xe!==Xe+0)throw Xe;Lt(1,0)}}function ti(h){var M=zt();try{return bo(h)}catch($){if(It(M),$!==$+0)throw $;Lt(1,0)}}function Vc(h,M,$,D,R,te,me,$e,je,Ye){var Xe=zt();try{return ji(h,M,$,D,R,te,me,$e,je,Ye)}catch(pt){if(It(Xe),pt!==pt+0)throw pt;Lt(1,0)}}function vl(h,M,$){var D=zt();try{return xs(h,M,$)}catch(R){if(It(D),R!==R+0)throw R;Lt(1,0)}}function Gc(h,M,$,D){var R=zt();try{return ta(h,M,$,D)}catch(te){if(It(R),te!==te+0)throw te;return Lt(1,0),0n}}function Pu(h,M,$){var D=zt();try{return Ri(h,M,$)}catch(R){if(It(D),R!==R+0)throw R;Lt(1,0)}}function ia(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt){var vt=zt();try{Sa(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt)}catch(fn){if(It(vt),fn!==fn+0)throw fn;Lt(1,0)}}function wl(h,M,$,D,R,te,me,$e,je,Ye,Xe){var pt=zt();try{Bi(h,M,$,D,R,te,me,$e,je,Ye,Xe)}catch(vt){if(It(pt),vt!==vt+0)throw vt;Lt(1,0)}}function $o(h,M,$,D,R,te,me,$e,je,Ye,Xe){var pt=zt();try{return jr(h,M,$,D,R,te,me,$e,je,Ye,Xe)}catch(vt){if(It(pt),vt!==vt+0)throw vt;Lt(1,0)}}function bl(h,M,$,D){var R=zt();try{return Bs(h,M,$,D)}catch(te){if(It(R),te!==te+0)throw te;Lt(1,0)}}function Ki(h,M,$,D){var R=zt();try{return Es(h,M,$,D)}catch(te){if(It(R),te!==te+0)throw te;Lt(1,0)}}function Au(h,M,$,D){var R=zt();try{return Ss(h,M,$,D)}catch(te){if(It(R),te!==te+0)throw te;Lt(1,0)}}function ni(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn){var cr=zt();try{Rs(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt,fn)}catch(Vr){if(It(cr),Vr!==Vr+0)throw Vr;Lt(1,0)}}function Tl(h,M,$,D,R){var te=zt();try{hl(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;Lt(1,0)}}function $u(h,M,$){var D=zt();try{Eo(h,M,$)}catch(R){if(It(D),R!==R+0)throw R;Lt(1,0)}}function qi(h,M){var $=zt();try{return Ea(h,M)}catch(D){if(It($),D!==D+0)throw D;return Lt(1,0),0n}}function xl(h,M,$,D,R){var te=zt();try{return Mr(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;Lt(1,0)}}function Qi(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt){var fn=zt();try{an(h,M,$,D,R,te,me,$e,je,Ye,Xe,pt,vt)}catch(cr){if(It(fn),cr!==cr+0)throw cr;Lt(1,0)}}function El(h,M,$,D){var R=zt();try{return ra(h,M,$,D)}catch(te){if(It(R),te!==te+0)throw te;Lt(1,0)}}function Ou(h,M,$,D,R){var te=zt();try{return ls(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;return Lt(1,0),0n}}function oa(h,M,$,D,R){var te=zt();try{Vi(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;Lt(1,0)}}function Xi(h,M,$,D,R){var te=zt();try{return sa(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;Lt(1,0)}}function Oo(h,M,$,D,R){var te=zt();try{ml(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;Lt(1,0)}}function la(h,M,$,D,R){var te=zt();try{return So(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;Lt(1,0)}}function ua(h,M,$,D,R){var te=zt();try{Ya(h,M,$,D,R)}catch(me){if(It(te),me!==me+0)throw me;Lt(1,0)}}function Yi(h,M,$,D,R,te,me){var $e=zt();try{return Za(h,M,$,D,R,te,me)}catch(je){if(It($e),je!==je+0)throw je;Lt(1,0)}}function ko(h,M,$,D,R,te,me){var $e=zt();try{return Co(h,M,$,D,R,te,me)}catch(je){if(It($e),je!==je+0)throw je;Lt(1,0)}}return o.stackSave=()=>zt(),o.stackRestore=h=>It(h),o.stackAlloc=h=>wo(h),o.setValue=function(h,M,$="i8"){switch($.endsWith("*")&&($="*"),$){case"i1":case"i8":U()[h>>>0]=M;break;case"i16":Q()[h>>>1>>>0]=M;break;case"i32":re()[h>>>2>>>0]=M;break;case"i64":ne[h>>>3]=BigInt(M);break;case"float":Se()[h>>>2>>>0]=M;break;case"double":Be()[h>>>3>>>0]=M;break;case"*":ve()[h>>>2>>>0]=M;break;default:We(`invalid type for setValue: ${$}`)}},o.getValue=function(h,M="i8"){switch(M.endsWith("*")&&(M="*"),M){case"i1":case"i8":return U()[h>>>0];case"i16":return Q()[h>>>1>>>0];case"i32":return re()[h>>>2>>>0];case"i64":return ne[h>>>3];case"float":return Se()[h>>>2>>>0];case"double":return Be()[h>>>3>>>0];case"*":return ve()[h>>>2>>>0];default:We(`invalid type for getValue: ${M}`)}},o.UTF8ToString=_n,o.stringToUTF8=rr,o.lengthBytesUTF8=Fr,function h(){if(0<Ve)Ue=h;else if(f)i(o),Z();else{for(;0<pe.length;)pe.shift()(o);0<Ve?Ue=h:(o.calledRun=!0,ge||(Z(),i(o)))}}(),o.PTR_SIZE=4,c}),Zv=Sm,qg=(s=(t=globalThis.self)==null?void 0:t.name)==null?void 0:s.startsWith("em-pthread"),qg&&Sm()}),Cm,g_,Qg,ha,Jv,Sh,Xg,Yg,Pm,Zg,Am,ew,$m,tw,L_=ot(()=>{F_(),Cm=typeof location>"u"?void 0:location.origin,g_=import.meta.url>"file:"&&import.meta.url<"file;",Qg=()=>{{if(g_){let t=URL;return new URL(new t("ort.bundle.min.mjs",import.meta.url).href,Cm).href}return import.meta.url}},ha=Qg(),Jv=()=>{if(ha&&!ha.startsWith("blob:"))return ha.substring(0,ha.lastIndexOf("/")+1)},Sh=(t,s)=>{try{let n=s??ha;return(n?new URL(t,n):new URL(t)).origin===Cm}catch{return!1}},Xg=(t,s)=>{let n=s??ha;try{return(n?new URL(t,n):new URL(t)).href}catch{return}},Yg=(t,s)=>`${s??"./"}${t}`,Pm=async t=>{let s=await(await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(s)},Zg=async t=>(await import(t)).default,Am=(Rx(),Vh(Qv)).default,ew=async()=>{if(!ha)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Sh(ha))return[void 0,Am()];let t=await Pm(ha);return[t,Am(t)]},$m=(Nx(),Vh(Yv)).default,tw=async(t,s,n)=>{if(!t&&!s&&$m&&ha&&Sh(ha))return[void 0,$m];{let i="ort-wasm-simd-threaded.jsep.mjs",l=t??Xg(i,s),o=n&&l&&!Sh(l,s),c=o?await Pm(l):l??Yg(i,s);return[o?c:void 0,await Zg(c)]}}}),Om,Ch,Ap,km,Jg,ey,B_,Ir,xc=ot(()=>{L_(),Ch=!1,Ap=!1,km=!1,Jg=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},ey=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},B_=async t=>{if(Ch)return Promise.resolve();if(Ap)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(km)throw new Error("previous call to 'initializeWebAssembly()' failed.");Ap=!0;let s=t.initTimeout,n=t.numThreads;if(!ey())throw new Error("WebAssembly SIMD is not supported in the current environment.");let i=Jg();n>1&&!i&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=n=1);let l=t.wasmPaths,o=typeof l=="string"?l:void 0,c=l==null?void 0:l.mjs,p=(c==null?void 0:c.href)??c,d=l==null?void 0:l.wasm,f=(d==null?void 0:d.href)??d,g=t.wasmBinary,[_,y]=await tw(p,o,n>1),T=!1,b=[];if(s>0&&b.push(new Promise(k=>{setTimeout(()=>{T=!0,k()},s)})),b.push(new Promise((k,L)=>{let C={numThreads:n};if(g)C.wasmBinary=g;else if(f||o)C.locateFile=S=>f??o+S;else if(p&&p.indexOf("blob:")!==0)C.locateFile=S=>new URL(S,p).href;else if(_){let S=Jv();S&&(C.locateFile=I=>S+I)}y(C).then(S=>{Ap=!1,Ch=!0,Om=S,k(),_&&URL.revokeObjectURL(_)},S=>{Ap=!1,km=!0,L(S)})})),await Promise.race(b),T)throw new Error(`WebAssembly backend initializing failed due to timeout: ${s}ms`)},Ir=()=>{if(Ch&&Om)return Om;throw new Error("WebAssembly is not initialized yet.")}}),ss,Gh,vn,R_=ot(()=>{xc(),ss=(t,s)=>{let n=Ir(),i=n.lengthBytesUTF8(t)+1,l=n._malloc(i);return n.stringToUTF8(t,l,i),s.push(l),l},Gh=(t,s,n,i)=>{if(typeof t=="object"&&t!==null){if(n.has(t))throw new Error("Circular reference in options");n.add(t)}Object.entries(t).forEach(([l,o])=>{let c=s?s+l:l;if(typeof o=="object")Gh(o,c+".",n,i);else if(typeof o=="string"||typeof o=="number")i(c,o.toString());else if(typeof o=="boolean")i(c,o?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof o}`)})},vn=t=>{let s=Ir(),n=s.stackSave();try{let i=s.PTR_SIZE,l=s.stackAlloc(2*i);s._OrtGetLastError(l,l+i);let o=Number(s.getValue(l,i===4?"i32":"i64")),c=s.getValue(l+i,"*"),p=c?s.UTF8ToString(c):"";throw new Error(`${t} ERROR_CODE: ${o}, ERROR_MESSAGE: ${p}`)}finally{s.stackRestore(n)}}}),nw,jx=ot(()=>{xc(),R_(),nw=t=>{let s=Ir(),n=0,i=[],l=t||{};try{if((t==null?void 0:t.logSeverityLevel)===void 0)l.logSeverityLevel=2;else if(typeof t.logSeverityLevel!="number"||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if((t==null?void 0:t.logVerbosityLevel)===void 0)l.logVerbosityLevel=0;else if(typeof t.logVerbosityLevel!="number"||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);(t==null?void 0:t.terminate)===void 0&&(l.terminate=!1);let o=0;return(t==null?void 0:t.tag)!==void 0&&(o=ss(t.tag,i)),n=s._OrtCreateRunOptions(l.logSeverityLevel,l.logVerbosityLevel,!!l.terminate,o),n===0&&vn("Can't create run options."),(t==null?void 0:t.extra)!==void 0&&Gh(t.extra,"",new WeakSet,(c,p)=>{let d=ss(c,i),f=ss(p,i);s._OrtAddRunConfigEntry(n,d,f)!==0&&vn(`Can't set a run config entry: ${c} - ${p}.`)}),[n,i]}catch(o){throw n!==0&&s._OrtReleaseRunOptions(n),i.forEach(c=>s._free(c)),o}}}),ty,ny,ry,sy,rw,Ux=ot(()=>{xc(),R_(),ty=t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}},ny=t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}},ry=t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});let s=t.extra.session;s.use_ort_model_bytes_directly||(s.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(n=>(typeof n=="string"?n:n.name)==="webgpu")&&(t.enableMemPattern=!1)},sy=(t,s,n)=>{for(let i of s){let l=typeof i=="string"?i:i.name;switch(l){case"webnn":if(l="WEBNN",typeof i!="string"){let c=i==null?void 0:i.deviceType;if(c){let p=ss("deviceType",n),d=ss(c,n);Ir()._OrtAddSessionConfigEntry(t,p,d)!==0&&vn(`Can't set a session config entry: 'deviceType' - ${c}.`)}}break;case"webgpu":if(l="JS",typeof i!="string"){let c=i;if(c!=null&&c.preferredLayout){if(c.preferredLayout!=="NCHW"&&c.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${c.preferredLayout}`);let p=ss("preferredLayout",n),d=ss(c.preferredLayout,n);Ir()._OrtAddSessionConfigEntry(t,p,d)!==0&&vn(`Can't set a session config entry: 'preferredLayout' - ${c.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${l}`)}let o=ss(l,n);Ir()._OrtAppendExecutionProvider(t,o)!==0&&vn(`Can't append execution provider: ${l}.`)}},rw=t=>{let s=Ir(),n=0,i=[],l=t||{};ry(l);try{let o=ty(l.graphOptimizationLevel??"all"),c=ny(l.executionMode??"sequential"),p=typeof l.logId=="string"?ss(l.logId,i):0,d=l.logSeverityLevel??2;if(!Number.isInteger(d)||d<0||d>4)throw new Error(`log serverity level is not valid: ${d}`);let f=l.logVerbosityLevel??0;if(!Number.isInteger(f)||f<0||f>4)throw new Error(`log verbosity level is not valid: ${f}`);let g=typeof l.optimizedModelFilePath=="string"?ss(l.optimizedModelFilePath,i):0;if(n=s._OrtCreateSessionOptions(o,!!l.enableCpuMemArena,!!l.enableMemPattern,c,!!l.enableProfiling,0,p,d,f,g),n===0&&vn("Can't create session options."),l.executionProviders&&sy(n,l.executionProviders,i),l.enableGraphCapture!==void 0){if(typeof l.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${l.enableGraphCapture}`);let _=ss("enableGraphCapture",i),y=ss(l.enableGraphCapture.toString(),i);s._OrtAddSessionConfigEntry(n,_,y)!==0&&vn(`Can't set a session config entry: 'enableGraphCapture' - ${l.enableGraphCapture}.`)}if(l.freeDimensionOverrides)for(let[_,y]of Object.entries(l.freeDimensionOverrides)){if(typeof _!="string")throw new Error(`free dimension override name must be a string: ${_}`);if(typeof y!="number"||!Number.isInteger(y)||y<0)throw new Error(`free dimension override value must be a non-negative integer: ${y}`);let T=ss(_,i);s._OrtAddFreeDimensionOverride(n,T,y)!==0&&vn(`Can't set a free dimension override: ${_} - ${y}.`)}return l.extra!==void 0&&Gh(l.extra,"",new WeakSet,(_,y)=>{let T=ss(_,i),b=ss(y,i);s._OrtAddSessionConfigEntry(n,T,b)!==0&&vn(`Can't set a session config entry: ${_} - ${y}.`)}),[n,i]}catch(o){throw n!==0&&s._OrtReleaseSessionOptions(n)!==0&&vn("Can't release session options."),i.forEach(c=>s._free(c)),o}}}),jd,yc,Mc,N_,Wh,j_,U_,y_,Bt=ot(()=>{jd=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${t}`)}},yc=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${t}`)}},Mc=(t,s)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],i=typeof s=="number"?s:s.reduce((l,o)=>l*o,1);return n>0?Math.ceil(i*n):void 0},N_=t=>{switch(t){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}},Wh=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${t}`)}},j_=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",U_=t=>t==="float32"||t==="float16"||t==="int32"||t==="int64"||t==="uint32"||t==="uint64"||t==="int8"||t==="uint8"||t==="bool"||t==="uint4"||t==="int4",y_=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${t}`)}}}),V_,sw=ot(()=>{F_(),V_=async t=>{if(typeof t=="string"){let s=await fetch(t);if(!s.ok)throw new Error(`failed to load external data file: ${t}`);let n=s.headers.get("Content-Length"),i=n?parseInt(n,10):0;if(i<1073741824)return new Uint8Array(await s.arrayBuffer());{if(!s.body)throw new Error(`failed to load external data file: ${t}, no response body.`);let l=s.body.getReader(),o;try{o=new ArrayBuffer(i)}catch(p){if(p instanceof RangeError){let d=Math.ceil(i/65536);o=new WebAssembly.Memory({initial:d,maximum:d}).buffer}else throw p}let c=0;for(;;){let{done:p,value:d}=await l.read();if(p)break;let f=d.byteLength;new Uint8Array(o,c,f).set(d),c+=f}return new Uint8Array(o,0,i)}}else return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t)}}),ay,iy,oy,ly,G_,uy,dn,qo=ot(()=>{Bt(),ay=["V","I","W","E","F"],iy=(t,s)=>{console.log(`[${ay[t]},${new Date().toISOString()}]${s}`)},G_=(t,s)=>{oy=t,ly=s},uy=(t,s)=>{let n=Wh(t),i=Wh(oy);n>=i&&iy(n,typeof s=="function"?s():s)},dn=(...t)=>{ly&&uy(...t)}}),W_,aw=ot(()=>{Bt(),W_=(t,s)=>new(N_(s))(t)}),H_=ot(()=>{}),Dm,Ph,Ah,cy,dy,Im,M_,fy,iw,Vx=ot(()=>{qo(),H_(),Dm=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),Ph=[],Ah=t=>Math.ceil(Number(t)/16)*16,cy=t=>{for(let s=0;s<Ph.length;s++){let n=Ph[s];if(t<=n)return n}return Math.ceil(t/16)*16},dy=1,Im=()=>dy++,M_=async(t,s,n,i)=>{let l=Ah(n),o=t.device.createBuffer({size:l,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let c=t.getCommandEncoder();t.endComputePass(),c.copyBufferToBuffer(s,0,o,0,l),t.flush(),await o.mapAsync(GPUMapMode.READ);let p=o.getMappedRange();if(i){let d=i();return d.set(new Uint8Array(p,0,n)),d}else return new Uint8Array(p.slice(0,n))}finally{o.destroy()}},fy=class{constructor(t){this.backend=t,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[s]of Dm)Ph.push(s),this.freeBuffers.set(s,[]),this.freeUniformBuffers.set(s,[]);this.sessionCount=0}upload(t,s){let n=s.buffer,i=s.byteOffset,l=s.byteLength,o=Ah(l),c=this.storageCache.get(t);if(!c)throw new Error("gpu data for uploading does not exist");if(Number(c.originalSize)!==l)throw new Error(`inconsistent data size. gpu data size=${c.originalSize}, data size=${l}`);let p=this.backend.device.createBuffer({mappedAtCreation:!0,size:o,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),d=p.getMappedRange();new Uint8Array(d).set(new Uint8Array(n,i,l)),p.unmap();let f=this.backend.device.createCommandEncoder();f.copyBufferToBuffer(p,0,c.gpuData.buffer,0,o),this.backend.device.queue.submit([f.finish()]),p.destroy(),dn("verbose",()=>`[WebGPU] GpuDataManager.upload(id=${t})`)}memcpy(t,s){let n=this.storageCache.get(t);if(!n)throw new Error("source gpu data for memcpy does not exist");let i=this.storageCache.get(s);if(!i)throw new Error("destination gpu data for memcpy does not exist");if(n.originalSize!==i.originalSize)throw new Error("inconsistent source and destination gpu data size");let l=Ah(n.originalSize),o=this.backend.getCommandEncoder();this.backend.endComputePass(),o.copyBufferToBuffer(n.gpuData.buffer,0,i.gpuData.buffer,0,l)}registerExternalBuffer(t,s,n){let i;if(n){if(i=n[0],t===n[1])return dn("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${s}) => id=${i}, buffer is the same, skip.`),i;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.
             Please use the previous external buffer!`)}else i=Im();return this.storageCache.set(i,{gpuData:{id:i,type:0,buffer:t},originalSize:s}),dn("verbose",()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${s}) => id=${i}, registered.`),i}unregisterExternalBuffer(t){t!==void 0&&(this.storageCache.delete(t),dn("verbose",()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`))}create(t,s=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let n=cy(t),i,l=(s&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,o=(s&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(l||o){let p=(l?this.freeBuffers:this.freeUniformBuffers).get(n);p?p.length>0?i=p.pop():i=this.backend.device.createBuffer({size:n,usage:s}):i=this.backend.device.createBuffer({size:n,usage:s})}else i=this.backend.device.createBuffer({size:n,usage:s});let c={id:Im(),type:0,buffer:i};return this.storageCache.set(c.id,{gpuData:c,originalSize:Number(t)}),dn("verbose",()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${c.id}`),c}get(t){var s;return(s=this.storageCache.get(t))==null?void 0:s.gpuData}release(t){let s=typeof t=="bigint"?Number(t):t,n=this.storageCache.get(s);if(!n){if(this.storageCache.size===0)return 0;throw new Error("releasing data does not exist")}return dn("verbose",()=>`[WebGPU] GpuDataManager.release(id=${s}), gpuDataId=${n.gpuData.id}`),this.storageCache.delete(s),this.buffersPending.push(n.gpuData.buffer),n.originalSize}async download(t,s){let n=this.storageCache.get(Number(t));if(!n)throw new Error("data does not exist");await M_(this.backend,n.gpuData.buffer,n.originalSize,s)}refreshPendingBuffers(){if(this.buffersPending.length!==0)if(this.backend.sessionStatus==="default"){for(let t of this.buffersPending){let s=Dm.get(t.size);if((t.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let n=this.freeBuffers.get(t.size)||[];s===void 0||n.length>=s?t.destroy():n.push(t)}else if((t.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let n=this.freeUniformBuffers.get(t.size)||[];s===void 0||n.length>=s?t.destroy():n.push(t)}else t.destroy()}this.buffersPending=[]}else{let t=this.capturedPendingBuffers.get(this.backend.currentSessionId);t||(t=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,t));for(let s of this.buffersPending)t.push(s);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach(t=>{t.forEach(s=>{s.destroy()})}),this.freeUniformBuffers.forEach(t=>{t.forEach(s=>{s.destroy()})}),this.storageCache.forEach(t=>{t.gpuData.buffer.destroy()}),this.capturedPendingBuffers.forEach(t=>{t.forEach(s=>{s.destroy()})}),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(t){let s=this.capturedPendingBuffers.get(t);s&&(s.forEach(n=>{n.destroy()}),this.capturedPendingBuffers.delete(t)),this.sessionCount-=1,this.sessionCount===0&&(dn("warning",()=>"[WebGPU] Clearing webgpu buffer cache"),this.storageCache.forEach(n=>{n.gpuData.buffer.destroy()}),this.storageCache=new Map)}},iw=(...t)=>new fy(...t)}),py,An,or=ot(()=>{py=class{constructor(t){Object.assign(this,t)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(t=>`${this[t]}`).join(";")),this.key}},An=t=>new py(t)}),hy,Gd,Ne,Hh,ow,lw,uw,qt=ot(()=>{hy=class{static calcMatMulShape(t,s){return t[1]!==s[0]?void 0:[t[0],s[1]]}},Gd=class{static calcShape(t,s,n=!1){let i=t.length,l=s.length;if(i===0)return s;if(l===0)return t;let o=Math.max(t.length,s.length),c=new Array(o);if(n){if(i<2||l<2)return;let p=hy.calcMatMulShape([t[i-2],t[i-1]],[s[l-2],s[l-1]]);if(p===void 0)return;[c[o-2],c[o-1]]=p}for(let p=n?3:1;p<=o;p++){let d=i-p<0?1:t[i-p],f=l-p<0?1:s[l-p];if(d!==f&&d>1&&f>1)return;let g=Math.max(d,f);if(d&&f)c[o-p]=Math.max(d,f);else{if(g>1)return;c[o-p]=0}}return c}static isValidBroadcast(t,s){let n=t.length,i=s.length;if(n>i)return!1;for(let l=1;l<=n;l++)if(t[n-l]!==1&&t[n-l]!==s[i-l])return!1;return!0}},Ne=class jh{static size(s){return jh.getSizeFromDimensionRange(s,0,s.length)}static convertShape(s,n=4){let i=s.length;if(i===0)return[];let l=new Array(i),o=i-1;for(;o>=0;){if(s[o]%n===0){l[o]=s[o]/n;break}if(n%s[o]!==0)throw new Error("cannot convert shape");l[o]=1,n/=s[o],o--}for(o--;o>=0;o--)l[o]=s[o];return l}static sizeFromDimension(s,n){if(n<0||n>s.length)throw new Error(`invalid dimension of ${n} for sizeFromDimension as Tensor has ${s.length} dimensions.`);return jh.getSizeFromDimensionRange(s,n,s.length)}static sizeToDimension(s,n){if(n<0||n>s.length)throw new Error(`invalid dimension of ${n} for sizeToDimension as Tensor has ${s.length} dimensions.`);return jh.getSizeFromDimensionRange(s,0,n)}static getSizeFromDimensionRange(s,n,i){let l=1;for(let o=n;o<i;o++){if(s[o]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");l*=Number(s[o])}return l}static computeStrides(s){let n=s.length;if(n===0)return[];if(n===1)return[1];let i=new Array(n);i[n-1]=1,i[n-2]=s[n-1];for(let l=n-3;l>=0;--l)i[l]=i[l+1]*s[l+1];return i}static normalizeAxis(s,n){if(s<-n&&s>=n)throw new Error("unsupported axis for this operation.");return s<0?s+n:s}static normalizeAxes(s,n){return s.map(i=>this.normalizeAxis(i,n??s.length))}static sortBasedOnPerm(s,n){return n?n.map(i=>s[i]):s.slice().reverse()}static padShape(s,n){let i=s.length;return s.map((l,o)=>l+n[o]+n[o+i])}static areEqual(s,n){return s.length!==n.length?!1:s.every((i,l)=>i===n[l])}},Hh=class Bp{static adjustPoolAttributes(s,n,i,l,o,c){if(!s&&i.length!==n.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(s)for(let p=0;p<n.length-2;p++)p>=i.length?i.push(n[p+2]):i[p]=n[p+2];for(let p=0;p<i.length;p++)if(p<l.length){if(l[p]<0)throw new Error("strides should be greater than or equal to 1")}else l.push(1);for(let p=0;p<i.length;p++)if(p<o.length){if(o[p]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let p=0;p<i.length*2;p++)if(p<c.length){if(c[p]<0)throw new Error("pad should be greater than or equal to 1")}else c.push(0);for(let p=0;p<i.length;p++){if(i[p]<=0)throw new Error("kernel shapes need to be greater than 0");if(c[p]>=i[p]||c[p+i.length]>=i[p])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(s,n,i,l,o,c,p){if(p){if(o.length!==2*(s.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(n.length!==s.length-2)throw new Error("length of strides should be the length of data dimensions");if(l.length!==s.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let d=0;d<s.length-2;d++)Bp.adjustPadAndReturnShape(s[d+(c?1:2)],n[d],i[d],l[d],o,d,d+s.length-2,p)}}static computePoolOutputShape(s,n,i,l,o,c,p){if(n.length<=0)throw new Error("input shape must be of size greater than 0");let d=[n[0],n[1]];return Bp.computeShapeHelper(s,n,d,i,l,o,c,p),d}static computeConvOutputShape(s,n,i,l,o,c,p){if(s.length<=0||n.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let d=[s[0],n[0]];return Bp.computeShapeHelper(!1,s,d,i,l,o,c,p),d}static computeShapeHelper(s,n,i,l,o,c,p,d){if(s)for(let f=0;f<n.length-2;f++)i.push(1);else for(let f=0;f<n.length-2;f++)i.push(Bp.adjustPadAndReturnShape(n[f+2],l[f],o[f],c[f],p,f,f+n.length-2,d))}static adjustPadAndReturnShape(s,n,i,l,o,c,p,d){let f=i*(l-1)+1;if(d&&d!=="NOTSET")switch(d){case"VALID":return o[c]=0,o[p]=0,Math.floor((s-f)/n+1);case"SAME_LOWER":case"SAME_UPPER":if(i!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let g=((s+n-1)/n-1)*n+l-s;return o[c]=Math.floor(d==="SAME_LOWER"?(g+1)/2:g/2),o[p]=g-o[c],Math.floor((s+g-l)/n+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((s+o[c]+o[p]-f)/n+1)}},ow=class{static getShapeOfGemmResult(t,s,n,i,l){if(t.length!==2||n.length!==2)throw new Error("shape need to be of size 2");let o,c,p;s?(o=t[1],c=t[0]):(o=t[0],c=t[1]);let d=-1;if(i?(p=n[0],d=1):(p=n[1],d=0),n[d]!==c)throw new Error("dimension mismatch");if(o<=0||p<=0||c<=0)throw new Error("invalid shape specified");if(l&&!Gd.isValidBroadcast(l,[o,p]))throw new Error("gemm: invalid bias shape for broadcast");return[o,p,c]}},lw=-34028234663852886e22,uw=34028234663852886e22}),Wd,$h,zr,hs,Ct,nr,v_,Vd,su,xt,$p,Ke,Tt,cw,K_,my,dw,Xt=ot(()=>{Bt(),qt(),Wd=64,$h=(t,s)=>{if(s===3)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(t)){case 10:return s>1?`vec${s}<f16>`:"f16";case 1:return s>1?`vec${s}<f32>`:"f32";case 6:return s>1?`vec${s}<i32>`:"i32";case 12:return s>1?`vec${s}<u32>`:"u32";case 7:if(s>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(s>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(s!==4)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${t}`)}},zr=(t,s=1)=>{let n=$h(t,s);return typeof n=="string"?n:n[0]},hs=(t,s=1)=>{let n=$h(t,s);return typeof n=="string"?n:n[1]},Ct=(...t)=>{let s=[];return t.forEach(n=>{n.length!==0&&s.push({type:12,data:n},{type:12,data:Ne.computeStrides(n)})}),s},nr=t=>t%4===0?4:t%2===0?2:1,v_=(t="f32",s,n="0")=>!s||s===1?`${t}(${n})`:`vec${s}<${t}>(${n})`,Vd=(t,s,n)=>t==="f32"?n:s===1?`f32(${n})`:`vec${s}<f32>(${n})`,su=(t,s)=>s===4?`(${t}.x + ${t}.y + ${t}.z + ${t}.w)`:s===2?`(${t}.x + ${t}.y)`:s===3?`(${t}.x + ${t}.y + ${t}.z)`:t,xt=(t,s,n,i)=>t.startsWith("uniforms.")&&n>4?typeof s=="string"?i==="f16"?`${t}[(${s}) / 8][(${s}) % 8 / 4][(${s}) % 8 % 4]`:`${t}[(${s}) / 4][(${s}) % 4]`:i==="f16"?`${t}[${Math.floor(s/8)}][${Math.floor(s%8/4)}][${s%8%4}]`:`${t}[${Math.floor(s/4)}][${s%4}]`:n>1?`${t}[${s}]`:t,$p=(t,s,n,i,l)=>{let o=typeof n=="number",c=o?n:n.length,p=[...new Array(c).keys()],d=c<2?"u32":c<=4?`vec${c}<u32>`:`array<u32, ${c}>`,f=$h(s,l),g=typeof f=="string"?f:f[1],_=typeof f=="string"?f:f[0],y={indices:d,value:g,storage:_,tensor:s},T=U=>typeof U=="string"?U:`${U}u`,b={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},k=o?"uniforms.":"",L=`${k}${t}_shape`,C=`${k}${t}_strides`,S="";for(let U=0;U<c-1;U++)S+=`
    let dim${U} = current / ${xt(C,U,c)};
    let rest${U} = current % ${xt(C,U,c)};
    indices[${U}] = dim${U};
    current = rest${U};
    `;S+=`indices[${c-1}] = current;`;let I=c<2?"":`
  fn o2i_${t}(offset: u32) -> ${y.indices} {
    var indices: ${y.indices};
    var current = offset;
    ${S}
    return indices;
  }`,O=U=>(b.offsetToIndices=!0,c<2?U:`o2i_${t}(${U})`),x=[];if(c>=2)for(let U=c-1;U>=0;U--)x.push(`${xt(C,U,c)} * (indices[${U}])`);let E=c<2?"":`
  fn i2o_${t}(indices: ${y.indices}) -> u32 {
    return ${x.join("+")};
  }`,A=U=>(b.indicesToOffset=!0,c<2?U:`i2o_${t}(${U})`),F=(...U)=>c===0?"0u":`${y.indices}(${U.map(T).join(",")})`,K=(U,B)=>c<2?`${U}`:`${xt(U,B,c)}`,X=(U,B,Q)=>c<2?`${U}=${Q};`:`${xt(U,B,c)}=${Q};`,oe={},ie=(U,B)=>{b.broadcastedIndicesToOffset=!0;let Q=`${B.name}broadcastedIndicesTo${t}Offset`;if(Q in oe)return`${Q}(${U})`;let le=[];for(let re=c-1;re>=0;re--){let ve=B.indicesGet("outputIndices",re+B.rank-c);le.push(`${K(C,re)} * (${ve} % ${K(L,re)})`)}return oe[Q]=`fn ${Q}(outputIndices: ${B.type.indices}) -> u32 {
             return ${le.length>0?le.join("+"):"0u"};
           }`,`${Q}(${U})`},J=(U,B)=>(()=>{if(y.storage===y.value)return`${t}[${U}]=${B};`;if(y.storage==="vec2<u32>"&&y.value==="i32")return`${t}[${U}]=vec2<u32>(u32(${B}), select(0u, 0xFFFFFFFFu, ${B} < 0));`;if(y.storage==="vec2<u32>"&&y.value==="u32")return`${t}[${U}]=vec2<u32>(u32(${B}), 0u);`;if(y.storage==="u32"&&y.value==="vec4<bool>")return`${t}[${U}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${B}));`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),ue=U=>(()=>{if(y.storage===y.value)return`${t}[${U}]`;if(y.storage==="vec2<u32>"&&y.value==="i32")return`i32(${t}[${U}].x)`;if(y.storage==="vec2<u32>"&&y.value==="u32")return`u32(${t}[${U}].x)`;if(y.storage==="u32"&&y.value==="vec4<bool>")return`vec4<bool>(bool(${t}[${U}] & 0xFFu), bool(${t}[${U}] & 0xFF00u), bool(${t}[${U}] & 0xFF0000u), bool(${t}[${U}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${y.storage} and value type ${y.value} yet`)})(),ne=c<2?"":`
  fn get_${t}ByIndices(indices: ${y.indices}) -> ${g} {
    return ${ue(`i2o_${t}(indices)`)};
  }`,G=c<2?"":(()=>{let U=p.map(Q=>`d${Q}: u32`).join(", "),B=p.map(Q=>`d${Q}`).join(", ");return`
  fn get_${t}(${U}) -> ${g} {
    return get_${t}ByIndices(${F(B)});
  }`})(),se=(...U)=>{if(U.length!==c)throw new Error(`indices length must be ${c}`);let B=U.map(T).join(",");return c===0?ue("0u"):c===1?ue(B[0]):(b.get=!0,b.getByIndices=!0,b.indicesToOffset=!0,`get_${t}(${B})`)},ce=U=>c<2?ue(U):(b.getByIndices=!0,b.indicesToOffset=!0,`get_${t}ByIndices(${U})`),ge=c<2?"":`
  fn set_${t}ByIndices(indices: ${y.indices}, value: ${g}) {
    ${J(`i2o_${t}(indices)`,"value")}
  }`,W=c<2?"":(()=>{let U=p.map(Q=>`d${Q}: u32`).join(", "),B=p.map(Q=>`d${Q}`).join(", ");return`
  fn set_${t}(${U}, value: ${g}) {
    set_${t}ByIndices(${F(B)}, value);
  }`})();return{impl:()=>{let U=[],B=!1;return b.offsetToIndices&&(U.push(I),B=!0),b.indicesToOffset&&(U.push(E),B=!0),b.broadcastedIndicesToOffset&&(Object.values(oe).forEach(Q=>U.push(Q)),B=!0),b.set&&(U.push(W),B=!0),b.setByIndices&&(U.push(ge),B=!0),b.get&&(U.push(G),B=!0),b.getByIndices&&(U.push(ne),B=!0),!o&&B&&U.unshift(`const ${L} = ${y.indices}(${n.join(",")});`,`const ${C} = ${y.indices}(${Ne.computeStrides(n).join(",")});`),U.join(`
`)},type:y,offsetToIndices:O,indicesToOffset:A,broadcastedIndicesToOffset:ie,indices:F,indicesGet:K,indicesSet:X,set:(...U)=>{if(U.length!==c+1)throw new Error(`indices length must be ${c}`);let B=U[c];if(typeof B!="string")throw new Error("value must be string");let Q=U.slice(0,c).map(T).join(",");return c===0?J("0u",B):c===1?J(Q[0],B):(b.set=!0,b.setByIndices=!0,b.indicesToOffset=!0,`set_${t}(${Q}, ${B})`)},setByOffset:J,setByIndices:(U,B)=>c<2?J(U,B):(b.setByIndices=!0,b.indicesToOffset=!0,`set_${t}ByIndices(${U}, ${B});`),get:se,getByOffset:ue,getByIndices:ce,usage:i,name:t,strides:C,shape:L,rank:c}},Ke=(t,s,n,i=1)=>$p(t,s,n,"input",i),Tt=(t,s,n,i=1)=>$p(t,s,n,"output",i),cw=(t,s,n)=>$p(t,s,n,"atomicOutput",1),K_=(t,s,n,i=1)=>$p(t,s,n,"internal",i),my=class{constructor(t,s){this.normalizedDispatchGroup=t,this.limits=s,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(t){return`if (global_idx >= ${typeof t=="number"?`${t}u`:t}) { return; }`}mainStart(t=Wd){let s=typeof t=="number"?t:t[0],n=typeof t=="number"?1:t[1],i=typeof t=="number"?1:t[2];if(s>this.limits.maxComputeWorkgroupSizeX||n>this.limits.maxComputeWorkgroupSizeY||i>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${s}, ${n}, ${i}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(s*n*i>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${s}, ${n}, ${i}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let l=this.normalizedDispatchGroup[1]===1&&this.normalizedDispatchGroup[2]===1,o=l?`@builtin(global_invocation_id) global_id : vec3<u32>,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(local_invocation_id) local_id : vec3<u32>`:`@builtin(global_invocation_id) global_id : vec3<u32>,
                                             @builtin(local_invocation_id) local_id : vec3<u32>,
    @builtin(local_invocation_index) local_idx : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>,
    @builtin(num_workgroups) num_workgroups : vec3<u32>`,c=l?`let global_idx = global_id.x;
         let workgroup_index = workgroup_id.x;`:`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +
             workgroup_id.y * num_workgroups[0] + workgroup_id.x;
         let global_idx = workgroup_index * ${s*n*i}u + local_idx;`;return`@compute @workgroup_size(${s}, ${n}, ${i})
  fn main(${o}) {
    ${c}
  `}appendVariableUniforms(t){t.rank!==0&&(t.shape.startsWith("uniforms.")&&this.uniforms.push({name:t.shape.replace("uniforms.",""),type:"u32",length:t.rank}),t.strides.startsWith("uniforms.")&&this.uniforms.push({name:t.strides.replace("uniforms.",""),type:"u32",length:t.rank}))}declareVariable(t,s){if(t.usage==="internal")throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(t),this.appendVariableUniforms(t);let n=t.usage==="input"?"read":"read_write",i=t.usage==="atomicOutput"?"atomic<i32>":t.type.storage;return`@group(0) @binding(${s}) var<storage, ${n}> ${t.name}: array<${i}>;`}declareVariables(...t){return t.map(s=>this.declareVariable(s,this.variableIndex++)).join(`
`)}registerInternalVariable(t){if(t.usage!=="internal")throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(t),this.appendVariableUniforms(t)}registerInternalVariables(...t){return t.forEach(s=>this.registerInternalVariable(s)),this}registerUniform(t,s,n=1){return this.uniforms.push({name:t,type:s,length:n}),this}registerUniforms(t){return this.uniforms=this.uniforms.concat(t),this}uniformDeclaration(){if(this.uniforms.length===0)return"";let t=[];for(let{name:s,type:n,length:i}of this.uniforms)if(i&&i>4)n==="f16"?t.push(`@align(16) ${s}:array<mat2x4<${n}>, ${Math.ceil(i/8)}>`):t.push(`${s}:array<vec4<${n}>, ${Math.ceil(i/4)}>`);else{let l=i==null||i===1?n:`vec${i}<${n}>`;t.push(`${s}:${l}`)}return`
      struct Uniforms { ${t.join(", ")} };
      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map(t=>t.impl()).join(`
`)+this.internalVariables.map(t=>t.impl()).join(`
`)}get variablesInfo(){if(this.uniforms.length===0)return;let t=s=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(s)];return this.uniforms.map(s=>[t(s.type),s.length??1])}},dw=(t,s)=>new my(t,s)}),_y,zm,gy,yy,My,vy,_a,fw,pw,au=ot(()=>{Bt(),qt(),or(),Xt(),_y=(t,s)=>{if(!t||t.length!==1)throw new Error("Transpose requires 1 input.");if(s.length!==0&&s.length!==t[0].dims.length)throw new Error(`perm size ${s.length} does not match input rank ${t[0].dims.length}`)},zm=(t,s)=>s.length!==0?s:[...new Array(t).keys()].reverse(),gy=(t,s)=>Ne.sortBasedOnPerm(t,zm(t.length,s)),yy=(t,s,n,i)=>{let l=`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`;for(let o=0;o<s;++o)l+=`a[${t[o]}]=i[${o}];`;return l+="return a;}"},My=(t,s)=>{let n=[],i=[];for(let l=0;l<t.length;++l)t[l]!==1&&n.push(t[l]),t[s[l]]!==1&&i.push(s[l]);return{newShape:n,newPerm:i}},vy=(t,s)=>{let n=0;for(let i=0;i<t.length;++i)if(s[t[i]]!==1){if(t[i]<n)return!1;n=t[i]}return!0},_a=(t,s)=>{let n=t.dataType,i=t.dims.length,l=zm(i,s),o=gy(t.dims,l),c=t.dims,p=o,d=i<2||vy(l,t.dims),f;if(d)return f=b=>{let k=Ke("input",n,c,4),L=Tt("output",n,p,4);return`
  ${b.registerUniform("output_size","u32").declareVariables(k,L)}
  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    output[global_idx] = input[global_idx];
  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let b=Ne.size(o);return{outputs:[{dims:o,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(b/64/4)},programUniforms:[{type:12,data:Math.ceil(b/4)}]}},getShaderSource:f};let{newShape:g,newPerm:_}=My(t.dims,l),y=Ne.areEqual(_,[2,3,1]),T=Ne.areEqual(_,[3,1,2]);if(g.length===2||y||T){c=y?[g[0],g[1]*g[2]]:T?[g[0]*g[1],g[2]]:g,p=[c[1],c[0]];let b=16;return f=k=>{let L=Ke("a",n,c.length),C=Tt("output",n,p.length);return`
  ${k.registerUniform("output_size","u32").declareVariables(L,C)}
  var<workgroup> tile : array<array<${C.type.value}, ${b+1}>, ${b}>;
  ${k.mainStart([b,b,1])}
    let stride = (uniforms.output_shape[1] - 1) / ${b} + 1;
    let workgroup_id_x = workgroup_index % stride;
    let workgroup_id_y = workgroup_index / stride;
    let input_col = workgroup_id_y * ${b}u + local_id.x;
    let input_row = workgroup_id_x * ${b}u + local_id.y;
    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {
      tile[local_id.y][local_id.x] = ${L.getByIndices(`${L.type.indices}(input_row, input_col)`)};
    }
    workgroupBarrier();

    let output_col = workgroup_id_x * ${b}u + local_id.x;
    let output_row = workgroup_id_y * ${b}u + local_id.y;
    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {
      ${C.setByIndices(`${C.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}
    }
  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let k=Ne.size(o);return{outputs:[{dims:o,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(p[1]/b),y:Math.ceil(p[0]/b)},programUniforms:[{type:12,data:k},...Ct(c,p)]}},getShaderSource:f}}return f=b=>{let k=Ke("a",n,c.length),L=Tt("output",n,p.length);return`
  ${b.registerUniform("output_size","u32").declareVariables(k,L)}

  ${yy(l,i,k,L)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${L.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${L.setByOffset("global_idx",k.getByIndices("aIndices"))}
  }`},{name:"Transpose",shaderCache:{hint:`${s}`,inputDependencies:["rank"]},getRunData:()=>{let b=Ne.size(o);return{outputs:[{dims:o,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:12,data:b},...Ct(c,p)]}},getShaderSource:f}},fw=(t,s)=>{_y(t.inputs,s.perm),t.compute(_a(t.inputs[0],s.perm))},pw=t=>An({perm:t.perm})}),wy,by,Ty,xy,Ey,Sy,Cy,Py,Ay,$y,mi,hw,mw,_w,gw,yw,Mw,vw,ww,bw,Tw,Gx=ot(()=>{Bt(),qt(),Xt(),q_(),au(),wy={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},by={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},Ty={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},xy={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},Ey=(t,s)=>{let n=[];for(let i=s-t;i<s;++i)n.push(i);return n},Sy=(t,s)=>{let n=[],i=t.length;for(let o=0;o<i;o++)s.indexOf(o)===-1&&n.push(t[o]);let l=s.map(o=>t[o]);return[n,l]},Cy=(t,s)=>{let n=t.length+s.length,i=[],l=0;for(let o=0;o<n;o++)s.indexOf(o)===-1?i.push(t[l++]):i.push(1);return i},Py=(t,s)=>{for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==s-1-n)return!1;return!0},Ay=(t,s)=>{let n=[];if(!Py(t,s)){for(let i=0;i<s;++i)t.indexOf(i)===-1&&n.push(i);t.forEach(i=>n.push(i))}return n},$y=(t,s,n,i,l,o,c)=>{let p=n[0].dims,d=Ne.size(o),f=Ne.size(c),g=Ke("_A",n[0].dataType,p),_=Tt("output",l,o),y=64;d===1&&(y=256);let T=`
          var<workgroup> aBestValues : array<f32, ${y}>;
       `,b=k=>`
        ${k.registerUniform("reduceSize","u32").declareVariables(g,_)}
        ${T}
        fn DIV_CEIL(a : u32, b : u32) -> u32 {
          return ((a - 1u) / b + 1u);
         }
         ${k.mainStart(y)}

          let outputIndex = global_idx / ${y};
          let offset = outputIndex * uniforms.reduceSize;

          var bestValue = f32(${Ty[i]});
          let Length = uniforms.reduceSize;
          for (var k = local_idx; k < Length; k = k + ${y}) {
           let candidate = f32(${g.getByOffset("offset + k")});
           bestValue = ${wy[i]};
          }
          aBestValues[local_idx] = bestValue;
          workgroupBarrier();

         var reduceSize = min(Length, ${y}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (local_idx < currentSize) {
            let candidate = aBestValues[local_idx + interval];
            bestValue = ${by[i]};
            aBestValues[local_idx] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (local_idx == 0u) {
          ${_.setByOffset("outputIndex",`${i==="mean"?`${_.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${_.type.storage}(${xy[i]})`}`)};
         }
        }`;return{name:t,shaderCache:{hint:`${s};${y}`,inputDependencies:["type"]},getShaderSource:b,getRunData:()=>({outputs:[{dims:o,dataType:l}],dispatchGroup:{x:d},programUniforms:[{type:12,data:f}]})}},mi=(t,s,n,i)=>{let l=t.inputs.length===1?n:w_(t.inputs,n),o=l.axes;o.length===0&&!l.noopWithEmptyAxes&&(o=t.inputs[0].dims.map((T,b)=>b));let c=Ne.normalizeAxes(o,t.inputs[0].dims.length),p=c,d=t.inputs[0],f=Ay(p,t.inputs[0].dims.length);f.length>0&&(d=t.compute(_a(t.inputs[0],f),{inputs:[0],outputs:[-1]})[0],p=Ey(p.length,d.dims.length));let[g,_]=Sy(d.dims,p),y=g;l.keepDims&&(y=Cy(g,c)),t.compute($y(s,l.cacheKey,[d],i,t.inputs[0].dataType,y,_),{inputs:[d]})},hw=(t,s)=>{mi(t,"ReduceMeanShared",s,"mean")},mw=(t,s)=>{mi(t,"ReduceL1Shared",s,"l1")},_w=(t,s)=>{mi(t,"ReduceL2Shared",s,"l2")},gw=(t,s)=>{mi(t,"ReduceLogSumExpShared",s,"logSumExp")},yw=(t,s)=>{mi(t,"ReduceMaxShared",s,"max")},Mw=(t,s)=>{mi(t,"ReduceMinShared",s,"min")},vw=(t,s)=>{mi(t,"ReduceProdShared",s,"prod")},ww=(t,s)=>{mi(t,"ReduceSumShared",s,"sum")},bw=(t,s)=>{mi(t,"ReduceSumSquareShared",s,"sumSquare")},Tw=(t,s)=>{mi(t,"ReduceLogSumShared",s,"logSum")}}),_i,Oy,Kh,w_,gi,ky,Dy,Iy,zy,Fy,Ly,By,Ry,Ny,jy,yi,xw,Ew,Sw,Cw,Pw,Aw,$w,Ow,kw,Dw,q_=ot(()=>{Bt(),qt(),or(),Xt(),Gx(),_i=t=>{if(!t||t.length===0||t.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(t.length===2&&t[1].dims.length!==1)throw new Error("Invalid axes input dims.")},Oy=t=>["","",`var value = ${t.getByIndices("input_indices")};`,""],Kh=(t,s,n,i,l,o,c=!1,p=!1)=>{let d=[],f=n[0].dims,g=f.length,_=Ne.normalizeAxes(l,g),y=!p&&_.length===0;f.forEach((k,L)=>{y||_.indexOf(L)>=0?c&&d.push(1):d.push(k)});let T=d.length,b=Ne.size(d);return{name:t,shaderCache:s,getShaderSource:k=>{let L=[],C=Ke("_A",n[0].dataType,g),S=Tt("output",o,T),I=i(C,S,_),O=I[2];for(let x=0,E=0;x<g;x++)y||_.indexOf(x)>=0?(c&&E++,O=`for(var j${x}: u32 = 0; j${x} < ${f[x]}; j${x}++) {
                  ${I[2].includes("last_index")?`let last_index = j${x};`:""}
                  ${C.indicesSet("input_indices",x,`j${x}`)}
                  ${O}
                }`):(L.push(`${C.indicesSet("input_indices",x,S.indicesGet("output_indices",E))};`),E++);return`

        ${k.registerUniform("output_size","u32").declareVariables(C,S)}

        ${k.mainStart()}
          ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          var input_indices: ${C.type.indices};
          let output_indices = ${S.offsetToIndices("global_idx")};

          ${L.join(`
`)}
          ${I[0]}       // init ops for reduce max/min
          ${I[1]}
          ${O}
          ${I[3]}
          ${I.length===4?S.setByOffset("global_idx","value"):I.slice(4).join(`
`)}
        }`},getRunData:()=>({outputs:[{dims:d,dataType:o}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:[{type:12,data:b},...Ct(f,d)]})}},w_=(t,s)=>{let n=[];return t[1].dims[0]>0&&t[1].getBigInt64Array().forEach(i=>n.push(Number(i))),An({axes:n,keepDims:s.keepDims,noopWithEmptyAxes:s.noopWithEmptyAxes})},gi=(t,s,n,i)=>{let l=t.inputs,o=l.length===1?n:w_(l,n);t.compute(Kh(s,{hint:o.cacheKey,inputDependencies:["rank"]},[l[0]],o.noopWithEmptyAxes&&o.axes.length===0?Oy:i,o.axes,l[0].dataType,o.keepDims,o.noopWithEmptyAxes),{inputs:[0]})},ky=(t,s)=>{_i(t.inputs),gi(t,"ReduceLogSum",s,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,"value = log(value);"])},Dy=(t,s)=>{_i(t.inputs),gi(t,"ReduceL1",s,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += abs(${n.getByIndices("input_indices")});`,""])},Iy=(t,s)=>{_i(t.inputs),gi(t,"ReduceL2",s,(n,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"])},zy=(t,s)=>{_i(t.inputs),gi(t,"ReduceLogSumExp",s,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += exp(${n.getByIndices("input_indices")});`,"value = log(value);"])},Fy=(t,s)=>{_i(t.inputs),gi(t,"ReduceMax",s,(n,i,l)=>{let o=[];for(let c=0;c<n.rank;c++)(l.indexOf(c)>=0||l.length===0)&&o.push(n.indicesSet("input_indices",c,0));return[`${o.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = max(value, ${n.getByIndices("input_indices")});`,""]})},Ly=(t,s)=>{_i(t.inputs),gi(t,"ReduceMean",s,(n,i,l)=>{let o=1;for(let c=0;c<n.rank;c++)(l.indexOf(c)>=0||l.length===0)&&(o*=t.inputs[0].dims[c]);return["var sum = f32(0);","",`sum += f32(${n.getByIndices("input_indices")});`,`let value = ${i.type.value}(sum / ${o});`]})},By=(t,s)=>{_i(t.inputs),gi(t,"ReduceMin",s,(n,i,l)=>{let o=[];for(let c=0;c<n.rank;c++)(l.indexOf(c)>=0||l.length===0)&&o.push(`input_indices[${c}] = 0;`);return[`${o.join(`
`)}`,`var value = ${n.getByIndices("input_indices")};`,`value = min(value, ${n.getByIndices("input_indices")});`,""]})},Ry=(t,s)=>{_i(t.inputs),gi(t,"ReduceProd",s,(n,i)=>[`var value = ${i.type.storage}(1);`,"",`value *= ${n.getByIndices("input_indices")};`,""])},Ny=(t,s)=>{_i(t.inputs),gi(t,"ReduceSum",s,(n,i)=>[`var value = ${i.type.storage}(0);`,"",`value += ${n.getByIndices("input_indices")};`,""])},jy=(t,s)=>{_i(t.inputs),gi(t,"ReduceSumSquare",s,(n,i)=>[`var t = ${i.type.value}(0); var value = ${i.type.value}(0);`,"",`t = ${n.getByIndices("input_indices")}; value += t * t;`,""])},yi=(t,s,n)=>{if(s.length===0)return n;let i=1,l=1;for(let o=0;o<s.length;o++)s.indexOf(o)===-1?i*=t[o]:l*=t[o];return l<32&&i>1024},xw=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?Ly(t,s):hw(t,s)},Ew=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?Dy(t,s):mw(t,s)},Sw=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?Iy(t,s):_w(t,s)},Cw=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?zy(t,s):gw(t,s)},Pw=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?Fy(t,s):yw(t,s)},Aw=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?By(t,s):Mw(t,s)},$w=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?Ry(t,s):vw(t,s)},Ow=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?Ny(t,s):ww(t,s)},kw=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?jy(t,s):bw(t,s)},Dw=(t,s)=>{yi(t.inputs[0].dims,s.axes,s.noopWithEmptyAxes)?ky(t,s):Tw(t,s)}}),Fm,Iw,zw,b_,Wx=ot(()=>{Bt(),or(),q_(),Fm=t=>{if(!t||t.length===0||t.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(t[0].dataType!==1)throw new Error("Invalid input type.")},Iw=(t,s)=>{Fm(t.inputs);let n=(i,l,o)=>{let c=[];for(let p=0;p<i.rank;p++)(o.indexOf(p)>=0||o.length===0)&&c.push(`input_indices[${p}] = 0;`);return[`${c.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${s.selectLastIndex>0?"<=":"<"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",l.setByOffset("global_idx","best_index")]};t.compute(Kh("ArgMin",{hint:s.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[s.axis],7,s.keepDims),{inputs:[0]})},zw=(t,s)=>{Fm(t.inputs);let n=(i,l,o)=>{let c=[];for(let p=0;p<i.rank;p++)(o.indexOf(p)>=0||o.length===0)&&c.push(`input_indices[${p}] = 0;`);return[`${c.join(`
`)}`,`var value = ${i.getByIndices("input_indices")};
var best_index : i32 = 0;`,`if (${i.getByIndices("input_indices")} ${s.selectLastIndex>0?">=":">"} value) {
         value = ${i.getByIndices("input_indices")};
         best_index = i32(last_index);
       }`,"",l.setByOffset("global_idx","best_index")]};t.compute(Kh("argMax",{hint:s.cacheKey,inputDependencies:["rank"]},[t.inputs[0]],n,[s.axis],7,s.keepDims),{inputs:[0]})},b_=t=>An(t)}),Uy,Oh,Vy,Gy,Wy,Vp,Hy,Fw,Q_=ot(()=>{Bt(),qt(),H_(),Xt(),Uy=(t,s)=>{let n=t[0],i=t[1],l=t[2],o=t[3],c=t[4],p=t[5];if(c&&p)throw new Error("Attention cannot have both past and attention_bias");if(n.dims.length!==3)throw new Error('Input "input" must have 3 dimensions');let d=n.dims[0],f=n.dims[1],g=n.dims[2];if(l.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimensions');if(i.dims.length!==2)throw new Error('Input "weights" is expected to have 2 dimensions');if(i.dims[0]!==g)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(l.dims[0]!==i.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let _=l.dims[0]/3,y=_,T=y;if(s.qkvHiddenSizes.length>0){if(s.qkvHiddenSizes.length!==3)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let I of s.qkvHiddenSizes)if(I%s.numHeads!==0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");_=s.qkvHiddenSizes[0],y=s.qkvHiddenSizes[1],T=s.qkvHiddenSizes[2]}let b=f;if(_!==y)throw new Error("qkv_hidden_sizes first element should be same as the second");if(l.dims[0]!==_+y+T)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let k=0;if(c){if(y!==T)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(c.dims.length!==5)throw new Error('Input "past" must have 5 dimensions');if(c.dims[0]!==2)throw new Error('Input "past" first dimension must be 2');if(c.dims[1]!==d)throw new Error('Input "past" second dimension must be batch_size');if(c.dims[2]!==s.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(c.dims[4]!==y/s.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');s.pastPresentShareBuffer||(k=c.dims[3])}let L=b+k,C=-1,S=0;if(o)throw new Error("Mask not supported");if(c)throw new Error("past is not supported");if(p){if(p.dims.length!==4)throw new Error('Input "attention_bias" must have 4 dimensions');if(p.dims[0]!==d||p.dims[1]!==s.numHeads||p.dims[2]!==f||p.dims[3]!==L)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:d,sequenceLength:f,pastSequenceLength:k,kvSequenceLength:b,totalSequenceLength:L,maxSequenceLength:C,inputHiddenSize:g,hiddenSize:_,vHiddenSize:T,headSize:Math.floor(_/s.numHeads),vHeadSize:Math.floor(T/s.numHeads),numHeads:s.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:s.maskFilterValue,maskType:S,scale:s.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},Oh=(t,s,n)=>s&&t?`
      let total_sequence_length_input = u32(${s.getByOffset("0")});
      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);
      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;
      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;
      total_sequence_length = u32(${t==null?void 0:t.getByOffset("batchIdx")}) + 1;
      var past_sequence_length: u32 = 0;
      if (is_first_prompt == false) {
        past_sequence_length = total_sequence_length - sequence_length;
      }
       `:`
    ${n?"let past_sequence_length = uniforms.past_sequence_length":""};
    let present_sequence_length = total_sequence_length;
    `,Vy=(t,s,n,i,l,o,c,p)=>{let d=nr(c?1:o),f=64,g=o/d;g<f&&(f=32);let _=Math.ceil(o/d/f),y=[{type:12,data:s},{type:12,data:n},{type:12,data:i},{type:12,data:l},{type:12,data:g},{type:12,data:_}],T=zr(t.dataType,d),b=hs(1,d),k=["type"];c&&k.push("type"),p&&k.push("type");let L=C=>{let S=Tt("x",t.dataType,t.dims,d),I=[S],O=c?Ke("seq_lens",c.dataType,c.dims):void 0;O&&I.push(O);let x=p?Ke("total_sequence_length_input",p.dataType,p.dims):void 0;x&&I.push(x);let E=hs(t.dataType),A=[{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}];return`
  var<workgroup> thread_max: array<f32, ${f}>;
  var<workgroup> thread_sum: array<f32, ${f}>;
  ${C.registerUniforms(A).declareVariables(...I)}
  ${C.mainStart([f,1,1])}
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let sequence_length = uniforms.sequence_length;
    var total_sequence_length = uniforms.total_sequence_length;
    ${Oh(O,x,!1)}
    let local_offset = local_idx * uniforms.elements_per_thread;
    let offset = (global_idx / ${f}) * uniforms.total_sequence_length + local_offset;
    let seq_causal_length = ${c?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};
    var thread_max_vector = ${b}(-3.402823e+38f);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      thread_max_vector = max(${b}(x[offset + i]), thread_max_vector);
    }
    thread_max[local_idx] = ${(()=>{switch(d){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${d}`)}})()};
    workgroupBarrier();

    var max_value =  f32(-3.402823e+38f);
    for (var i = 0u; i < ${f}; i++) {
      max_value = max(thread_max[i], max_value);
    }

    var sum_vector = ${b}(0);
    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
      sum_vector += exp(${b}(x[offset + i]) - max_value);
    }
    thread_sum[local_idx] = ${(()=>{switch(d){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${d}`)}})()};
    workgroupBarrier();

    var sum: f32 = 0;
    for (var i = 0u; i < ${f}; i++) {
      sum += thread_sum[i];
    }

    if (sum == 0) {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        x[offset + i] = ${S.type.value}(${E}(1.0) / ${E}(seq_causal_length));
      }
    } else {
      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {
        var f32input = ${b}(x[offset + i]);
        x[offset + i] = ${S.type.value}(exp(f32input - max_value) / sum);
      }
    }
      ${c?`
        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {
          x[offset + total_seq_id] = ${S.type.value}(${E}(0));
        }`:""};
  }`};return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${f};${T};${d}`,inputDependencies:k},getShaderSource:L,getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:l,z:s*n},programUniforms:y})}},Gy=(t,s,n,i,l,o,c,p,d)=>{let f=c+o.kvSequenceLength,g=[o.batchSize,o.numHeads,o.sequenceLength,f],_=t>1&&i,y=o.kvNumHeads?o.kvNumHeads:o.numHeads,T=_?[o.batchSize,y,f,o.headSize]:void 0,b=o.nReps?o.nReps:1,k=o.scale===0?1/Math.sqrt(o.headSize):o.scale,L=nr(o.headSize),C=o.headSize/L,S=12,I={x:Math.ceil(f/S),y:Math.ceil(o.sequenceLength/S),z:o.batchSize*o.numHeads},O=[{type:12,data:o.sequenceLength},{type:12,data:C},{type:12,data:f},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:1,data:k},{type:12,data:c},{type:12,data:o.kvSequenceLength},{type:12,data:b}],x=_&&i&&Ne.size(i.dims)>0,E=["type","type"];x&&E.push("type"),l&&E.push("type"),p&&E.push("type"),d&&E.push("type");let A=[{dims:g,dataType:s.dataType,gpuDataType:0}];_&&A.push({dims:T,dataType:s.dataType,gpuDataType:0});let F=K=>{let X=Ke("q",s.dataType,s.dims,L),oe=Ke("key",n.dataType,n.dims,L),ie=[X,oe];if(x){let ge=Ke("past_key",i.dataType,i.dims,L);ie.push(ge)}l&&ie.push(Ke("attention_bias",l.dataType,l.dims));let J=p?Ke("seq_lens",p.dataType,p.dims):void 0;J&&ie.push(J);let ue=d?Ke("total_sequence_length_input",d.dataType,d.dims):void 0;ue&&ie.push(ue);let ne=Tt("output",s.dataType,g),G=[ne];_&&G.push(Tt("present_key",s.dataType,T,L));let se=hs(1,L),ce=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${S}u;

  var<workgroup> tileQ: array<${X.type.storage}, ${S*S}>;
  var<workgroup> tileK: array<${X.type.storage}, ${S*S}>;
  ${K.registerUniforms(ce).declareVariables(...ie,...G)}
  ${K.mainStart([S,S,1])}
    // x holds the N and y holds the M
    let headIdx = workgroup_id.z % uniforms.num_heads;
    let kvHeadIdx = ${b===1?"headIdx":"headIdx / uniforms.n_reps"};
    let kv_num_heads = ${b===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
    let batchIdx = workgroup_id.z / uniforms.num_heads;
    let m = workgroup_id.y * TILE_SIZE;
    let n = workgroup_id.x * TILE_SIZE;
    let sequence_length = uniforms.M;
    var total_sequence_length = uniforms.N;
    ${Oh(J,ue,!0)}
    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;
    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
    ${x&&_?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};
    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;
    ${_?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}
    var value = ${se}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];
      }
      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
      ${x&&_?`
              if (n + local_id.y < past_sequence_length) {
                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];
              }`:`
          if (n + local_id.y < uniforms.kv_sequence_length) {
            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];
          }`}
      ${_?`if (n + local_id.y < present_sequence_length) {
        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];
      }`:""}
      }
      workgroupBarrier();

      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {
          value += ${se}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);
      }

      workgroupBarrier();
    }

    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {
      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;
      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;
      var sum: f32 = ${(()=>{switch(L){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${L}`)}})()};
        output[outputIdx] = ${ne.type.value} (sum * uniforms.alpha) + ${l?"attention_bias[outputIdx]":"0.0"};
    }
  }`};return{name:"AttentionProbs",shaderCache:{hint:`${L};${l!==void 0};${i!==void 0};${t}`,inputDependencies:E},getRunData:()=>({outputs:A,dispatchGroup:I,programUniforms:O}),getShaderSource:F}},Wy=(t,s,n,i,l,o,c=void 0,p=void 0)=>{let d=o+l.kvSequenceLength,f=l.nReps?l.nReps:1,g=l.vHiddenSize*f,_=t>1&&i,y=l.kvNumHeads?l.kvNumHeads:l.numHeads,T=_?[l.batchSize,y,d,l.headSize]:void 0,b=[l.batchSize,l.sequenceLength,g],k=12,L={x:Math.ceil(l.vHeadSize/k),y:Math.ceil(l.sequenceLength/k),z:l.batchSize*l.numHeads},C=[{type:12,data:l.sequenceLength},{type:12,data:d},{type:12,data:l.vHeadSize},{type:12,data:l.numHeads},{type:12,data:l.headSize},{type:12,data:g},{type:12,data:o},{type:12,data:l.kvSequenceLength},{type:12,data:f}],S=_&&i&&Ne.size(i.dims)>0,I=["type","type"];S&&I.push("type"),c&&I.push("type"),p&&I.push("type");let O=[{dims:b,dataType:s.dataType,gpuDataType:0}];_&&O.push({dims:T,dataType:s.dataType,gpuDataType:0});let x=E=>{let A=Ke("probs",s.dataType,s.dims),F=Ke("v",n.dataType,n.dims),K=[A,F];S&&K.push(Ke("past_value",i.dataType,i.dims));let X=c?Ke("seq_lens",c.dataType,c.dims):void 0;c&&K.push(X);let oe=p?Ke("total_sequence_length_input",p.dataType,p.dims):void 0;p&&K.push(oe);let ie=[Tt("output",s.dataType,b)];_&&ie.push(Tt("present_value",s.dataType,T));let J=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}];return`
  const TILE_SIZE = ${k}u;
  var<workgroup> tileQ: array<${A.type.value}, ${k*k}>;
  var<workgroup> tileV: array<${A.type.value}, ${k*k}>;
  ${E.registerUniforms(J).declareVariables(...K,...ie)}
  ${E.mainStart([k,k,1])}
   let headIdx = workgroup_id.z % uniforms.num_heads;
   let batchIdx = workgroup_id.z / uniforms.num_heads;
   let kvHeadIdx = ${f===1?"headIdx":"headIdx / uniforms.n_reps"};
   let kv_num_heads = ${f===1?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};
   let m = global_id.y;
   let n = global_id.x;
   let sequence_length = uniforms.M;
   var total_sequence_length = uniforms.K;
   ${Oh(X,oe,!0)}
   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;
   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch
   ${S&&_?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};
   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;
   ${_?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}
   var value = ${A.type.storage}(0);
   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        var idx = TILE_SIZE * local_id.y + local_id.x;
        ${S&&_?`
        if (w + local_id.y < past_sequence_length) {
          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];
        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {
          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];
        }
      `:`
            if (w + local_id.y < uniforms.kv_sequence_length) {
              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];
            }`}
        ${_?`
            if (w + local_id.y < present_sequence_length) {
          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];
        }`:""}
      }
     workgroupBarrier();
     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {
       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];
     }
     workgroupBarrier();
   }

   // we need to transpose output from BNSH_v to BSND_v
   if (m < uniforms.M && n < uniforms.N) {
     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size
       + headIdx * uniforms.N + n;
     output[outputIdx] = value;
   }
  }`};return{name:"AttentionScore",shaderCache:{hint:`${i!==void 0};${t}`,inputDependencies:I},getRunData:()=>({outputs:O,dispatchGroup:L,programUniforms:C}),getShaderSource:x}},Vp=(t,s,n,i,l,o,c,p,d,f,g=void 0,_=void 0)=>{let y=Math.min(t.outputCount,1+(c?1:0)+(p?1:0)),T=y>1?f.pastSequenceLength:0,b=T+f.kvSequenceLength,k=d&&Ne.size(d.dims)>0?d:void 0,L=[s,n];y>1&&c&&Ne.size(c.dims)>0&&L.push(c),k&&L.push(k),g&&L.push(g),_&&L.push(_);let C=t.compute(Gy(y,s,n,c,k,f,T,g,_),{inputs:L,outputs:y>1?[-1,1]:[-1]})[0];t.compute(Vy(C,f.batchSize,f.numHeads,T,f.sequenceLength,b,g,_),{inputs:g&&_?[C,g,_]:[C],outputs:[]});let S=[C,i];y>1&&p&&Ne.size(p.dims)>0&&S.push(p),g&&S.push(g),_&&S.push(_),t.compute(Wy(y,C,i,p,f,T,g,_),{inputs:S,outputs:y>1?[0,2]:[0]})},Hy=(t,s)=>{let n=[s.batchSize,s.numHeads,s.sequenceLength,s.headSize],i=s.sequenceLength,l=s.inputHiddenSize,o=s.headSize,c=12,p={x:Math.ceil(s.headSize/c),y:Math.ceil(s.sequenceLength/c),z:s.batchSize*s.numHeads},d=[t.inputs[0],t.inputs[1],t.inputs[2]],f=[{type:12,data:i},{type:12,data:l},{type:12,data:o},{type:12,data:s.numHeads},{type:12,data:s.headSize},{type:12,data:s.hiddenSize},{type:12,data:s.hiddenSize+s.hiddenSize+s.vHiddenSize}],g=_=>{let y=Tt("output_q",d[0].dataType,n),T=Tt("output_k",d[0].dataType,n),b=Tt("output_v",d[0].dataType,n),k=Ke("input",d[0].dataType,d[0].dims),L=Ke("weight",d[1].dataType,d[1].dims),C=Ke("bias",d[2].dataType,d[2].dims),S=k.type.storage,I=[{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}];return`
  const TILE_SIZE = ${c}u;
  var<workgroup> tileInput: array<${S}, ${c*c}>;
  var<workgroup> tileWeightQ: array<${S}, ${c*c}>;
  var<workgroup> tileWeightK: array<${S}, ${c*c}>;
  var<workgroup> tileWeightV: array<${S}, ${c*c}>;
  ${_.registerUniforms(I).declareVariables(k,L,C,y,T,b)}
  ${_.mainStart([c,c,1])}
    let batchIndex = workgroup_id.z / uniforms.num_heads;
    let headNumber = workgroup_id.z % uniforms.num_heads;
    let m = global_id.y;
    let n = global_id.x;

    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;
    let biasOffsetQ = headNumber * uniforms.head_size;
    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;
    let biasOffsetV = uniforms.hidden_size + biasOffsetK;

    var valueQ = ${S}(0);
    var valueK = ${S}(0);
    var valueV = ${S}(0);
    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {
      if (m < uniforms.M && w + local_id.x < uniforms.K) {
        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];
      }
      if (n < uniforms.N && w + local_id.y < uniforms.K) {
        let offset = n + (w + local_id.y) * uniforms.ldb;
        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];
        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];
        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];
      }
      workgroupBarrier();
      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {
        let inputTileOffset = TILE_SIZE * local_id.y + k;
        let weightTileOffset = TILE_SIZE * k + local_id.x;
        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];
        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];
        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];
      }

      workgroupBarrier();
    }

    let headOffset = (m * uniforms.N + n) % uniforms.head_size;
    valueQ += bias[headOffset + biasOffsetQ];
    valueK += bias[headOffset + biasOffsetK];
    valueV += bias[headOffset + biasOffsetV];

    let offset = workgroup_id.z * uniforms.M * uniforms.N;
    if (m < uniforms.M && n < uniforms.N) {
      let outputIdx = offset + m * uniforms.N + n;
      output_q[outputIdx] = valueQ;
      output_k[outputIdx] = valueK;
      output_v[outputIdx] = valueV;
    }
  }`};return t.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0},{dims:n,dataType:t.inputs[0].dataType,gpuDataType:0}],dispatchGroup:p,programUniforms:f}),getShaderSource:g},{inputs:d,outputs:[-1,-1,-1]})},Fw=(t,s)=>{let n=Uy(t.inputs,s),[i,l,o]=Hy(t,n);return Vp(t,i,l,o,t.inputs[4],void 0,void 0,void 0,t.inputs[5],n)}}),Ky,qy,Qy,Lw,Hx=ot(()=>{xi(),Bt(),qt(),or(),Xt(),Ky=(t,s)=>{if(!t||t.length!==5)throw new Error("BatchNormalization requires 5 inputs");let n=(i,l,o)=>{let c=l.length;if(c!==i.length)throw new Error(`${o}: num dimensions != ${c}`);l.forEach((p,d)=>{if(p!==i[d])throw new Error(`${o}: dim[${d}] do not match`)})};if(t[0].dims.length>1){let i=s.format==="NHWC"?s.spatial?t[0].dims.slice(-1):t[0].dims.slice(-1).concat(t[0].dims.slice(1,t[0].dims.length-1)):t[0].dims.slice(1,s.spatial?2:void 0);n(t[1].dims,i,"Invalid input scale"),n(t[2].dims,i,"Invalid input B"),n(t[3].dims,i,"Invalid input mean"),n(t[4].dims,i,"Invalid input var")}else n(t[1].dims,[1],"Invalid input scale"),n(t[2].dims,[1],"Invalid input B"),n(t[3].dims,[1],"Invalid input mean"),n(t[4].dims,[1],"Invalid input var")},qy=(t,s)=>{let{epsilon:n,spatial:i,format:l}=s,o=t[0].dims,c=i?nr(o[o.length-1]):1,p=l==="NHWC"&&o.length>1?c:1,d=Ne.size(o)/c,f=i,g=f?o.length:o,_=Ke("x",t[0].dataType,t[0].dims,c),y=Ke("scale",t[1].dataType,t[1].dims,p),T=Ke("bias",t[2].dataType,t[2].dims,p),b=Ke("inputMean",t[3].dataType,t[3].dims,p),k=Ke("inputVar",t[4].dataType,t[4].dims,p),L=Tt("y",t[0].dataType,g,c),C=()=>{let I="";if(i)I=`let cOffset = ${o.length===1?"0u":l==="NHWC"?`outputIndices[${o.length-1}] / ${c}`:"outputIndices[1]"};`;else if(l==="NCHW")I=`
            ${L.indicesSet("outputIndices","0","0")}
            let cOffset = ${L.indicesToOffset("outputIndices")};`;else{I=`var cIndices = ${y.type.indices}(0);
                       cIndices[0] = outputIndices[${o.length-1}];`;for(let O=1;O<y.rank;O++)I+=`cIndices[${O}] = outputIndices[${O}];`;I+=`let cOffset = ${y.indicesToOffset("cIndices")};`}return I},S=I=>`
  const epsilon = ${n};
  ${I.registerUniform("outputSize","u32").declareVariables(_,y,T,b,k,L)}
  ${I.mainStart()}
  ${I.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
    var outputIndices = ${L.offsetToIndices(`global_idx * ${c}`)};
    ${C()}
    let scale = ${y.getByOffset("cOffset")};
    let bias = ${T.getByOffset("cOffset")};
    let inputMean = ${b.getByOffset("cOffset")};
    let inputVar = ${k.getByOffset("cOffset")};
    let x = ${_.getByOffset("global_idx")};
    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;
    ${L.setByOffset("global_idx","value")}
  }`;return{name:"BatchNormalization",shaderCache:{hint:`${s.epsilon}_${s.format}_${i}_${c}`,inputDependencies:f?["rank","type","type","type","type"]:void 0},getShaderSource:S,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f?[{type:12,data:d},...Ct(o)]:[{type:12,data:d}]})}},Qy=t=>An(t),Lw=(t,s)=>{let{inputs:n,outputCount:i}=t,l=Qy({...s,outputCount:i});if(Hn.webgpu.validateInputContent&&Ky(n,l),s.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");t.compute(qy(n,l))}}),Xy,Yy,Bw,Kx=ot(()=>{qt(),Xt(),Xy=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(t[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Yy=t=>{let s=t[0].dims,n=t[0].dims[2],i=Ne.size(s)/4,l=t[0].dataType,o=Ke("input",l,s,4),c=Ke("bias",l,[n],4),p=Ke("residual",l,s,4),d=Tt("output",l,s,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)}}),getShaderSource:f=>`
  const channels = ${n}u / 4;
  ${f.declareVariables(o,c,p,d)}

  ${f.mainStart()}
    ${f.guardAgainstOutOfBoundsWorkgroupSizes(i)}
    let value = ${o.getByOffset("global_idx")}
      + ${c.getByOffset("global_idx % channels")} + ${p.getByOffset("global_idx")};
    ${d.setByOffset("global_idx","value")}
  }`}},Bw=t=>{Xy(t.inputs),t.compute(Yy(t.inputs))}}),Zy,pn,Rw,Nw,jw,Uw,Vw,Gw,Ww,Hw,Kw,Jy,qw,Qw,Xw,Yw,Rp,Zw,Uh,Jw,eb,tb,nb,rb,sb,ab,ib,ob,lb,ub,cb,db,fb,pb,hb,Lm,mb,T_,x_,_b,gb,yb,e0,t0,Mb,X_=ot(()=>{Bt(),qt(),or(),Xt(),Zy=(t,s,n,i,l,o,c)=>{let p=Math.ceil(s/4),d="";typeof l=="string"?d=`${l}(a)`:d=l("a");let f=Ke("inputData",n,[p],4),g=Tt("outputData",i,[p],4),_=[{name:"vec_size",type:"u32"}];return c&&_.push(...c),`
      ${t.registerUniforms(_).declareVariables(f,g)}

  ${o??""}

  ${t.mainStart()}
    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}

    let a = ${f.getByOffset("global_idx")};
    ${g.setByOffset("global_idx",d)}
  }`},pn=(t,s,n,i,l,o=t.dataType,c,p)=>{let d=[{type:12,data:Math.ceil(Ne.size(t.dims)/4)}];return c&&d.push(...c),{name:s,shaderCache:{hint:l,inputDependencies:["type"]},getShaderSource:f=>Zy(f,Ne.size(t.dims),t.dataType,o,n,i,p),getRunData:f=>({outputs:[{dims:t.dims,dataType:o}],dispatchGroup:{x:Math.ceil(Ne.size(f[0].dims)/64/4)},programUniforms:d})}},Rw=t=>{t.compute(pn(t.inputs[0],"Abs","abs"))},Nw=t=>{t.compute(pn(t.inputs[0],"Acos","acos"))},jw=t=>{t.compute(pn(t.inputs[0],"Acosh","acosh"))},Uw=t=>{t.compute(pn(t.inputs[0],"Asin","asin"))},Vw=t=>{t.compute(pn(t.inputs[0],"Asinh","asinh"))},Gw=t=>{t.compute(pn(t.inputs[0],"Atan","atan"))},Ww=t=>{t.compute(pn(t.inputs[0],"Atanh","atanh"))},Hw=t=>An(t),Kw=(t,s)=>{let n;switch(s.to){case 10:n="vec4<f16>";break;case 1:n="vec4<f32>";break;case 12:n="vec4<u32>";break;case 6:n="vec4<i32>";break;case 9:n="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${s.to}`)}t.compute(pn(t.inputs[0],"Cast",n,void 0,s.cacheKey,s.to))},Jy=t=>{let s,n,i=t.length>=2&&t[1].data!==0,l=t.length>=3&&t[2].data!==0;switch(t[0].dataType){case 1:s=i?t[1].getFloat32Array()[0]:-34028234663852886e22,n=l?t[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:s=i?t[1].getUint16Array()[0]:64511,n=l?t[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return An({min:s,max:n})},qw=(t,s)=>{let n=s||Jy(t.inputs),i=hs(t.inputs[0].dataType);t.compute(pn(t.inputs[0],"Clip",l=>`clamp(${l}, vec4<${i}>(uniforms.min), vec4<${i}>(uniforms.max))`,void 0,n.cacheKey,void 0,[{type:t.inputs[0].dataType,data:n.min},{type:t.inputs[0].dataType,data:n.max}],[{name:"min",type:i},{name:"max",type:i}]),{inputs:[0]})},Qw=t=>{t.compute(pn(t.inputs[0],"Ceil","ceil"))},Xw=t=>{t.compute(pn(t.inputs[0],"Cos","cos"))},Yw=t=>{t.compute(pn(t.inputs[0],"Cosh","cosh"))},Rp=t=>An(t),Zw=(t,s)=>{let n=hs(t.inputs[0].dataType);t.compute(pn(t.inputs[0],"Elu",i=>`elu_vf32(${i})`,`
  const elu_alpha_ = ${n}(${s.alpha});

  fn elu_f32(a: ${n}) -> ${n} {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<${n}>) -> vec4<${n}> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`,s.cacheKey))},Uh=(t="f32")=>`
const r0: ${t} = 0.3275911;
const r1: ${t} = 0.254829592;
const r2: ${t} = -0.284496736;
const r3: ${t} = 1.421413741;
const r4: ${t} = -1.453152027;
const r5: ${t} = 1.061405429;

fn erf_vf32(v: vec4<${t}>) -> vec4<${t}> {
  let absv = abs(v);
  let x = 1.0 / (1.0 + r0 * absv);
  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
}`,Jw=t=>{let s=hs(t.inputs[0].dataType);t.compute(pn(t.inputs[0],"Erf",n=>`erf_vf32(${n})`,Uh(s)))},eb=t=>{t.compute(pn(t.inputs[0],"Exp","exp"))},tb=t=>{t.compute(pn(t.inputs[0],"Floor","floor"))},nb=t=>{let s=hs(t.inputs[0].dataType);t.compute(pn(t.inputs[0],"Gelu",n=>`0.5 * ${n} * (1.0 + erf_vf32(${n} * 0.7071067811865475))`,Uh(s)))},rb=(t,s)=>{let n=hs(t.inputs[0].dataType);t.compute(pn(t.inputs[0],"LeakyRelu",i=>`select(leaky_relu_alpha_ * ${i}, ${i}, ${i} >= vec4<${n}>(0.0))`,`const leaky_relu_alpha_ = ${n}(${s.alpha});`,s.cacheKey))},sb=t=>{t.compute(pn(t.inputs[0],"Not",s=>`!${s}`))},ab=t=>{t.compute(pn(t.inputs[0],"Neg",s=>`-${s}`))},ib=t=>{t.compute(pn(t.inputs[0],"Reciprocal",s=>`1.0/${s}`))},ob=t=>{let s=hs(t.inputs[0].dataType);t.compute(pn(t.inputs[0],"Relu",n=>`select(vec4<${s}>(0.0), ${n}, ${n} > vec4<${s}>(0.0))`))},lb=t=>{t.compute(pn(t.inputs[0],"Sigmoid",s=>`(1.0 / (1.0 + exp(-${s})))`))},ub=t=>An(t),cb=(t,s)=>{let n=hs(t.inputs[0].dataType);t.compute(pn(t.inputs[0],"HardSigmoid",i=>`max(vec4<${n}>(0.0), min(vec4<${n}>(1.0), ${s.alpha} * ${i} + vec4<${n}>(${s.beta})))`,void 0,s.cacheKey))},db=t=>{t.compute(pn(t.inputs[0],"Sin","sin"))},fb=t=>{t.compute(pn(t.inputs[0],"Sinh","sinh"))},pb=t=>{t.compute(pn(t.inputs[0],"Sqrt","sqrt"))},hb=t=>{t.compute(pn(t.inputs[0],"Tan","tan"))},Lm=t=>`sign(${t}) * (1 - exp(-2 * abs(${t}))) / (1 + exp(-2 * abs(${t})))`,mb=t=>{t.compute(pn(t.inputs[0],"Tanh",Lm))},T_=(t="f32")=>`
const fast_gelu_a: ${t} = 0.5;
const fast_gelu_b: ${t} = 0.7978845608028654;
const fast_gelu_c: ${t} = 0.035677408136300125;

fn tanh_v(v: vec4<${t}>) -> vec4<${t}> {
  return ${Lm("v")};
}
`,x_=t=>`(fast_gelu_a + fast_gelu_a * tanh_v(${t} * (fast_gelu_c * ${t} * ${t} + fast_gelu_b))) * ${t}`,_b=t=>{let s=hs(t.inputs[0].dataType);t.compute(pn(t.inputs[0],"FastGelu",x_,T_(s),void 0,t.inputs[0].dataType))},gb=(t,s)=>{let n=hs(t.inputs[0].dataType);return t.compute(pn(t.inputs[0],"ThresholdedRelu",i=>`select(vec4<${n}>(0.0), ${i}, ${i} > thresholded_relu_alpha_)`,`const thresholded_relu_alpha_ = vec4<${n}>(${s.alpha});`,s.cacheKey)),0},yb=t=>{t.compute(pn(t.inputs[0],"Log","log"))},e0=(t,s)=>`
const alpha = vec4<${t}>(${s});
const one = ${t}(1.0);
const zero = ${t}(0.0);

fn quick_gelu_impl(x: vec4<${t}>) -> vec4<${t}> {
  let v = x *alpha;
  var x1 : vec4<${t}>;
  for (var i = 0; i < 4; i = i + 1) {
    if (v[i] >= zero) {
      x1[i] = one / (one + exp(-v[i]));
    } else {
      x1[i] = one - one / (one + exp(v[i]));
    }
  }
  return x * x1;
}
`,t0=t=>`quick_gelu_impl(${t})`,Mb=(t,s)=>{let n=hs(t.inputs[0].dataType);t.compute(pn(t.inputs[0],"QuickGelu",t0,e0(n,s.alpha),s.cacheKey,t.inputs[0].dataType))}}),n0,r0,vb,qx=ot(()=>{qt(),Xt(),X_(),n0=t=>{if(t[0].dims.length!==3)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(t[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(t[1].dims.length!==1)throw new Error("bias is expected to have 1 dimensions");if(t[0].dims[2]!==t[1].dims[0])throw new Error("last dimension of input and bias are not the same")},r0=t=>{let s=t[0].dims.slice();s[2]=s[2]/2;let n=Ke("input",t[0].dataType,t[0].dims,4),i=Ke("bias",t[0].dataType,[t[0].dims[2]],4),l=Tt("output",t[0].dataType,s,4),o=Ne.size(s)/4,c=zr(t[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:s,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:p=>`
  const M_SQRT2 = sqrt(2.0);
  const halfChannels = ${t[0].dims[2]/4/2}u;

  ${p.declareVariables(n,i,l)}

  ${Uh(c)}

  ${p.mainStart()}
    ${p.guardAgainstOutOfBoundsWorkgroupSizes(o)}
    let biasIdx = global_idx % halfChannels;
    let batchIndex = global_idx / halfChannels;
    let inputOffset = biasIdx + batchIndex * halfChannels * 2;
    let valueLeft = input[inputOffset] + bias[biasIdx];
    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];
    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);

    ${l.setByOffset("global_idx","valueLeft * geluRight")}
  }`}},vb=t=>{n0(t.inputs),t.compute(r0(t.inputs))}}),s0,a0,Mi,wb,bb,Tb,xb,Eb,Sb,Cb,Pb,Ab,$b,Qx=ot(()=>{Bt(),qt(),Xt(),s0=(t,s,n,i,l,o,c,p,d,f,g,_)=>{let y,T;typeof p=="string"?y=T=(S,I)=>`${p}((${S}),(${I}))`:typeof p=="function"?y=T=p:(y=p.scalar,T=p.vector);let b=Tt("outputData",g,i.length,4),k=Ke("aData",d,s.length,4),L=Ke("bData",f,n.length,4),C;if(l)if(o){let S=Ne.size(s)===1,I=Ne.size(n)===1,O=s.length>0&&s[s.length-1]%4===0,x=n.length>0&&n[n.length-1]%4===0;S||I?C=b.setByOffset("global_idx",T(S?`${k.type.value}(${k.getByOffset("0")}.x)`:k.getByOffset("global_idx"),I?`${L.type.value}(${L.getByOffset("0")}.x)`:L.getByOffset("global_idx"))):C=`
            let outputIndices = ${b.offsetToIndices("global_idx * 4u")};
            let offsetA = ${k.broadcastedIndicesToOffset("outputIndices",b)};
            let offsetB = ${L.broadcastedIndicesToOffset("outputIndices",b)};
            ${b.setByOffset("global_idx",T(c||O?k.getByOffset("offsetA / 4u"):`${k.type.value}(${k.getByOffset("offsetA / 4u")}[offsetA % 4u])`,c||x?L.getByOffset("offsetB / 4u"):`${L.type.value}(${L.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}
          `}else C=b.setByOffset("global_idx",T(k.getByOffset("global_idx"),L.getByOffset("global_idx")));else{if(!o)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let S=(I,O,x="")=>{let E=`aData[indexA${O}][componentA${O}]`,A=`bData[indexB${O}][componentB${O}]`;return`
            let outputIndices${O} = ${b.offsetToIndices(`global_idx * 4u + ${O}u`)};
            let offsetA${O} = ${k.broadcastedIndicesToOffset(`outputIndices${O}`,b)};
            let offsetB${O} = ${L.broadcastedIndicesToOffset(`outputIndices${O}`,b)};
            let indexA${O} = offsetA${O} / 4u;
            let indexB${O} = offsetB${O} / 4u;
            let componentA${O} = offsetA${O} % 4u;
            let componentB${O} = offsetB${O} % 4u;
            ${I}[${O}] = ${x}(${y(E,A)});
          `};g===9?C=`
            var data = vec4<u32>(0);
            ${S("data",0,"u32")}
            ${S("data",1,"u32")}
            ${S("data",2,"u32")}
            ${S("data",3,"u32")}
            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:C=`
            ${S("outputData[global_idx]",0)}
            ${S("outputData[global_idx]",1)}
            ${S("outputData[global_idx]",2)}
            ${S("outputData[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(k,L,b)}

        ${_??""}

        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${C}
      }`},a0=(t,s,n,i,l,o,c=n.dataType)=>{let p=n.dims.map(k=>Number(k)??1),d=i.dims.map(k=>Number(k)??1),f=!Ne.areEqual(p,d),g=p,_=Ne.size(p),y=!1,T=!1,b=[f];if(f){let k=Gd.calcShape(p,d,!1);if(!k)throw new Error("Can't perform binary op on the given tensors");g=k.slice(),_=Ne.size(g);let L=Ne.size(p)===1,C=Ne.size(d)===1,S=p.length>0&&p[p.length-1]%4===0,I=d.length>0&&d[d.length-1]%4===0;b.push(L),b.push(C),b.push(S),b.push(I);let O=1;for(let x=1;x<g.length;x++){let E=p[p.length-x],A=d[d.length-x];if(E===A)O*=E;else break}O%4===0?(T=!0,y=!0):(L||C||S||I)&&(y=!0)}else y=!0;return b.push(y),{name:t,shaderCache:{hint:s+b.map(k=>k.toString()).join("_"),inputDependencies:["rank","rank"]},getShaderSource:k=>s0(k,p,d,g,y,f,T,l,n.dataType,i.dataType,c,o),getRunData:()=>({outputs:[{dims:g,dataType:c}],dispatchGroup:{x:Math.ceil(_/64/4)},programUniforms:[{type:12,data:Math.ceil(Ne.size(g)/4)},...Ct(p,d,g)]})}},Mi=(t,s,n,i,l,o)=>{t.compute(a0(s,l??"",t.inputs[0],t.inputs[1],n,i,o))},wb=t=>{Mi(t,"Add",(s,n)=>`${s}+${n}`)},bb=t=>{Mi(t,"Div",(s,n)=>`${s}/${n}`)},Tb=t=>{Mi(t,"Equal",{scalar:(s,n)=>`u32(${s}==${n})`,vector:(s,n)=>`vec4<u32>(${s}==${n})`},void 0,void 0,9)},xb=t=>{Mi(t,"Mul",(s,n)=>`${s}*${n}`)},Eb=t=>{let s=Ke("input",t.inputs[0].dataType,t.inputs[0].dims).type.value;Mi(t,"Pow",{scalar:(n,i)=>`pow_custom(${n},${i})`,vector:(n,i)=>`pow_vector_custom(${n},${i})`},`
    fn pow_custom(a : ${s}, b : ${s}) -> ${s} {
      if (b == ${s}(0.0)) {
        return ${s}(1.0);
      } else if (a < ${s}(0.0) && f32(b) != floor(f32(b))) {
        return ${s}(pow(f32(a), f32(b))); // NaN
      }
      return select(sign(a), ${s}(1.0), round(f32(abs(b) % ${s}(2.0))) != 1.0) * ${s}(${s==="i32"?"round":""}(pow(f32(abs(a)), f32(b))));
    }
    fn pow_vector_custom(a : vec4<${s}>, b : vec4<${s}>) -> vec4<${s}> {
      // TODO: implement vectorized pow
      return vec4<${s}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));
    }
      `)},Sb=t=>{Mi(t,"Sub",(s,n)=>`${s}-${n}`)},Cb=t=>{Mi(t,"Greater",{scalar:(s,n)=>`u32(${s}>${n})`,vector:(s,n)=>`vec4<u32>(${s}>${n})`},void 0,void 0,9)},Pb=t=>{Mi(t,"Less",{scalar:(s,n)=>`u32(${s}<${n})`,vector:(s,n)=>`vec4<u32>(${s}<${n})`},void 0,void 0,9)},Ab=t=>{Mi(t,"GreaterOrEqual",{scalar:(s,n)=>`u32(${s}>=${n})`,vector:(s,n)=>`vec4<u32>(${s}>=${n})`},void 0,void 0,9)},$b=t=>{Mi(t,"LessOrEqual",{scalar:(s,n)=>`u32(${s}<=${n})`,vector:(s,n)=>`vec4<u32>(${s}<=${n})`},void 0,void 0,9)}}),i0,o0,l0,u0,Ob,kb,Xx=ot(()=>{Bt(),qt(),or(),Xt(),i0=(t,s)=>{if(!t||t.length<1)throw new Error("too few inputs");let n=0,i=t[n],l=i.dataType,o=i.dims.length;t.forEach((c,p)=>{if(p!==n){if(c.dataType!==l)throw new Error("input tensors should be one type");if(c.dims.length!==o)throw new Error("input tensors should have the same shape");c.dims.forEach((d,f)=>{if(f!==s&&d!==i.dims[f])throw new Error("non concat dimensions must match")})}})},o0=(t,s)=>`
  fn calculateInputIndex(index: u32) -> u32 {
    let sizeInConcatAxis = array<u32, ${t}u>(${s});
    for (var i: u32 = 0u; i < ${t}; i += 1u ) {
      if (index < sizeInConcatAxis[i]) {
        return i;
      }
    }
    return ${t}u;
  }`,l0=(t,s)=>{let n=t.length,i=[];for(let l=0;l<n;++l){let o=s.setByOffset("global_idx",t[l].getByIndices("indices"));n===1?i.push(o):l===0?i.push(`if (inputIndex == ${l}u) { ${o} }`):l===n-1?i.push(`else { ${o} }`):i.push(`else if (inputIndex == ${l}) { ${o} }`)}return i.join(`
`)},u0=(t,s,n,i)=>{let l=Ne.size(n),o=new Array(t.length),c=new Array(t.length),p=0,d=[],f=[],g=[{type:12,data:l}];for(let k=0;k<t.length;++k)p+=t[k].dims[s],o[k]=p,f.push(t[k].dims.length),c[k]=Ke(`input${k}`,i,f[k]),d.push("rank"),g.push({type:12,data:o[k]});for(let k=0;k<t.length;++k)g.push(...Ct(t[k].dims));g.push(...Ct(n));let _=Tt("output",i,n.length),y=_.indicesGet("indices",s),T=Array.from(Array(o.length).keys()).map(k=>`uniforms.sizeInConcatAxis${k}`).join(","),b=k=>`

  ${(()=>{k.registerUniform("outputSize","u32");for(let L=0;L<t.length;L++)k.registerUniform(`sizeInConcatAxis${L}`,"u32");return k.declareVariables(...c,_)})()}

  ${o0(o.length,T)}

  ${k.mainStart()}
    ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

    var indices = ${_.offsetToIndices("global_idx")};

    let inputIndex = calculateInputIndex(${y});
    if (inputIndex != 0u) {
      let sizeInConcatAxis = array<u32, ${o.length}u>(${T});
      ${y} -= sizeInConcatAxis[inputIndex - 1u];
    }

    ${l0(c,_)}
  }`;return{name:"Concat",shaderCache:{hint:`${s}`,inputDependencies:d},getRunData:()=>({outputs:[{dims:n,dataType:i}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:g}),getShaderSource:b}},Ob=(t,s)=>{let n=t.inputs,i=n[0].dims,l=Ne.normalizeAxis(s.axis,i.length);i0(n,l);let o=i.slice();o[l]=n.reduce((p,d)=>p+(d.dims.length>l?d.dims[l]:0),0);let c=n.filter(p=>Ne.size(p.dims)>0);t.compute(u0(c,l,o,n[0].dataType),{inputs:c})},kb=t=>An({axis:t.axis})}),wc,bc,Tc,Y_,Ec=ot(()=>{Bt(),qt(),wc=(t,s,n="f32")=>{switch(t.activation){case"Relu":return`value = max(value, ${s}(0.0));`;case"Sigmoid":return`value = (${s}(1.0) / (${s}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${s}(${n}(uniforms.clip_min)), ${s}(${n}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${s}(0.0), min(${s}(1.0), ${n}(uniforms.alpha) * value + ${n}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${n}(uniforms.alpha) * value, value, value >= ${s}(0.0));`;case"Tanh":return`let e2x = exp(-2.0 * abs(value));
              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);
        `;case"":return"";default:throw new Error(`Unsupported activation ${t.activation}`)}},bc=(t,s)=>{t.activation==="Clip"?s.push({type:1,data:t.clipMax},{type:1,data:t.clipMin}):t.activation==="HardSigmoid"?s.push({type:1,data:t.alpha},{type:1,data:t.beta}):t.activation==="LeakyRelu"&&s.push({type:1,data:t.alpha})},Tc=(t,s)=>{t.activation==="Clip"?s.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):t.activation==="HardSigmoid"?s.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):t.activation==="LeakyRelu"&&s.push({name:"alpha",type:"f32"})},Y_=t=>{let s=(t==null?void 0:t.activation)||"";if(s==="HardSigmoid"){let[n,i]=(t==null?void 0:t.activation_params)||[.2,.5];return{activation:s,alpha:n,beta:i}}else if(s==="Clip"){let[n,i]=(t==null?void 0:t.activation_params)||[lw,uw];return{activation:s,clipMax:i,clipMin:n}}else if(s==="LeakyRelu"){let[n]=(t==null?void 0:t.activation_params)||[.01];return{activation:s,alpha:n}}return{activation:s}}}),Wr,Db,Z_=ot(()=>{Wr=(t,s)=>{switch(t){case 1:return s;case 2:return`vec2<${s}>`;case 3:return`vec3<${s}>`;case 4:return`vec4<${s}>`;default:throw new Error(`${t}-component is not supported.`)}},Db=t=>`
      ${t?"value = value + getBiasByOutputCoords(coords);":""}
      `}),Ib,Yx=ot(()=>{Ib=t=>`
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    i32(${t}.x), i32(${t}.y), i32(${t}.z), 1));
}
`}),jp,J_,eg=ot(()=>{Bt(),qt(),Xt(),Ec(),jp=(t,s,n,i,l)=>{let o=i-n;return`
      ${Array.from({length:n}).map((c,p)=>`
      if (${xt(s.shape,p,s.rank)} != 1) {
        ${s.indicesSet(t,p,xt(l,p+o,i))}
      } else {
        ${s.indicesSet(t,p,0)}
      }`).join("")}
`},J_=(t,s,n,i,l=!1,o)=>{let c=t[0].dims,p=t[1].dims,d=c[c.length-2],f=p[p.length-1],g=c[c.length-1],_=nr(f),y=nr(g),T=nr(d),b=Ne.size(n)/_/T,k=t.length>2,L=i?i.slice(0,-2):n.slice(0,-2),C=[Ne.size(L),d,f],S=[{type:12,data:b},{type:12,data:d},{type:12,data:f},{type:12,data:g}];bc(s,S),S.push(...Ct(L,c,p)),k&&S.push(...Ct(t[2].dims)),S.push(...Ct(C));let I=O=>{let x=K_("batch_dims",t[0].dataType,L.length),E=Ke("a",t[0].dataType,c.length,y),A=Ke("b",t[1].dataType,p.length,_),F=Tt("output",t[0].dataType,C.length,_),K=zr(F.type.tensor),X=wc(s,F.type.value,K),oe=[E,A],ie="";if(k){let ne=l?_:1;oe.push(Ke("bias",t[2].dataType,t[2].dims.length,ne)),ie=`${l?`value += bias[col / ${ne}];`:`value += ${F.type.value}(bias[row + i]);`}`}let J=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Tc(s,J);let ue=()=>{let ne=`var a_data: ${E.type.value};`;for(let G=0;G<y;G++)ne+=`
              let b_data${G} = b[(b_offset + (k + ${G}) * uniforms.N + col) / ${_}];`;for(let G=0;G<T;G++){ne+=`a_data = a[(a_offset + (row + ${G}) * uniforms.K + k) / ${y}];`;for(let se=0;se<y;se++)ne+=`
            values[${G}] = fma(${A.type.value}(a_data${y===1?"":`[${se}]`}), b_data${se}, values[${G}]);
`}return ne};return`
  ${O.registerUniforms(J).registerInternalVariables(x).declareVariables(...oe,F)}
  ${O.mainStart()}
    ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let col = (global_idx % (uniforms.N / ${_})) * ${_};
    var index1 = global_idx / (uniforms.N / ${_});
    let stride1 = uniforms.M / ${T};
    let row = (index1 % stride1) * ${T};
    let batch = index1 / stride1;

    ${n.length===2?"":`let batch_indices = ${x.offsetToIndices("batch")};`}

    var a_indices: ${E.type.indices};
    ${jp("a_indices",E,E.rank-2,x.rank,"batch_indices")}
    ${E.indicesSet("a_indices",E.rank-2,0)}
    ${E.indicesSet("a_indices",E.rank-1,0)}
    let a_offset = ${E.indicesToOffset("a_indices")};

    var b_indices: ${A.type.indices};
    ${jp("b_indices",A,A.rank-2,x.rank,"batch_indices")}
    ${A.indicesSet("b_indices",A.rank-2,0)}
    ${A.indicesSet("b_indices",A.rank-1,0)}
    let b_offset = ${A.indicesToOffset("b_indices")};
    var values: array<${F.type.value}, ${T}>;
    for (var k: u32 = 0u; k < uniforms.K; k = k + ${y}) {
      ${ue()}
    }
    for (var i = 0u; i < ${T}u; i++) {
      var value = values[i];
      ${ie}
      ${X}
      let cur_indices = ${F.type.indices}(batch, row + i, col);
      let offset = ${F.indicesToOffset("cur_indices")};
      ${F.setByOffset(`offset / ${_}`,"value")};
    }
  }
  `};return{name:"MatMulNaive",shaderCache:{hint:`${s.activation};${_};${y};${T};${l}`,inputDependencies:k?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:o?o(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(b/64)},programUniforms:S}),getShaderSource:I}}}),c0,d0,E_,Bm,f0,S_,p0,qh,tg=ot(()=>{Bt(),qt(),Xt(),Ec(),eg(),Z_(),c0=(t,s)=>t?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol${s?", batchIndices":""});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol${s?", batchIndices":""});
        `,d0=(t,s)=>t?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${s===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${s===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${s===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`,E_=(t,s,n="f32",i,l=!1,o=32,c=!1,p=32)=>{let d=s[1]*t[1],f=s[0]*t[0],g=l?d:o,_=l?o:d,y=g/s[0],T=o/s[1];if(!((l&&y===4&&t[1]===4||!l&&(y===3||y===4))&&g%s[0]===0&&o%s[1]===0&&t[0]===4))throw new Error(`If transposeA ${l} is true, innerElementSize ${y} and workPerThread[1] ${t[1]} must be 4.
      Otherwise, innerElementSize ${y} must be 3 or 4.
  tileAWidth ${g} must be divisible by workgroupSize[0]${s[0]}. tileInner ${o} must be divisible by workgroupSize[1] ${s[1]}. colPerThread ${t[0]} must be 4.`);return`
var<workgroup> mm_Asub: array<array<vec${y}<${n}>, ${g/y}>, ${_}>;
var<workgroup> mm_Bsub: array<array<vec4<${n}>, ${f/t[0]}>, ${o}>;

const rowPerThread = ${t[1]};
const colPerThread = ${t[0]};
const innerElementSize = ${y};
const tileInner = ${o};

@compute @workgroup_size(${s[0]}, ${s[1]}, ${s[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = localRow * rowPerThread;
  let tileCol = i32(localId.x);

  let globalRow =i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x);
  let batch = ${c?"0":"i32(globalId.z)"};
  ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
  let globalRowStart = i32(workgroupId.y) * ${d};

  let num_tiles = ${c?`${Math.ceil(p/o)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
  var kStart = ${c?`i32(globalId.z) * ${p}`:"0"};

  var acc: array<vec4<${n}>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${T};
  for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${c0(l,i)}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${T}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${i?", batchIndices":""});
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${y===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${d0(l,y)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`},Bm=(t,s)=>t?`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol${s?", batchIndices":""});
            `:`
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol${s?", batchIndices":""});
            `,f0=t=>t?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",S_=(t,s,n="f32",i,l=!1,o=32,c=!1,p=32,d=!1)=>{let f=t[1]*s[1],g=t[0]*s[0],_=l?f:o,y=l?o:f;if(!(y%s[1]===0&&_%s[0]===0&&o%s[1]===0))throw new Error(`tileAHight ${y} must be divisible by workgroupSize[1]${s[1]}, tileAWidth ${_} must be divisible by workgroupSize[0]${s[0]}, tileInner ${o} must be divisible by workgroupSize[1]${s[1]}`);let T=y/s[1],b=_/s[0],k=o/s[1],L=d?`
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${f};
    let globalColStart = i32(workgroupId.x) * ${g};

    // Loop over shared dimension.
    for (var t = 0; t < num_tiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${y}; inputRow = inputRow + ${s[1]}) {
        for (var inputCol = localCol; inputCol < ${_}; inputCol = inputCol + ${s[0]}) {
          ${Bm(l,i)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${o}; inputRow = inputRow + ${s[1]}) {
            for (var inputCol = localCol; inputCol < ${g}; inputCol = inputCol + ${s[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol${i?", batchIndices":""});
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<${n}, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${s[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${l?`mm_Asub[k][localRow + innerRow * ${s[1]}];`:`mm_Asub[localRow + innerRow * ${s[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${s[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${s[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    `:`
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${f};

let tileRowA = i32(localId.y) * ${T};
let tileColA = i32(localId.x) * ${b};
let tileRowB = i32(localId.y) * ${k};
// Loop over shared dimension.
for (var t = 0; t < num_tiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${T}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${b}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${Bm(l,i)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${k}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol${i?", batchIndices":""});
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<${n}, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${f0(l)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;return`
  var<workgroup> mm_Asub : array<array<${n}, ${_}>, ${y}>;
  var<workgroup> mm_Bsub : array<array<${n}, ${g}>, ${o}>;
  const rowPerThread = ${t[1]};
  const colPerThread = ${t[0]};
  const tileInner = ${o};

@compute @workgroup_size(${s[0]}, ${s[1]}, ${s[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${c?"0":"i32(globalId.z)"};
    ${i?`let batchIndices = ${i.offsetToIndices("u32(batch)")};`:""}
    let num_tiles = ${c?`${Math.ceil(p/o)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};
    var kStart = ${c?`i32(globalId.z) * ${p}`:"0"};

    var acc : array<array<${n}, colPerThread>, rowPerThread>;
    ${L}
  }
`},p0=(t,s,n,i,l=!1)=>{let[o,c,p,d]=i,f=zr(i[0].type.tensor);return`
    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${o.type.indices}) -> ${Wr(t,f)} {
      var value = ${Wr(t,f)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)
      {
        var aIndices: ${c.type.indices};
        ${jp("aIndices",c,c.rank-2,o.rank,"batchIndices")}
        ${c.indicesSet("aIndices",c.rank-2,"u32(row)")}
        ${c.indicesSet("aIndices",c.rank-1,"u32(colIn)")}
        value = ${c.getByIndices("aIndices")};
      }
      return value;
    }

    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${o.type.indices}) -> ${Wr(t,f)} {
      var value = ${Wr(t,f)}(0.0);
      let col = colIn * ${t};
      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)
      {
        var bIndices: ${p.type.indices};
        ${jp("bIndices",p,p.rank-2,o.rank,"batchIndices")}
        ${p.indicesSet("bIndices",p.rank-2,"u32(row)")}
        ${p.indicesSet("bIndices",p.rank-1,"u32(colIn)")}
        value = ${p.getByIndices("bIndices")};
      }
      return value;
    }

    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Wr(t,f)}) {
      let col = colIn * ${t};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {
        var value = valueIn;
        let coords = vec3<i32>(batch, row, colIn);
        ${s?`value = value + ${l?"bias[colIn]":`${Wr(t,f)}(bias[row])`};`:""}
        ${n}
        ${d.setByIndices("vec3<u32>(coords)","value")}
      }
    }
    `},qh=(t,s,n,i,l=!1,o)=>{let c=t[0].dims,p=t[1].dims,d=c.slice(0,-2),f=p.slice(0,-2),g=i?i.slice(0,-2):n.slice(0,-2),_=Ne.size(g),y=c[c.length-2],T=c[c.length-1],b=p[p.length-1],k=T%4===0&&b%4===0,L=y<=8?[4,1,1]:[4,4,1],C=[8,8,1],S=[Math.ceil(b/C[0]/L[0]),Math.ceil(y/C[1]/L[1]),Math.ceil(_/C[2]/L[2])],I=k?4:1,O=[...d,y,T/I],x=O.length,E=[...f,T,b/I],A=E.length,F=[_,y,b/I],K=[{type:6,data:y},{type:6,data:b},{type:6,data:T}];bc(s,K),K.push(...Ct(g,O,E));let X=["rank","rank"],oe=t.length>2;oe&&(K.push(...Ct(t[2].dims)),X.push("rank")),K.push(...Ct(F));let ie=J=>{let ue=g.length,ne=K_("batchDims",t[0].dataType,ue,1),G=zr(t[0].dataType),se=Ke("a",t[0].dataType,x,I),ce=Ke("b",t[1].dataType,A,I),ge=Tt("result",t[0].dataType,F.length,I),W=[se,ce];if(oe){let re=l?I:1;W.push(Ke("bias",t[2].dataType,t[2].dims.length,re))}let U=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Tc(s,U);let B=zr(ge.type.tensor),Q=wc(s,ge.type.value,B),le=p0(I,oe,Q,[ne,se,ce,ge],l);return`
  ${J.registerUniforms(U).registerInternalVariables(ne).declareVariables(...W,ge)}
  ${le}
  ${k?E_(L,C,G,ne):S_(L,C,G,ne)}
                   `};return{name:"MatMul",shaderCache:{hint:`${L};${s.activation};${k};${l}`,inputDependencies:X},getRunData:()=>({outputs:[{dims:o?o(n):n,dataType:t[0].dataType}],dispatchGroup:{x:S[0],y:S[1],z:S[2]},programUniforms:K}),getShaderSource:ie}}}),h0,zb,Zx=ot(()=>{Bt(),qo(),Xt(),Ec(),Z_(),Yx(),tg(),h0=(t,s,n,i,l=!1,o,c=4,p=4,d=4,f="f32")=>{let g=K=>{switch(K){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${f}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${K} is not supported.`)}},_=K=>{switch(K){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${K} is not supported.`)}},y=t?`
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    `:`
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `,T=t?`
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    `:`
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `,b=t?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",k=t?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",L=t?"row":"col",C=t?"col":"row",S=`
    let inChannels = i32(uniforms.w_shape[2]);
    let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
    let outRow = ${L} / outWidth;
    let outCol = ${L} % outWidth;

    let WRow = ${C} / (i32(uniforms.w_shape[1]) * inChannels);
    let WCol = ${C} / inChannels % i32(uniforms.w_shape[1]);
    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
    let xCh = ${C} % inChannels;
    var resData = ${Wr(c,f)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${b} && xCol >= 0 && xCol < ${k}) {
      ${y}
      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));
      ${g(c)}
    }
    return resData;`,I=t?s&&i?`
    let col = colIn * ${c};
    ${S}`:`
    let col = colIn * ${c};
    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {
      ${S}
    }
    return ${Wr(c,f)}(0.0);`:i&&n?`
    let col = colIn * ${c};
    ${S}`:`
    let col = colIn * ${c};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${S}
    }
    return ${Wr(c,f)}(0.0);`,O=t?i&&n?_(p):`
    let col = colIn * ${p};
    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {
      ${_(p)}
    }
    return ${Wr(p,f)}(0.0);`:`
    let col = colIn * ${p};
    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {
      ${_(p)}
    }
    return ${Wr(p,f)}(0.0);`,x=Wr(d,f),E=Wr(t?c:p,f),A=Wr(t?p:c,f),F=wc(o,x,f);return`
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${E} {
      ${t?I:O}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${A} {
      ${t?O:I}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${x}) {
      let col = colIn * ${d};
      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)
      {
      var value = valueIn;
      let outWidth = ${t?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};
      ${T}
      ${Db(l)}
      ${F}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`},zb=(t,s,n,i,l,o,c,p,d)=>{let f=s.format==="NHWC",g=f?t[0].dims[3]:t[0].dims[1],_=n[0],y=f?n[2]:n[3],T=f?n[1]:n[2],b=f?n[3]:n[1],k=f&&(g%4===0||g%3===0)&&b%4===0,L=f?b:y*T,C=f?y*T:b,S=[8,8,1],I=i<=8?[4,1,1]:[4,4,1],O=[Math.ceil(L/S[0]/I[0]),Math.ceil(C/S[1]/I[1]),Math.ceil(_/S[2]/I[2])];dn("verbose",()=>`[conv2d_mm_webgpu] dispatch = ${O}`);let x=k?f&&g%4!==0?3:4:1,E=S[1]*I[1],A=S[0]*I[0],F=Math.max(S[0]*x,S[1]),K=i%E===0,X=l%A===0,oe=o%F===0,ie=k?[x,4,4]:[1,1,1],J=[{type:6,data:i},{type:6,data:l},{type:6,data:o},{type:6,data:[s.pads[0],s.pads[1]]},{type:6,data:s.strides},{type:6,data:s.dilations}];bc(s,J),J.push(...Ct(t[0].dims,t[1].dims));let ue=["rank","rank"];c&&(J.push(...Ct(t[2].dims)),ue.push("rank")),J.push(...Ct(n));let ne=G=>{let se=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Tc(s,se);let ce=k?4:1,ge=zr(t[0].dataType),W=`
      fn setOutputAtIndex(flatIndex : i32, value : ${k?`vec4<${ge}>`:ge}) {
        result[flatIndex] = ${k?`vec4<${ge}>`:ge}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${k?`vec4<${ge}>`:ge}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${k?"/ 4":""}, value);
      }`,U=Ke("x",t[0].dataType,t[0].dims.length,x===3?1:x),B=Ke("w",t[1].dataType,t[1].dims.length,ce),Q=[U,B],le=Tt("result",t[0].dataType,n.length,ce);if(c){let re=Ke("bias",t[2].dataType,t[2].dims.length,ce);Q.push(re),W+=`
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${k?`vec4<${ge}>`:ge} {
          return bias[coords.${f?"w":"y"}${k?"/ 4":""}];
        }`}return`
        ${Ib("uniforms.result_strides")}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${G.registerUniforms(se).declareVariables(...Q,le)}
        ${W}
        ${h0(f,K,X,oe,c,s,ie[0],ie[1],ie[2],ge)}
        ${k?E_(I,S,ge,void 0,!f,F):S_(I,S,ge,void 0,!f,F,!1,void 0,p)}`};return{name:"Conv2DMatMul",shaderCache:{hint:`${s.cacheKey};${x};${k};${K};${X};${oe};${E};${A};${F}`,inputDependencies:ue},getRunData:()=>({outputs:[{dims:d?d(n):n,dataType:t[0].dataType}],dispatchGroup:{x:O[0],y:O[1],z:O[2]},programUniforms:J}),getShaderSource:ne}}}),m0,Rm,Op,_0,Nm,g0,Fb,Lb,Jx=ot(()=>{Bt(),qo(),qt(),Xt(),Ec(),Z_(),m0=t=>{let s=1;for(let n=0;n<t.length;n++)s*=t[n];return s},Rm=t=>typeof t=="number"?[t,t,t]:t,Op=(t,s)=>s<=1?t:t+(t-1)*(s-1),_0=(t,s,n,i=1)=>{let l=Op(s,i);return Math.floor((t[0]*(n-1)-n+l)/2)},Nm=(t,s,n,i,l)=>{l==null&&(l=_0(t,s[0],i[0]));let o=[0,0,0,n];for(let c=0;c<3;c++)t[c]+2*l>=s[c]&&(o[c]=Math.trunc((t[c]-s[c]+2*l)/i[c]+1));return o},g0=(t,s,n,i,l,o,c,p,d,f)=>{let g,_,y,T;if(t==="VALID"&&(t=0),typeof t=="number"){g={top:t,bottom:t,left:t,right:t,front:t,back:t};let b=Nm([s,n,i,1],[p,d,f],1,[l,o,c],t);_=b[0],y=b[1],T=b[2]}else if(Array.isArray(t)){if(!t.every((k,L,C)=>k===C[0]))throw Error(`Unsupported padding parameter: ${t}`);g={top:t[0],bottom:t[1],left:t[2],right:t[3],front:t[4],back:t[5]};let b=Nm([s,n,i,1],[p,d,f],1,[l,o,c],t[0]);_=b[0],y=b[1],T=b[2]}else if(t==="SAME_UPPER"){_=Math.ceil(s/l),y=Math.ceil(n/o),T=Math.ceil(i/c);let b=(_-1)*l+p-s,k=(y-1)*o+d-n,L=(T-1)*c+f-i,C=Math.floor(b/2),S=b-C,I=Math.floor(k/2),O=k-I,x=Math.floor(L/2),E=L-x;g={top:I,bottom:O,left:x,right:E,front:C,back:S}}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:g,outDepth:_,outHeight:y,outWidth:T}},Fb=(t,s,n,i,l,o=!1,c="channelsLast")=>{let p,d,f,g,_;if(c==="channelsLast")[p,d,f,g,_]=t;else if(c==="channelsFirst")[p,_,d,f,g]=t;else throw new Error(`Unknown dataFormat ${c}`);let[y,,T,b,k]=s,[L,C,S]=Rm(n),[I,O,x]=Rm(i),E=Op(T,I),A=Op(b,O),F=Op(k,x),{padInfo:K,outDepth:X,outHeight:oe,outWidth:ie}=g0(l,d,f,g,L,C,S,E,A,F),J=o?y*_:y,ue=[0,0,0,0,0];return c==="channelsFirst"?ue=[p,J,X,oe,ie]:c==="channelsLast"&&(ue=[p,X,oe,ie,J]),{batchSize:p,dataFormat:c,inDepth:d,inHeight:f,inWidth:g,inChannels:_,outDepth:X,outHeight:oe,outWidth:ie,outChannels:J,padInfo:K,strideDepth:L,strideHeight:C,strideWidth:S,filterDepth:T,filterHeight:b,filterWidth:k,effectiveFilterDepth:E,effectiveFilterHeight:A,effectiveFilterWidth:F,dilationDepth:I,dilationHeight:O,dilationWidth:x,inShape:t,outShape:ue,filterShape:s}},Lb=(t,s,n,i,l,o)=>{let c=o==="channelsLast";c?t[0].dims[3]:t[0].dims[1];let p=[64,1,1],d={x:n.map((L,C)=>C)},f=[Math.ceil(m0(d.x.map(L=>n[L]))/p[0]),1,1];dn("verbose",()=>`[conv3d_naive_webgpu] dispatch = ${f}`);let g=1,_=Ne.size(n),y=[{type:12,data:_},{type:12,data:i},{type:12,data:l},{type:12,data:s.strides},{type:12,data:s.dilations}];bc(s,y),y.push(...Ct(t[0].dims,t[1].dims));let T=["rank","rank"],b=t.length===3;b&&(y.push(...Ct(t[2].dims)),T.push("rank")),y.push(...Ct(n));let k=L=>{let C=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:i.length},{name:"pads",type:"u32",length:l.length},{name:"strides",type:"u32",length:s.strides.length},{name:"dilations",type:"u32",length:s.dilations.length}];Tc(s,C);let S=1,I=zr(t[0].dataType),O=Ke("x",t[0].dataType,t[0].dims.length,g),x=Ke("W",t[1].dataType,t[1].dims.length,S),E=[O,x],A=Tt("result",t[0].dataType,n.length,S),F="";if(b){let oe=Ke("bias",t[2].dataType,t[2].dims.length,S);E.push(oe),F+=`
        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${I} {
          return bias[${c?xt("coords",4,5):xt("coords",1,5)}];
        }`}let K=Wr(g,I),X=wc(s,K,I);return`
            ${F}
            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${O.getByIndices("aIndices")};
            }
            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {
              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);
              return ${x.getByIndices("aIndices")};
            }
          ${L.registerUniforms(C).declareVariables(...E,A)}
          ${L.mainStart()}
          ${L.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
              let coords = ${A.offsetToIndices("global_idx")};
              let batch = ${xt("coords",0,O.rank)};
              let d2 = ${c?xt("coords",O.rank-1,O.rank):xt("coords",1,O.rank)};
              let xFRCCorner = vec3<u32>(${c?xt("coords",1,O.rank):xt("coords",2,O.rank)},
              ${c?xt("coords",2,O.rank):xt("coords",3,O.rank)},
              ${c?xt("coords",3,O.rank):xt("coords",4,O.rank)}) * uniforms.strides - uniforms.pads;
              let xFCorner = xFRCCorner.x;
              let xRCorner = xFRCCorner.y;
              let xCCorner = xFRCCorner.z;
              let xShapeY = ${c?xt("uniforms.x_shape",1,O.rank):xt("uniforms.x_shape",2,O.rank)};
              let xShapeZ = ${c?xt("uniforms.x_shape",2,O.rank):xt("uniforms.x_shape",3,O.rank)};
              let xShapeW = ${c?xt("uniforms.x_shape",3,O.rank):xt("uniforms.x_shape",4,O.rank)};
              let xShapeU = ${c?xt("uniforms.x_shape",4,O.rank):xt("uniforms.x_shape",1,O.rank)};
              let inputDepthNearestVec4 = (xShapeU / 4) * 4;
              let inputDepthVec4Remainder = xShapeU % 4;

              var value = 0.0;
              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {
                let xF = xFCorner + wF * uniforms.dilations[0];
                if (xF < 0 || xF >= xShapeY) {
                  continue;
                }

                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {
                  let xR = xRCorner + wR * uniforms.dilations[1];
                  if (xR < 0 || xR >= xShapeZ) {
                    continue;
                  }

                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {
                    let xC = xCCorner + wC * uniforms.dilations[2];
                    if (xC < 0 || xC >= xShapeW) {
                      continue;
                    }

                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {
                      ${c?`let xValues = vec4<f32>(
                               getX(batch, xF, xR, xC, d1),
                               getX(batch, xF, xR, xC, d1 + 1),
                               getX(batch, xF, xR, xC, d1 + 2),
                               getX(batch, xF, xR, xC, d1 + 3));
                            `:`let xValues = vec4<f32>(
                               getX(batch, d1, xF, xR, xC),
                               getX(batch, d1 + 1, xF, xR, xC),
                               getX(batch, d1 + 2, xF, xR, xC),
                               getX(batch, d1 + 3, xF, xR, xC));
                            `}
                            let wValues = vec4<f32>(
                              getW(d2, d1, wF, wR, wC),
                              getW(d2, d1 + 1, wF, wR, wC),
                              getW(d2, d1 + 2, wF, wR, wC),
                              getW(d2, d1 + 3, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                    if (inputDepthVec4Remainder == 1) {
                        ${c?`value += getX(batch, xF, xR, xC, inputDepthNearestVec4)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`:`value += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                    } else if (inputDepthVec4Remainder == 2) {
                      ${c?`let xValues = vec2<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
                      `:`let xValues = vec2<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
                    `}
                    let wValues = vec2<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                      value += dot(xValues, wValues);
                    } else if (inputDepthVec4Remainder == 3) {
                      ${c?`let xValues = vec3<f32>(
                        getX(batch, xF, xR, xC, inputDepthNearestVec4),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
                      `:`let xValues = vec3<f32>(
                        getX(batch, inputDepthNearestVec4, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
                    `}
                    let wValues = vec3<f32>(
                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                      value += dot(xValues, wValues);
                    }
                  }
                }
              }
              ${b?"value = value + getBiasByOutputCoords(coords)":""};
              ${X}
              result[global_idx] = f32(value);
          }`};return{name:"Conv3DNaive",shaderCache:{hint:`${s.cacheKey};${c};${g};${b}`,inputDependencies:T},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:f[0],y:f[1],z:f[2]},programUniforms:y}),getShaderSource:k}}}),Bb,Rb,eE=ot(()=>{Bt(),qt(),Xt(),Ec(),Bb=(t,s,n,i)=>{let l=t.length>2,o=l?"value += b[output_channel];":"",c=t[0].dims,p=t[1].dims,d=s.format==="NHWC",f=d?n[3]:n[1],g=f/s.group,_=d&&g>=4?nr(f):1,y=Ne.size(n)/_,T=[{type:12,data:y},{type:12,data:s.dilations},{type:12,data:[s.strides[0],s.strides[1]]},{type:12,data:[s.pads[0],s.pads[1]]},{type:12,data:g}];bc(s,T),T.push(...Ct(c,[p[0],p[1],p[2],p[3]/_]));let b=l?["rank","rank","rank"]:["rank","rank"];T.push(...Ct([n[0],n[1],n[2],n[3]/_]));let k=L=>{let C=Tt("output",t[0].dataType,n.length,_),S=zr(C.type.tensor),I=wc(s,C.type.value,S),O=Ke("x",t[0].dataType,c.length),x=Ke("w",t[1].dataType,p.length,_),E=[O,x];l&&E.push(Ke("b",t[2].dataType,t[2].dims,_));let A=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:s.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Tc(s,A);let F=d?`
      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {
            let input_channel = in_channel_offset + wInChannel;
            let xVal = ${O.get("batch","xHeight","xWidth","input_channel")};
            let wVal = ${x.get("wHeight","wWidth","wInChannel","output_channel")};
            value += xVal * wVal;
          }
        }
      }
      `:`
      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {
        let input_channel = in_channel_offset + wInChannel;
        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {
          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];

          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {
            continue;
          }

          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {
            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];
            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {
              continue;
            }

            let xVal = ${O.get("batch","input_channel","xHeight","xWidth")};
            let wVal = ${x.get("output_channel","wInChannel","wHeight","wWidth")};
            value += xVal * wVal;
          }
        }
      }
      `;return`
  ${L.registerUniforms(A).declareVariables(...E,C)}

  ${L.mainStart()}
    ${L.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let outputIndices = ${C.offsetToIndices("global_idx")};
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${d?3:1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${d?1:2}], outputIndices[${d?2:3}]) * uniforms.strides - uniforms.pads;
    let group_id: u32 = output_channel * ${_} / uniforms.output_channels_per_group;
    var in_channel_offset = group_id * uniforms.w_shape[${d?2:1}];

    var value: ${C.type.value} = ${C.type.value}(0);
    ${F}
    ${o}
    ${I}
    ${C.setByOffset("global_idx","value")}
  }`};return{name:"GroupedConv",shaderCache:{hint:`${s.cacheKey}_${_}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:T}),getShaderSource:k}},Rb=(t,s,n,i)=>{let l=t.length>2,o=nr(n[3]),c=nr(n[2]),p=Ne.size(n)/o/c,d=[t[0].dims[0],t[0].dims[1],t[0].dims[2],t[0].dims[3]/o],f=[t[1].dims[0],t[1].dims[1],t[1].dims[2],t[1].dims[3]/o],g=[n[0],n[1],n[2],n[3]/o],_=[{type:12,data:p},{type:6,data:[s.strides[0],s.strides[1]]},{type:6,data:[s.pads[0],s.pads[1]]}];bc(s,_),_.push(...Ct(d,f,g));let y=(c-1)*s.strides[1]+f[1],T=b=>{let k=Tt("output",t[0].dataType,g.length,o),L=zr(k.type.tensor),C=wc(s,k.type.value,L),S=Ke("x",t[0].dataType,d.length,o),I=Ke("w",t[1].dataType,f.length,o),O=[S,I];l&&O.push(Ke("b",t[2].dataType,t[2].dims,o));let x=l?"value += b[output_channel];":"",E=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Tc(s,E),`
  ${b.registerUniforms(E).declareVariables(...O,k)}
  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let width0 = uniforms.output_shape[3];
    let output_channel = global_idx % width0;
    var index1 = global_idx / width0;
    let width1 = uniforms.output_shape[2] / ${c}u;
    let col = (index1 % width1) * ${c}u;
    index1 = index1 / width1;
    let row = index1 % uniforms.output_shape[1];
    let batch = index1 / uniforms.output_shape[1];

    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;

    var x_vals: array<${S.type.value}, ${y}>;
    var values: array<${k.type.value}, ${c}>;
    let input_channel = output_channel;
    // Use constant instead of uniform can give better performance for w's height/width.
    for (var w_height: u32 = 0u; w_height < ${f[0]}; w_height++) {
      let x_height = x_corner.x + i32(w_height);
      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {
        for (var i = 0; i < ${y}; i++) {
          let x_width = x_corner.y + i;
          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {
            x_vals[i] = ${S.get("batch","u32(x_height)","u32(x_width)","input_channel")};
          } else {
            x_vals[i] = ${S.type.value}(0);
          }
        }
        for (var w_width: u32 = 0u; w_width < ${f[1]}; w_width++) {
          let w_val = ${I.get("w_height","w_width","0","output_channel")};
          for (var i = 0u; i < ${c}u; i++) {
            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);
          }
        }
      }
    }

    for (var i = 0u; i < ${c}u; i++) {
      var value = values[i];
      ${x}
      ${C}
      ${k.set("batch","row","col + i","output_channel","value")};
    }
  }`};return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${s.cacheKey};${o};${c};${y};${f[0]};${f[1]}`,inputDependencies:l?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:i?i(n):n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:_}),getShaderSource:T}}}),y0,kh,M0,Dh,C_,jm,v0,w0,P_,tE=ot(()=>{qt(),Zx(),Jx(),tg(),eE(),Ec(),eg(),au(),y0=(t,s,n,i,l,o)=>{let c=t[0],p=t.slice(o?1:2,o?3:4),d=p.length,f=s[0],g=s.slice(2).map((y,T)=>y+(y-1)*(n[T]-1)),_=p.map((y,T)=>y+i[T]+i[T+d]).map((y,T)=>Math.floor((y-g[T]+l[T])/l[T]));return _.splice(0,0,c),_.splice(o?3:1,0,f),_},kh=[2,3,1,0],M0=(t,s)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length>5)throw new Error("greater than 5D is not supported");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[s.format==="NHWC"?t[0].dims.length-1:1],i=t[1].dims[1]*s.group;if(n!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(t.length===3&&(t[2].dims.length!==1||t[1].dims[0]!==t[2].dims[0]))throw new Error("invalid bias");let l=t[0].dims.length-2;if(s.dilations.length!==l)throw new Error(`dilations should be ${l}D`);if(s.strides.length!==l)throw new Error(`strides should be ${l}D`);if(s.pads.length!==l*2)throw new Error(`pads should be ${l*2}D`);if(s.kernelShape.length!==0&&s.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape")},Dh=(t,s)=>{let n=t.kernelShape.slice();n.length<s[1].dims.length-2&&n.push(...Array(s[1].dims.length-2-n.length).fill(0));for(let o=2;o<s[1].dims.length;++o)n[o-2]===0&&(n[o-2]=s[1].dims[o]);let i=t.pads.slice();Hh.adjustPadsBasedOnAutoPad(s[0].dims,t.strides,t.dilations,n,i,t.format==="NHWC",t.autoPad);let l=Object.assign({},t);return Object.assign(l,{kernelShape:n,pads:i}),l},C_=t=>{let s=Y_(t),n=t.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],l=t.dilations,o=t.group,c=t.kernel_shape,p=t.pads,d=t.strides,f=t.w_is_const();return{autoPad:i,format:n,dilations:l,group:o,kernelShape:c,pads:p,strides:d,wIsConst:f,...s,cacheKey:`${t.format};${s.activation};`}},jm=(t,s,n,i)=>{let l=n.format==="NHWC",o=y0(s[0].dims,s[1].dims,n.dilations,n.pads,n.strides,l);if(n.group!==1){let E=[s[0]];if(l){let A=t.kernelCustomData.wT??t.compute(_a(s[1],kh),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=A),E.push(A)}else E.push(s[1]);s.length===3&&E.push(s[2]),!t.adapterInfo.isArchitecture("ampere")&&l&&s[1].dims[0]===n.group&&s[1].dims[1]===1&&n.dilations[0]===1&&n.dilations[1]===1?t.compute(Rb(E,n,o,i),{inputs:E}):t.compute(Bb(E,n,o,i),{inputs:E});return}let c=s.length===3,p=s[0].dims[l?1:2],d=s[0].dims[l?2:3],f=s[0].dims[l?3:1],g=s[1].dims[2],_=s[1].dims[3],y=o[l?1:2],T=o[l?2:3],b=o[l?3:1],k=l&&g===p&&_===d&&n.pads[0]===0&&n.pads[1]===0;if(k||g===1&&_===1&&n.dilations[0]===1&&n.dilations[1]===1&&n.strides[0]===1&&n.strides[1]===1&&n.pads[0]===0&&n.pads[1]===0){let E=o[0],A,F,K,X=[];if(l){let J=t.kernelCustomData.wT??t.compute(_a(s[1],kh),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];if(n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=J),k){let ue=p*d*f;A=s[0].reshape([1,E,ue]),F=J.reshape([1,ue,b]),K=[1,E,b]}else A=s[0].reshape([E,p*d,f]),F=J.reshape([1,f,b]),K=[E,y*T,b];X.push(A),X.push(F)}else A=s[0].reshape([E,f,p*d]),F=s[1].reshape([1,b,f]),K=[E,b,y*T],X.push(F),X.push(A);c&&X.push(s[2]);let oe=K[2],ie=X[0].dims[X[0].dims.length-1];oe<8&&ie<8?t.compute(J_(X,n,o,K,l,i),{inputs:X}):t.compute(qh(X,n,o,K,l,i),{inputs:X});return}let L=!0,C=t.kernelCustomData.wT??t.compute(_a(s[1],kh),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=C);let S=[s[0],C];c&&S.push(s[2]);let I=l?y*T:b,O=l?b:y*T,x=g*_*f;t.compute(zb(S,n,o,I,O,x,c,L,i),{inputs:S})},v0=(t,s)=>{let n=s.format==="NHWC",i=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&i.push(t.inputs[2]);let l=[0,s.pads[0],0,s.pads[1]],o=[1].concat(s.strides),c=[1].concat(s.dilations),p=[1].concat(s.kernelShape),d=Dh({...s,pads:l,strides:o,dilations:c,kernelShape:p},i);jm(t,i,d,f=>n?[f[0],f[2],f[3]]:[f[0],f[1],f[3]])},w0=(t,s,n)=>{let i=n.format==="NHWC"?"channelsLast":"channelsFirst",l=Dh(n,s),o=n.autoPad==="NOTSET"?n.pads:n.autoPad,c=Fb(s[0].dims,s[1].dims,n.strides,n.dilations,o,!1,i);t.compute(Lb(s,l,c.outShape,[c.filterDepth,c.filterHeight,c.filterWidth],[c.padInfo.front,c.padInfo.top,c.padInfo.left],i))},P_=(t,s)=>{if(M0(t.inputs,s),t.inputs[0].dims.length===3)v0(t,s);else if(t.inputs[0].dims.length===5)w0(t,t.inputs,s);else{let n=Dh(s,t.inputs);jm(t,t.inputs,n)}}}),Nb,nE=ot(()=>{Bt(),qo(),qt(),Xt(),Nb=(t,s,n)=>{let i=t.length>2,l=s.outputShape,o=s.format==="NHWC",c=s.group,p=t[1].dims,d=p[2]/c,f=p[3],g=o?nr(d):1,_=o&&f===1&&d>=4,y=_?Math.floor(d/4)*4:Math.floor(d/g)*g,T=d-y,b=o?nr(f):1,k=o?f===1?g:b:1,L=Ne.size(l)/b,C=[Math.ceil(L/64),1,1];dn("verbose",()=>`[conv2d_backprop_webgpu] dispatch = ${C}`);let S=["rank","rank"],I=[s.strides[0],s.strides[1]],O=[s.kernelShape[o?1:2],s.kernelShape[o?2:3]],x=[s.dilations[0],s.dilations[1]],E=[O[0]+(s.dilations[0]<=1?0:(s.kernelShape[o?1:2]-1)*(s.dilations[0]-1)),O[1]+(s.dilations[1]<=1?0:(s.kernelShape[o?2:3]-1)*(s.dilations[1]-1))],A=[E[0]-1-Math.floor((s.pads[0]+s.pads[2])/2),E[1]-1-Math.floor((s.pads[1]+s.pads[3])/2)],F=[{type:12,data:L},{type:12,data:I},{type:12,data:O},{type:12,data:x},{type:12,data:E},{type:6,data:A},{type:12,data:y},{type:12,data:d},{type:12,data:f},...Ct(t[0].dims,t[1].dims)];i&&(F.push(...Ct(t[2].dims)),S.push("rank")),F.push(...Ct(l));let K=X=>{let oe=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:I.length},{name:"filter_dims",type:"u32",length:O.length},{name:"dilations",type:"u32",length:O.length},{name:"effective_filter_dims",type:"u32",length:E.length},{name:"pads",type:"i32",length:A.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],ie=zr(t[0].dataType),J=o?1:2,ue=o?2:3,ne=o?3:1,G=Ke("W",t[1].dataType,t[1].dims.length,k),se=Ke("Dy",t[0].dataType,t[0].dims.length,g),ce=[se,G];i&&ce.push(Ke("bias",t[2].dataType,[l[ne]].length,b));let ge=Tt("result",t[0].dataType,l.length,b),W=()=>{let Q="";if(_)g===4?Q+=`
        let xValue = ${se.getByOffset("x_offset")};
        let wValue = ${G.getByOffset("w_offset")};
        dotProd = dotProd + dot(xValue, wValue);
        x_offset += 1u;
        w_offset += 1u;`:g===2?Q+=`
          dotProd = dotProd + dot(vec4<${ie}>(${se.getByOffset("x_offset")}, ${se.getByOffset("x_offset + 1u")}), vec4<${ie}>(${G.getByOffset("w_offset")}, ${G.getByOffset("w_offset + 1u")}));
          x_offset += 2u;
          w_offset += 2u;`:g===1&&(Q+=`
          dotProd = dotProd + dot(vec4<${ie}>(${se.getByOffset("x_offset")}, ${se.getByOffset("x_offset + 1u")}, ${se.getByOffset("x_offset + 2u")}, ${se.getByOffset("x_offset + 3u")}), vec4<${ie}>(${G.getByOffset("w_offset")}, ${G.getByOffset("w_offset + 1u")}, ${G.getByOffset("w_offset + 2u")}, ${G.getByOffset("w_offset + 3u")}));
          x_offset += 4u;
          w_offset += 4u;`);else if(Q+=`
                  let xValue = ${o?se.getByOffset(`${se.indicesToOffset(`${se.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${g}`):se.get("batch","inputChannel","idyR","idyC")};
        `,g===1)Q+=`
          let w_offset = ${G.indicesToOffset(`${G.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};
          let wValue = ${G.getByOffset(`w_offset / ${k}`)};
          dotProd = dotProd + xValue * wValue;`;else for(let le=0;le<g;le++)Q+=`
            let wValue${le} = ${G.getByOffset(`${G.indicesToOffset(`${G.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${le}, wOutChannel)`)} / ${k}`)};
            dotProd = dotProd + xValue[${le}] * wValue${le};`;return Q},U=()=>{if(T===0)return"";if(!_)throw new Error(`packInputAs4 ${_} is not true.`);let Q="";if(g===1){Q+="dotProd = dotProd";for(let le=0;le<T;le++)Q+=`
            + ${se.getByOffset(`x_offset + ${le}`)} * ${G.getByOffset(`w_offset + ${le}`)}`;Q+=";"}else if(g===2){if(T!==2)throw new Error(`Invalid inputChannelsRemainder ${T}.`);Q+=`
          let xValue = ${se.getByOffset("x_offset")};
          let wValue = ${G.getByOffset("w_offset")};
          dotProd = dotProd + dot(xValue, wValue);`}return Q},B=`
            let outputIndices = ${ge.offsetToIndices(`global_idx * ${b}`)};
            let batch = ${ge.indicesGet("outputIndices",0)};
            let d1 = ${ge.indicesGet("outputIndices",ne)};
            let r = ${ge.indicesGet("outputIndices",J)};
            let c = ${ge.indicesGet("outputIndices",ue)};
            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;
            let dyRCorner = dyCorner.x;
            let dyCCorner = dyCorner.y;
            let groupId = d1 / uniforms.output_channels_per_group;
            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;
            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
            // ? = to be determined. : = across all values in that axis.
            var dotProd = ${ge.type.value}(0.0);
            var wR: u32 = 0;
            if (uniforms.dilations.x == 1) {
              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0
              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);
            }
            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {
              if (wR % uniforms.dilations.x != 0) {
                continue;
              }
              let dyR = (${ie}(dyRCorner) + ${ie}(wR)) / ${ie}(uniforms.strides[0]);
              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;
              if (dyR < 0.0 || dyR >= ${ie}(uniforms.Dy_shape[${J}]) || fract(dyR) > 0.0 ||
                  wRPerm < 0) {
                continue;
              }
              let idyR: u32 = u32(dyR);
              var wC: u32 = 0;
              if (uniforms.dilations.y == 1) {
                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0
                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);
              }
              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {
                if (wC % uniforms.dilations.y != 0) {
                  continue;
                }
                let dyC = (${ie}(dyCCorner) + ${ie}(wC)) / ${ie}(uniforms.strides.y);
                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;
                if (dyC < 0.0 || dyC >= ${ie}(uniforms.Dy_shape[${ue}]) ||
                    fract(dyC) > 0.0 || wCPerm < 0) {
                  continue;
                }
                let idyC: u32 = u32(dyC);
                var inputChannel = groupId * uniforms.input_channels_per_group;
                ${_?`
                var x_offset = ${se.indicesToOffset(`${se.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${g};
                var w_offset = ${G.indicesToOffset(`${G.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${k};
                  `:""}
                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${_?4:g}) {
                  ${W()}
                  inputChannel = inputChannel + ${_?4:g};
                }
                ${U()}
                wC = wC + uniforms.strides.y - 1;
              }
              wR = wR + uniforms.strides[0] - 1;
            }
            let value = dotProd${i?` + bias[d1 / ${b}]`:""};
            ${ge.setByOffset("global_idx","value")};
          `;return`
    ${X.registerUniforms(oe).declareVariables(...ce,ge)}
      ${X.mainStart()}
      ${X.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};
    ${B}}`};return{name:"ConvTranspose2D",shaderCache:{hint:`${s.cacheKey};${g}${k}${b}${_}${T}`,inputDependencies:S},getRunData:()=>({dispatchGroup:{x:C[0],y:C[1],z:C[2]},outputs:[{dims:n?n(l):l,dataType:t[0].dataType}],programUniforms:F}),getShaderSource:K}}}),b0,T0,x0,Um,jb,E0,Vm,S0,Ub,rE=ot(()=>{nE(),Ec(),au(),b0=(t,s,n,i,l,o)=>(t-1)*s+n+(i-1)*l+1-o,T0=(t,s,n,i,l)=>{let o=Math.floor(t/2);s==="SAME_UPPER"?(n[i]=o,n[l]=t-o):s==="SAME_LOWER"&&(n[i]=t-o,n[l]=o)},x0=(t,s,n,i,l,o,c,p,d,f)=>{let g=t.length-2,_=f.length===0;d.length<g&&d.push(...Array(g-d.length).fill(0));let y=t[0],T=s[p?3:1]*l;for(let b=0,k=t.length-g-(p?1:0);b<g;++b,++k){let L=t[k],C=_?L*c[b]:f[b],S=b0(L,c[b],o[b],s[k],n[b],C);T0(S,i,o,b,b+g),_&&f.push(c[b]*(L-1)+d[b]+(s[k]-1)*n[b]+1-o[b]-o[b+g])}f.splice(0,0,y),f.splice(p?3:1,0,T)},Um=(t,s)=>{let n=t.kernelShape.slice();if(t.kernelShape.length===0||t.kernelShape.reduce((_,y)=>_*y,1)===0){n.length=0;for(let _=2;_<s[1].dims.length;++_)n.push(s[1].dims[_])}let i=t.format==="NHWC";n.splice(0,0,s[1].dims[0]),n.splice(i?3:1,0,s[1].dims[1]);let l=t.pads.slice(),o=t.outputShape.slice(),c=t.outputPadding.slice(),p=s[0].dims,d=t.dilations.slice();if(d.reduce((_,y)=>_+y,0)===0){let _=s[0].dims.length-2;d=new Array(_).fill(1)}let f=t.strides.slice();if(f.reduce((_,y)=>_+y,0)===0){let _=s[0].dims.length-2;f=new Array(_).fill(1)}x0(p,n,d,t.autoPad,t.group,l,f,i,c,o);let g=Object.assign({},t);return Object.assign(g,{kernelShape:n,pads:l,outputPadding:c,outputShape:o,dilations:d,strides:f}),g},jb=t=>{let s=Y_(t),n=t.format,i=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof t.autoPad>"u"?0:t.autoPad],l=t.dilations,o=t.group,c=t.kernelShape,p=t.pads,d=t.strides,f=t.wIsConst(),g=t.outputPadding,_=t.outputShape;return{autoPad:i,format:n,dilations:l,group:o,kernelShape:c,outputPadding:g,outputShape:_,pads:p,strides:d,wIsConst:f,...s,cacheKey:`${t.format};${s.activation};`}},E0=(t,s)=>{if(!t||t.length!==2&&t.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(t[0].dims.length!==4&&t[0].dims.length!==3)throw new Error("currently only support 2-dimensional conv");if(t[0].dims.length!==t[1].dims.length)throw new Error("filter does not have same dimension as input");let n=t[0].dims[s.format==="NHWC"?t[0].dims.length-1:1],i=t[1].dims[0];if(n!==i)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let l=t[1].dims[1]*s.group;if(t.length===3&&(t[2].dims.length!==1||t[2].dims[0]!==l))throw new Error("invalid bias");let o=t[0].dims.length-2;if(s.dilations.reduce((c,p)=>c+p,0)>0&&s.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(s.strides.reduce((c,p)=>c+p,0)>0&&s.strides.length!==o)throw new Error(`strides should be ${o}D`);if(s.pads.reduce((c,p)=>c+p,0)>0&&s.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(s.outputPadding.length!==o&&s.outputPadding.length!==0)throw new Error(`output_padding should be ${o}D`);if(s.kernelShape.reduce((c,p)=>c+p,0)>0&&s.kernelShape.length!==0&&s.kernelShape.length!==t[1].dims.length-2)throw new Error("invalid kernel shape");if(s.outputShape.length!==0&&s.outputShape.length!==t[0].dims.length-2)throw new Error("invalid output shape")},Vm=(t,s,n,i)=>{let l=t.kernelCustomData.wT??t.compute(_a(s[1],[2,3,0,1]),{inputs:[1],outputs:[n.wIsConst?-2:-1]})[0];n.wIsConst&&!t.kernelCustomData.wT&&(t.kernelCustomData.wT=l);let o=[s[0],l];s.length===3&&o.push(s[2]),t.compute(Nb(o,n,i),{inputs:o})},S0=(t,s)=>{let n=s.format==="NHWC",i=[t.inputs[0].reshape(n?[t.inputs[0].dims[0],1,t.inputs[0].dims[1],t.inputs[0].dims[2]]:[t.inputs[0].dims[0],t.inputs[0].dims[1],1,t.inputs[0].dims[2]]),t.inputs[1].reshape([t.inputs[1].dims[0],t.inputs[1].dims[1],1,t.inputs[1].dims[2]])];t.inputs.length===3&&i.push(t.inputs[2]);let l=s.kernelShape;(l.length===0||l[0]===0)&&(l=[t.inputs[1].dims[2]]);let o=s.dilations;(o.length===0||o[0]===0)&&(o=[1]);let c=s.strides;(c.length===0||c[0]===0)&&(c=[1]);let p=s.pads;p.length===0&&(p=[0,0]),p=[0,p[0],0,p[1]],c=[1].concat(c),o=[1].concat(o),l=[1].concat(l);let d=s.outputPadding;d=[0].concat(d);let f=Um({...s,pads:p,strides:c,dilations:o,kernelShape:l,outputPadding:d},i);Vm(t,i,f,g=>n?[g[0],g[2],g[3]]:[g[0],g[1],g[3]])},Ub=(t,s)=>{if(E0(t.inputs,s),t.inputs[0].dims.length===3)S0(t,s);else{let n=Um(s,t.inputs);Vm(t,t.inputs,n)}}}),C0,Vb,Gb,sE=ot(()=>{Bt(),qt(),or(),Xt(),C0=(t,s,n,i)=>{let l=Ne.size(s),o=s.length,c=Ke("input",t,o),p=Tt("output",t,o),d=n.dataType===6?n.getInt32Array()[0]:Number(n.getBigInt64Array()[0]),f=Ne.normalizeAxis(d,o),g=_=>{let y=` i32(${c.indicesGet("inputIndices","uniforms.axis")}) `,T=xt("uniforms.input_shape","uniforms.axis",o),b=i.reverse?y+(i.exclusive?" + 1":""):"0",k=i.reverse?T:y+(i.exclusive?"":" + 1");return`
                ${_.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(c,p)}
                ${_.mainStart()}
                  ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
                  var inputIndices = ${p.offsetToIndices("global_idx")};
                  var sum = ${p.type.value}(0);
                  let first : i32 = ${b};
                  let last : i32 = ${k};
                  for (var i : i32 = first; i < last; i++) {
                    ${c.indicesSet("inputIndices","uniforms.axis","u32(i)")};
                    sum = sum + ${c.getByIndices("inputIndices")};
                  }
                  ${p.setByOffset("global_idx","sum")};
                }`};return{name:"CumSum",shaderCache:{hint:i.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:s,dataType:t}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:[{type:12,data:l},{type:12,data:f},...Ct(s,s)]}),getShaderSource:g}},Vb=(t,s)=>{let n=t.inputs[0].dims,i=t.inputs[0].dataType,l=t.inputs[1];t.compute(C0(i,n,l,s),{inputs:[0]})},Gb=t=>{let s=t.exclusive===1,n=t.reverse===1;return An({exclusive:s,reverse:n})}}),P0,A0,$0,Wb,Hb,aE=ot(()=>{Bt(),qt(),or(),Xt(),P0=t=>{if(!t||t.length!==1)throw new Error("DepthToSpace requires 1 input.");if(t[0].dims.length!==4)throw new Error("DepthToSpace requires 4D input.")},A0=(t,s,n,i)=>{let l=[];l.push(`fn perm(i: ${i.type.indices}) -> ${n.type.indices} {
    var a: ${n.type.indices};`);for(let o=0;o<s;++o)l.push(n.indicesSet("a",t[o],`i[${o}]`));return l.push("return a;}"),l.join(`
`)},$0=(t,s)=>{let n,i,l,o,c,p,d=s.format==="NHWC",f=s.blocksize,g=s.mode==="DCR";d?([n,i,l,o]=t.dims,c=g?[n,i,l,f,f,o/f**2]:[n,i,l,o/f**2,f,f],p=g?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([n,i,l,o]=[t.dims[0],t.dims[2],t.dims[3],t.dims[1]],c=g?[n,f,f,o/f**2,i,l]:[n,o/f**2,f,f,i,l],p=g?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let _=t.reshape(c),y=_.dims.length,T=t.dataType,b=Ke("a",T,y),k=Tt("output",T,y),L=C=>`
  ${C.registerUniform("output_size","u32").declareVariables(b,k)}

  ${A0(p,y,b,k)}

  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let indices = ${k.offsetToIndices("global_idx")};
    let aIndices = perm(indices);

    ${k.setByOffset("global_idx",b.getByIndices("aIndices"))}
  }`;return{name:"DepthToSpace",shaderCache:{hint:`${t.dims};${s.blocksize};${s.mode}`,inputDependencies:["rank"]},getRunData:C=>{let S=d?[n,i*f,l*f,o/f**2]:[n,o/f**2,i*f,l*f],I=Ne.size(S),O=_.dims,x=Ne.sortBasedOnPerm(O,p);return{outputs:[{dims:S,dataType:C[0].dataType}],dispatchGroup:{x:Math.ceil(I/64)},programUniforms:[{type:12,data:I},...Ct(O,x)]}},getShaderSource:L}},Wb=(t,s)=>{P0(t.inputs),t.compute($0(t.inputs[0],s))},Hb=t=>An({blocksize:t.blocksize,mode:t.mode,format:t.format})}),Ih,kp,Gm,O0,k0,D0,I0,Wm,z0,Kb,qb,iE=ot(()=>{Bt(),qt(),or(),Xt(),Ih="[a-zA-Z]|\\.\\.\\.",kp="("+Ih+")+",Gm="^"+kp+"$",O0="("+kp+",)*"+kp,k0="^"+O0+"$",D0=class{constructor(t=-1){this.symbolToIndices=new Map,this.inputIndex=t}addSymbol(t,s){let n=this.symbolToIndices.get(t);n===void 0?n=[s]:n.push(s),this.symbolToIndices.set(t,n)}},I0=class{constructor(t,s){var l;this.equation=s,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[n,i]=s.includes("->")?s.split("->",2):[s,""];if(!n.match(RegExp(k0)))throw new Error("Invalid LHS term");if(n.split(",").forEach((o,c)=>{let p=t[c].dims.slice();if(!o.match(RegExp(Gm)))throw new Error("Invalid LHS term");let d=this.processTerm(o,!0,p,c);this.lhs.push(d)}),i==="")i+=[...this.symbolToInfo.entries()].filter(([o,c])=>c.count===1||o==="...").map(([o])=>o).join("");else if(!i.match(RegExp(kp)))throw new Error("Invalid RHS");(l=i.match(RegExp(Ih,"g")))==null||l.forEach(o=>{if(o==="...")this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let c=this.symbolToInfo.get(o);if(c===void 0)throw new Error("Invalid RHS symbol");this.outputDims.push(c.dimValue)}}),this.rhs=this.processTerm(i,!1,this.outputDims)}addSymbol(t,s,n){let i=this.symbolToInfo.get(t);if(i!==void 0){if(i.dimValue!==s&&i.count!==1)throw new Error("Dimension mismatch");i.count++,i.inputIndices.push(n)}else i={count:1,dimValue:s,inputIndices:[n]};this.symbolToInfo.set(t,i)}processTerm(t,s,n,i=-1){let l=n.length,o=!1,c=[],p=0;if(!t.match(RegExp(Gm))&&!s&&t!=="")throw new Error("Invalid LHS term");let d=t.match(RegExp(Ih,"g")),f=new D0(i);return d==null||d.forEach((g,_)=>{if(g==="..."){if(o)throw new Error("Only one ellipsis is allowed per input term");o=!0;let y=l-d.length+1;if(y<0)throw new Error("Ellipsis out of bounds");if(c=n.slice(p,p+y),this.hasEllipsis){if(this.ellipsisDims.length!==c.length||this.ellipsisDims.toString()!==c.toString())throw new Error("Ellipsis dimensions mismatch")}else if(s)this.hasEllipsis=!0,this.ellipsisDims=c;else throw new Error("Ellipsis must be specified in the LHS");for(let T=0;T<c.length;T++){let b=String.fromCharCode(48+T);f.addSymbol(b,_+T),this.addSymbol(b,n[p++],i)}}else f.addSymbol(g,_+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(g,n[p++],i)}),f}},Wm=t=>t+"_max",z0=(t,s,n,i)=>{let l=t.map(f=>f.length).map((f,g)=>Ke(`input${g}`,s,f)),o=Ne.size(i),c=Tt("output",s,i.length),p=[...n.symbolToInfo.keys()].filter(f=>!n.rhs.symbolToIndices.has(f)),d=f=>{let g=[],_="var prod = 1.0;",y="var sum = 0.0;",T="sum += prod;",b=[],k=[],L=[],C=[],S=n.symbolToInfo.size===n.rhs.symbolToIndices.size;n.symbolToInfo.forEach((O,x)=>{var E;if(n.rhs.symbolToIndices.has(x)){let A=(E=n.rhs.symbolToIndices.get(x))==null?void 0:E[0];A!==void 0&&n.lhs.forEach((F,K)=>{if(O.inputIndices.includes(K)){let X=F.symbolToIndices.get(x);if(X===void 0)throw new Error("Invalid symbol error");X.forEach(oe=>{g.push(`${l[K].indicesSet(`input${K}Indices`,oe,c.indicesGet("outputIndices",A))}`)})}})}else n.lhs.forEach((A,F)=>{if(O.inputIndices.includes(F)){let K=A.symbolToIndices.get(x);if(K===void 0)throw new Error("Invalid symbol error");K.forEach(X=>{b.push(`${l[F].indicesSet(`input${F}Indices`,X,`${x}`)}`)}),C.push(`prod *= ${l[F].getByIndices(`input${F}Indices`)};`)}}),k.push(`for(var ${x}: u32 = 0; ${x} < uniforms.${Wm(x)}; ${x}++) {`),L.push("}")});let I=S?[...g,`let sum = ${l.map((O,x)=>O.getByIndices(`input${x}Indices`)).join(" * ")};`]:[...g,y,...k,...b,_,...C,T,...L];return`
            ${f.registerUniforms(p.map(O=>({name:`${Wm(O)}`,type:"u32"}))).registerUniform("outputSize","u32").declareVariables(...l,c)}

            ${f.mainStart()}
            ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
            var outputIndices = ${c.offsetToIndices("global_idx")};
            ${l.map((O,x)=>`var input${x}Indices: ${l[x].type.indices};`).join(`
`)}
            ${I.join(`
`)};
            ${c.setByOffset("global_idx","sum")};
          }`};return{name:"Einsum",shaderCache:{hint:n.equation,inputDependencies:t.map(()=>"rank")},getRunData:()=>{let f=p.filter(_=>n.symbolToInfo.has(_)).map(_=>{var y;return{type:12,data:((y=n.symbolToInfo.get(_))==null?void 0:y.dimValue)||0}});f.push({type:12,data:o});let g=t.map((_,y)=>[...Ct(_)]).reduce((_,y)=>_.concat(y),f);return g.push(...Ct(i)),{outputs:[{dims:i,dataType:s}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:g}},getShaderSource:d}},Kb=(t,s)=>{let n=new I0(t.inputs,s.equation),i=n.outputDims,l=t.inputs.map((o,c)=>o.dims);t.compute(z0(l,t.inputs[0].dataType,n,i))},qb=t=>{let s=t.equation.replace(/\s+/g,"");return An({equation:s})}}),F0,Hm,L0,B0,Qb,oE=ot(()=>{Bt(),qt(),Xt(),F0=t=>{if(!t||t.length!==2)throw new Error("Expand requires 2 input.");let s=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),i=n.length<s.length?0:n.length-s.length,l=s.length<n.length?0:s.length-n.length;for(;i<n.length&&l<s.length;++i,++l)if(n[i]!==s[l]&&n[i]!==1&&s[l]!==1)throw new Error("Expand requires shape to be broadcastable to input")},Hm=(t,s)=>{let n=t.length-s.length,i=[];for(let l=0;l<n;++l)i.push(t[l]);for(let l=0;l<s.length;++l)i.push(s[l]===1?t[l+n]:s[l]);return i},L0=(t,s)=>t.length>s.length?Hm(t,s):Hm(s,t),B0=t=>{let s=t[0].dims,n=Array.from(t[1].getBigInt64Array(),Number),i=L0(s,n),l=t[0].dataType,o=l===9||Ne.size(s)===1,c=l===9||s.length>0&&s[s.length-1]%4===0?4:1,p=o||i.length>0&&i[i.length-1]%4===0?4:1,d=Math.ceil(Ne.size(i)/p),f=_=>{let y=Ke("input",l,s.length,c),T=Tt("output",l,i.length,p),b;if(l===9){let k=(L,C,S="")=>`
          let outputIndices${C} = ${T.offsetToIndices(`outputOffset + ${C}u`)};
          let offset${C} = ${y.broadcastedIndicesToOffset(`outputIndices${C}`,T)};
          let index${C} = offset${C} / 4u;
          let component${C} = offset${C} % 4u;
          ${L}[${C}] = ${S}(${y.getByOffset(`index${C}`)}[component${C}]);
        `;b=`
        let outputOffset = global_idx * ${p};
        var data = vec4<u32>(0);
        ${k("data",0,"u32")}
        ${k("data",1,"u32")}
        ${k("data",2,"u32")}
        ${k("data",3,"u32")}
        ${T.setByOffset("global_idx","data")}
      }`}else b=`
        let outputIndices = ${T.offsetToIndices(`global_idx * ${p}`)};
        let inputOffset = ${y.broadcastedIndicesToOffset("outputIndices",T)};
        let data = ${T.type.value}(${y.getByOffset(`inputOffset / ${c}`)});
        ${T.setByOffset("global_idx","data")}
      }`;return`
    ${_.registerUniform("vec_size","u32").declareVariables(y,T)}
    ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
    ${b}`},g=[{type:12,data:d},...Ct(s,i)];return{name:"Expand",shaderCache:{hint:`${i.length};${c}${p}`,inputDependencies:["rank"]},getShaderSource:f,getRunData:()=>({outputs:[{dims:i,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:g})}},Qb=t=>{F0(t.inputs),t.compute(B0(t.inputs),{inputs:[0]})}}),R0,Xb,lE=ot(()=>{Bt(),qt(),Xt(),X_(),R0=t=>{let s=t[0].dataType,n=Ne.size(t[0].dims),i=Ne.size(t[1].dims),l=i%4===0,o=c=>{let p=Ke("x",s,[1],4),d=Ke("bias",s,[1],4),f=Tt("y",s,[1],4),g=[{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}],_=T=>`
      let bias${T}_offset: u32 = (global_idx * 4 + ${T}) % uniforms.bias_size;
      let bias${T} = ${d.getByOffset(`bias${T}_offset / 4`)}[bias${T}_offset % 4];`,y=l?`
      let bias = ${d.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${_(0)}${_(1)}${_(2)}${_(3)}
      let bias = ${p.type.value}(bias0, bias1, bias2, bias3);`;return`${c.registerUniforms(g).declareVariables(p,d,f)}

    ${T_(hs(s))}

    ${c.mainStart(Wd)}
      ${c.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}

      let x = ${p.getByOffset("global_idx")};
      ${y}
      let x_in = x + bias;
      ${f.setByOffset("global_idx",x_("x_in"))}
    }`};return{name:"FastGeluWithBias",shaderCache:{hint:`${l}`,inputDependencies:["type","type"]},getShaderSource:o,getRunData:c=>({outputs:[{dims:c[0].dims,dataType:c[0].dataType}],programUniforms:[{type:12,data:Math.ceil(n/4)},{type:12,data:i}],dispatchGroup:{x:Math.ceil(n/Wd/4)}})}},Xb=t=>{t.inputs.length<2||Ne.size(t.inputs[1].dims)===0?_b(t):t.compute(R0(t.inputs))}}),N0,j0,Yb,Zb,uE=ot(()=>{Bt(),qt(),or(),Xt(),N0=t=>{if(!t||t.length!==2)throw new Error("Gather requires 2 inputs.")},j0=(t,s)=>{let n=t[0].dims,i=t[1].dims,l=n.length,o=Ne.normalizeAxis(s.axis,l),c=n.slice(0);c.splice(o,1,...i);let p=n[o],d=t[0].dataType===9?4:1,f=Math.ceil(Ne.size(c)/d),g=[{type:12,data:f},{type:6,data:p},{type:12,data:o},...Ct(t[0].dims,t[1].dims,c)],_=y=>{let T=Ke("data",t[0].dataType,t[0].dims.length,d),b=Ke("inputIndices",t[1].dataType,t[1].dims.length),k=Tt("output",t[0].dataType,c.length,d),L=S=>{let I=i.length,O=`var indicesIndices${S}  = ${b.type.indices}(0);`;for(let x=0;x<I;x++)O+=`${I>1?`indicesIndices${S}[${x}]`:`indicesIndices${S}`} = ${c.length>1?`outputIndices${S}[uniforms.axis + ${x}]`:`outputIndices${S}`};`;O+=`
          var idx${S} = ${b.getByIndices(`indicesIndices${S}`)};
          if (idx${S} < 0) {
            idx${S} = idx${S} + uniforms.axisDimLimit;
          }
          var dataIndices${S} : ${T.type.indices};
        `;for(let x=0,E=0;x<l;x++)x===o?(O+=`${l>1?`dataIndices${S}[${x}]`:`dataIndices${S}`} = u32(idx${S});`,E+=I):(O+=`${l>1?`dataIndices${S}[${x}]`:`dataIndices${S}`} = ${c.length>1?`outputIndices${S}[${E}]`:`outputIndices${S}`};`,E++);return O},C;if(t[0].dataType===9){let S=(I,O,x="")=>`
          let outputIndices${O} = ${k.offsetToIndices(`outputOffset + ${O}u`)};
          ${L(O)};
          let offset${O} = ${T.indicesToOffset(`dataIndices${O}`)};
          let index${O} = offset${O} / 4u;
          let component${O} = offset${O} % 4u;
          ${I}[${O}] = ${x}(${T.getByOffset(`index${O}`)}[component${O}]);
        `;C=`
        let outputOffset = global_idx * ${d};
        var value = vec4<u32>(0);
        ${S("value",0,"u32")}
        ${S("value",1,"u32")}
        ${S("value",2,"u32")}
        ${S("value",3,"u32")}
        ${k.setByOffset("global_idx","value")}
      `}else C=`
      let outputIndices = ${k.offsetToIndices("global_idx")};
      ${L("")};
      let value = ${T.getByIndices("dataIndices")};
      ${k.setByOffset("global_idx","value")};
      `;return`
      ${y.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(T,b,k)}
      ${y.mainStart()}
        ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        ${C}
      }`};return{name:"Gather",shaderCache:{hint:s.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:c,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:g}),getShaderSource:_}},Yb=t=>An({axis:t.axis}),Zb=(t,s)=>{let n=t.inputs;N0(n),t.compute(j0(t.inputs,s))}}),U0,Jb,e1,cE=ot(()=>{Bt(),qt(),Xt(),U0=(t,s,n,i,l,o,c,p,d)=>{let f=[{type:12,data:o},{type:12,data:i},{type:12,data:l},{type:12,data:n},{type:12,data:c},{type:12,data:p},{type:12,data:d}],g=[o];f.push(...Ct(s.dims,g));let _=y=>{let T=Ke("indices_data",s.dataType,s.dims.length),b=Tt("input_slice_offsets_data",12,1,1),k=[T,b],L=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:l.length},{name:"sizes_from_slice_dims_data",type:"u32",length:n.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`
  ${y.registerUniforms(L).declareVariables(...k)}
  ${y.mainStart()}
    ${y.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let batch_idx = global_idx / uniforms.num_slices_per_batch;
    let base_offset = batch_idx * uniforms.input_batch_stride;

    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;
    var relative_slice_offset = 0;
    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {
      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);
      let input_dim_idx = uniforms.batch_dims + dim_idx;
      if (index < 0) {
        ${l.length===1?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}
      }
      ${n.length===1?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}
    }

    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);
  }`};return t.compute({name:"computeSliceOffsets",shaderCache:{hint:`${l.length}_${n.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:g,dataType:t.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:f}),getShaderSource:_},{inputs:[s],outputs:[-1]})[0]},Jb=(t,s)=>{let n=t.inputs,i=n[0].dims,l=n[0].dataType,o=n[1].dims,c=o[o.length-1],p=Ne.sizeToDimension(o,o.length-1),d=Ne.sizeFromDimension(i,s.batchDims+c),f=Ne.sizeToDimension(i,s.batchDims),g=Ne.sizeFromDimension(i,s.batchDims),_=p/f,y=new Array(c),T=d;for(let O=0;O<c;++O)y[c-1-O]=T,T*=i[s.batchDims+c-1-O];let b=U0(t,n[1],y,s.batchDims,i,p,_,g,c),k=s.batchDims+c;if(k>i.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let L=o.slice(0,-1).concat(i.slice(k)),C=Ne.size(L),S=[{type:12,data:C},{type:12,data:d},...Ct(n[0].dims,b.dims,L)],I=O=>{let x=Ke("data",n[0].dataType,n[0].dims.length),E=Ke("slice_offsets",12,b.dims.length),A=Tt("output",n[0].dataType,L.length);return`
          ${O.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(x,E,A)}
            ${O.mainStart()}
            ${O.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];
          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];
        }`};t.compute({name:"GatherND",shaderCache:{hint:s.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:L,dataType:l}],dispatchGroup:{x:Math.ceil(C/64)},programUniforms:S}),getShaderSource:I},{inputs:[n[0],b]})},e1=t=>({batchDims:t.batch_dims,cacheKey:""})}),V0,G0,t1,n1,dE=ot(()=>{Bt(),qt(),or(),Xt(),V0=(t,s)=>{if(t.length<3||t.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let n=Ne.normalizeAxis(s.quantizeAxis,t[0].dims.length),i=s.blockSize,l=t[0],o=t[2],c=t.length===4?t[3]:void 0;if(o.dims.length!==l.dims.length||!l.dims.map((p,d)=>d===n?Math.ceil(p/i)===o.dims[d]:p===o.dims[d]).reduce((p,d)=>p&&d,!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(c){if(c.dataType!==l.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(c.dims.length!==o.dims.length||!c.dims.map((p,d)=>p===o.dims[d]).reduce((p,d)=>p&&d,!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},G0=(t,s)=>{let n=t[0].dims,i=t[1].dims,l=n.length,o=Ne.normalizeAxis(s.gatherAxis,l),c=Ne.normalizeAxis(s.quantizeAxis,l),p=n.slice(0);p.splice(o,1,...i);let d=Ne.size(p),f=t[2].dataType,g=t[0].dataType===22,_=[{type:12,data:d},{type:12,data:c},{type:12,data:o},{type:12,data:s.blockSize},...Ct(...t.map((T,b)=>T.dims),p)],y=T=>{let b=Ke("data",t[0].dataType,t[0].dims.length),k=Ke("inputIndices",t[1].dataType,t[1].dims.length),L=Ke("scales",t[2].dataType,t[2].dims.length),C=t.length>3?Ke("zeroPoint",t[3].dataType,t[3].dims.length):void 0,S=Tt("output",f,p.length),I=[b,k,L];C&&I.push(C);let O=[{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}];return`
        ${T.registerUniforms(O).declareVariables(...I,S)}
        ${T.mainStart()}
        let output_indices = ${S.offsetToIndices("global_idx")};
        var indices_indices = ${k.type.indices}(0);
        ${i.length>1?`
          for (var i: u32 = 0; i < ${i.length}; i++) {
            let index = ${S.indicesGet("output_indices","uniforms.gather_axis + i")};
            ${k.indicesSet("indices_indices","i","index")};
          }`:`indices_indices = ${S.indicesGet("output_indices","uniforms.gather_axis")};`};
        var data_indices = ${b.type.indices}(0);
        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {
          let index = ${S.indicesGet("output_indices","i")};
          ${b.indicesSet("data_indices","i","index")};
        }
        var index_from_indices = ${k.getByIndices("indices_indices")};
        if (index_from_indices < 0) {
          index_from_indices += ${n[o]};
        }
        ${b.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};
        for (var i = uniforms.gather_axis + 1; i < ${p.length}; i++) {
          let index = ${S.indicesGet("output_indices",`i + ${i.length} - 1`)};
          ${b.indicesSet("data_indices","i","index")};
        }
        let data_offset = ${b.indicesToOffset("data_indices")};
        let data_index = data_offset % 8;
        // Convert 4-bit packed data to 8-bit packed data.
        let packed_4bit_quantized_data = ${b.getByOffset("data_offset / 8")};
        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;
        let quantized_data_vec = ${g?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));
        let quantized_data = quantized_data_vec[data_index / 2];
        var scale_indices = data_indices;
        let quantize_axis_index = ${L.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;
        ${L.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};
        var scale = ${L.getByIndices("scale_indices")};
        ${C?`
              let zero_point_indices = scale_indices;
              let zero_point_offset = ${C.indicesToOffset("zero_point_indices")};
              let zero_point_index = zero_point_offset % 8;
              let packed_4bit_zero_points = ${C.getByOffset("zero_point_offset / 8")};
              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;
              let zero_point_vec = ${g?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));
              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};
        let dequantized_data = ${hs(f)}(quantized_data - zero_point) * scale;
        ${S.setByOffset("global_idx","dequantized_data")};
    }`};return{name:"GatherBlockQuantized",shaderCache:{hint:`${s.cacheKey};${t.filter((T,b)=>b!==1).map(T=>T.dims.join("_")).join(";")}`,inputDependencies:Array.from({length:t.length},(T,b)=>"rank")},getRunData:()=>({outputs:[{dims:p,dataType:f}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:_}),getShaderSource:y}},t1=(t,s)=>{let n=t.inputs;V0(n,s),t.compute(G0(t.inputs,s))},n1=t=>An({blockSize:t.blockSize,gatherAxis:t.gatherAxis,quantizeAxis:t.quantizeAxis})}),W0,H0,r1,s1,fE=ot(()=>{Bt(),qt(),or(),Xt(),W0=t=>{if(!t||t.length!==2)throw new Error("GatherElements requires 2 inputs.");if(t[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(t[0].dims.length!==t[1].dims.length)throw new Error(`GatherElements requires that the data input and
                     indices input tensors be of same rank.`)},H0=(t,s)=>{let n=t[0].dims,i=t[0].dataType,l=n.length,o=t[1].dims,c=t[1].dataType,p=Ne.normalizeAxis(s.axis,l),d=n[p],f=o.slice(0),g=Ne.size(f),_=Ke("input",i,l),y=Ke("indicesInput",c,o.length),T=Tt("output",i,f.length),b=[{type:12,data:g},{type:6,data:d},{type:12,data:p}];return b.push(...Ct(n,o,f)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:f,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:b}),getShaderSource:k=>`
      ${k.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(_,y,T)}
      ${k.mainStart()}
      ${k.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

      let outputIndices = ${T.offsetToIndices("global_idx")};

      var idx = ${y.getByOffset("global_idx")};
      if (idx < 0) {
        idx = idx + uniforms.axisDimLimit;
      }
      var inputIndices = ${_.type.indices}(outputIndices);
      ${_.indicesSet("inputIndices","uniforms.axis","u32(idx)")};
      let value = ${_.getByIndices("inputIndices")};

      ${T.setByOffset("global_idx","value")};
  }`}},r1=t=>An({axis:t.axis}),s1=(t,s)=>{let n=t.inputs;W0(n),t.compute(H0(t.inputs,s))}}),K0,q0,a1,i1,pE=ot(()=>{Bt(),qt(),Xt(),K0=t=>{if(!t)throw new Error("Input is missing");if(t.length<2||t.length>3)throw new Error("Invaid input number.");if(t.length===3&&t[2].dims.length>2)throw new Error("Invalid input shape of C");if(t[0].dataType!==t[1].dataType||t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("Input types are mismatched")},q0=(t,s)=>{let n=t[0].dims.slice(),i=t[1].dims.slice(),[l,o,c]=ow.getShapeOfGemmResult(n,s.transA,i,s.transB,t.length===3?t[2].dims:void 0),p=[l,o];if(!p)throw new Error("Can't use gemm on the given tensors");let d=16,f=Math.ceil(o/d),g=Math.ceil(l/d),_=!0,y=Ne.size(p),T=[{type:12,data:_?f:y},{type:12,data:l},{type:12,data:o},{type:12,data:c},{type:1,data:s.alpha},{type:1,data:s.beta}],b=["type","type"];t.length===3&&(T.push(...Ct(t[2].dims)),b.push("rank")),T.push(...Ct(p));let k=C=>{let S="";s.transA&&s.transB?S="value += a[k * uniforms.M + m] * b[n * uniforms.K + k];":s.transA&&!s.transB?S="value += a[k * uniforms.M + m] * b[k * uniforms.N + n];":!s.transA&&s.transB?S="value += a[m * uniforms.K + k] * b[n * uniforms.K + k];":!s.transA&&!s.transB&&(S="value += a[m * uniforms.K + k] * b[k * uniforms.N + n];");let I=s.alpha===1?"":"value *= uniforms.alpha;",O=Ke("a",t[0].dataType,t[0].dims),x=Ke("b",t[1].dataType,t[1].dims),E=O.type.value,A=null,F=[O,x];t.length===3&&(A=Ke("c",t[2].dataType,t[2].dims.length),F.push(A));let K=Tt("output",t[0].dataType,p.length);F.push(K);let X=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}];return`
  ${C.registerUniforms(X).declareVariables(...F)}

  ${C.mainStart()}
    ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

    let m = global_idx / uniforms.N;
    let n = global_idx % uniforms.N;

    var value = ${E}(0);
    for (var k: u32 = 0u; k < uniforms.K; k++) {
      ${S}
    }

    ${I}
    ${A!=null?`let cOffset = ${A.broadcastedIndicesToOffset("vec2(m, n)",K)}; value += ${E}(uniforms.beta) * ${A.getByOffset("cOffset")};`:""}
    output[global_idx] = value;
  }`},L=C=>{let S=Ke("a",t[0].dataType,t[0].dims),I=Ke("b",t[1].dataType,t[1].dims),O=null,x=[S,I];t.length===3&&(O=Ke("c",t[2].dataType,t[2].dims.length),x.push(O));let E=Tt("output",t[0].dataType,p.length);x.push(E);let A=[{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}],F="",K="";s.transA&&s.transB?(K=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${S.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${I.type.value}(0);
      }
      `,F="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):s.transA&&!s.transB?(K=`
      var col = tile_row_start + local_id.x;
      var row = k_start + local_id.y;
      if (col < uniforms.M && row < uniforms.K) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${S.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${I.type.value}(0);
      }
      `,F="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!s.transA&&s.transB?(K=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${S.type.value}(0);
      }

      col = k_start + local_id.x;
      row = tile_col_start + local_id.y;
      if (col < uniforms.K && row < uniforms.N) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${I.type.value}(0);
      }
      `,F="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!s.transA&&!s.transB&&(K=`
      var col = k_start + local_id.x;
      var row = tile_row_start + local_id.y;
      if (col < uniforms.K && row < uniforms.M) {
        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];
      } else {
        tile_a[local_id.y][local_id.x] = ${S.type.value}(0);
      }

      col = tile_col_start + local_id.x;
      row = k_start + local_id.y;
      if (col < uniforms.N && row < uniforms.K) {
        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];
      } else {
        tile_b[local_id.y][local_id.x] = ${I.type.value}(0);
      }
      `,F="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let X=s.alpha===1?"":"value *= uniforms.alpha;";return`
  ${C.registerUniforms(A).declareVariables(...x)}
  var<workgroup> tile_a: array<array<${S.type.storage}, ${d}>, ${d}>;
  var<workgroup> tile_b: array<array<${I.type.storage}, ${d}>, ${d}>;
  ${C.mainStart([d,d,1])}
    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${d};
    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${d};
    let num_tiles = (uniforms.K - 1) / ${d} + 1;
    var k_start = 0u;
    var value = ${E.type.value}(0);
    for (var t: u32 = 0u; t < num_tiles; t++) {
      ${K}
      k_start = k_start + ${d};
      workgroupBarrier();

      for (var k: u32 = 0u; k < ${d}; k++) {
        ${F}
      }
      workgroupBarrier();
    }

    ${X}
    let m = tile_row_start + local_id.y;
    let n = tile_col_start + local_id.x;
    ${O!=null?`let cOffset = ${O.broadcastedIndicesToOffset("vec2(m, n)",E)}; value += ${E.type.value}(uniforms.beta) * ${O.getByOffset("cOffset")};`:""}
    if (m < uniforms.M && n < uniforms.N) {
      output[m * uniforms.N + n] = value;
    }
  }`};return _?{name:"GemmShared",shaderCache:{hint:`${s.cacheKey}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:p,dataType:t[0].dataType}],dispatchGroup:{x:f*g},programUniforms:T}),getShaderSource:L}:{name:"Gemm",shaderCache:{hint:`${s.cacheKey}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:p,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:T}),getShaderSource:k}},a1=t=>{let s=t.transA,n=t.transB,i=t.alpha,l=t.beta;return{transA:s,transB:n,alpha:i,beta:l,cacheKey:`${t.transA};${t.transB};${t.alpha===1}`}},i1=(t,s)=>{K0(t.inputs),t.compute(q0(t.inputs,s))}}),lo,Ho,fc,pc,Q0,X0,Y0,Z0,J0,eM,tM,nM,o1,l1,hE=ot(()=>{Bt(),qt(),or(),Xt(),[lo,Ho,fc,pc]=[0,1,2,3],Q0=t=>{if(t[0].dims.length!==4)throw new Error("only 4-D tensor is supported.");if(t[0].dims.length!==t[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(t[0].dims.length-2!==t[1].dims[t[1].dims.length-1])throw new Error(`last dimension of grid must be equal to ${t[0].dims.length-2}`);if(t[0].dims[0]!==t[1].dims[0])throw new Error("grid batch size must match input batch size")},X0=`
  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {
    let cubic_alpha = -0.75f;
    let x_abs = abs(x);
    var coeffs: vec4<f32>;
    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);
    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);
    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);
    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);
    return coeffs;
  }
`,Y0=t=>`
  fn gs_bicubic_interpolate(p: mat4x4<${t}>, x: f32, y: f32) -> ${t} {
    var v: vec4<f32>;
    var coeffs = gs_get_cubic_coeffs(x);
    for (var i = 0; i < 4; i++) {
      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];
    }
    coeffs = gs_get_cubic_coeffs(y);
    let pixel = ${t}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);
    return pixel;
  }
`,Z0=t=>`
  fn gs_denormalize(n: f32, length: i32) -> f32 {
    ${t.alignCorners===0?`
    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]
    return ((n + 1.0) * f32(length) - 1.0) / 2.0;
    `:`
    // alignCorners: true => [-1, 1] to [0, length - 1]
    return (n + 1.0) / 2.0 * (f32(length - 1));
    `}
  }
`,J0=t=>`
  ${t.paddingMode==="reflection"?`
      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {
        var dx = 0.0;
        var fx = f32(x);
        let range = x_max - x_min;
        if (fx < x_min) {
          dx = x_min - fx;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_min + r;
          } else {
            fx = x_max - r;
          }
        } else if (fx > x_max) {
          dx = fx - x_max;
          let n = u32(dx / range);
          let r = dx - f32(n) * range;
          if (n % 2 == 0) {
            fx = x_max - r;
          } else {
            fx = x_min + r;
          }
        }
        return u32(fx);
      }`:""}
`,eM=(t,s,n)=>`
  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${s} {
     var pixel = ${s}(0);
     var indices = vec4<u32>(0);
     indices[${lo}] = batch;
     indices[${Ho}] = channel;`+(()=>{switch(n.paddingMode){case"zeros":return`
          if (r >= 0 && r < H && c >=0 && c < W) {
            indices[${fc}] = u32(r);
            indices[${pc}] = u32(c);
          }
        `;case"border":return`
          indices[${fc}] = u32(clamp(r, 0, H - 1));
          indices[${pc}] = u32(clamp(c, 0, W - 1));
        `;case"reflection":return`
          indices[${fc}] = gs_reflect(r, border[1], border[3]);
          indices[${pc}] = gs_reflect(c, border[0], border[2]);
        `;default:throw new Error(`padding mode ${n.paddingMode} is not supported`)}})()+`
    return ${t.getByIndices("indices")};
  }
`,tM=(t,s,n)=>(()=>{switch(n.mode){case"nearest":return`
          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${lo}], indices[${Ho}], border);
        `;case"bilinear":return`
          let x1 = i32(floor(x));
          let y1 = i32(floor(y));
          let x2 = x1 + 1;
          let y2 = y1 + 1;

          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${lo}], indices[${Ho}], border);
          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${lo}], indices[${Ho}], border);
          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${lo}], indices[${Ho}], border);
          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${lo}], indices[${Ho}], border);

          let dx2 = ${s}(f32(x2) - x);
          let dx1 = ${s}(x - f32(x1));
          let dy2 = ${s}(f32(y2) - y);
          let dy1 = ${s}(y - f32(y1));
          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);
        `;case"bicubic":return`
          let x0 = i32(floor(x)) - 1;
          let y0 = i32(floor(y)) - 1;
          var p: mat4x4<${s}>;
          for (var h = 0; h < 4; h++) {
            for (var w = 0; w < 4; w++) {
              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${lo}], indices[${Ho}], border);
            }
          }

          let dx = x - f32(x0 + 1);
          let dy = y - f32(y0 + 1);
          let result = gs_bicubic_interpolate(p, dx, dy);
        `;default:throw new Error(`mode ${n.mode} is not supported`)}})()+`${t.setByOffset("global_idx","result")}`,nM=(t,s)=>{let n=Ke("x",t[0].dataType,t[0].dims.length),i=[t[1].dims[0],t[1].dims[1],t[1].dims[2]],l=Ke("grid",t[1].dataType,i.length,2),o=[t[0].dims[0],t[0].dims[1],t[1].dims[1],t[1].dims[2]];s.format==="NHWC"&&(o=[t[0].dims[0],t[1].dims[1],t[1].dims[2],t[0].dims[3]],[lo,Ho,fc,pc]=[0,3,1,2]);let c=Tt("output",t[0].dataType,o.length),p=n.type.value,d=Ne.size(o),f=[{type:12,data:d},...Ct(t[0].dims,i,o)],g=_=>`
  ${_.registerUniform("output_size","u32").declareVariables(n,l,c)}
  ${X0}
  ${Y0(p)}
  ${Z0(s)}
  ${J0(s)}
  ${eM(n,p,s)}

  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let H_in = i32(uniforms.x_shape[${fc}]);
      let W_in = i32(uniforms.x_shape[${pc}]);

      ${s.alignCorners===0?`
      let x_min = -0.5;
      let x_max = f32(W_in) - 0.5;
      let y_min = -0.5;
      let y_max = f32(H_in) - 0.5;
      `:`
      let x_min = 0.0;
      let x_max = f32(W_in) - 1.0;
      let y_min = 0.0;
      let y_max = f32(H_in) - 1.0;
      `};
      let border = vec4<f32>(x_min, y_min, x_max, y_max);

      let indices = ${c.offsetToIndices("global_idx")};
      var grid_indices = vec3<u32>(indices[${lo}], indices[${fc}], indices[${pc}]);
      let nxy = ${l.getByIndices("grid_indices")};
      var x = gs_denormalize(f32(nxy[0]), W_in);
      var y = gs_denormalize(f32(nxy[1]), H_in);

      ${tM(c,p,s)}
  }`;return{name:"GridSample",shaderCache:{hint:`${s.cacheKey}`,inputDependencies:["type","type"]},getRunData:_=>{let y=Ne.size(o);return{outputs:[{dims:o,dataType:_[0].dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:f}},getShaderSource:g}},o1=(t,s)=>{Q0(t.inputs),t.compute(nM(t.inputs,s))},l1=t=>An({alignCorners:t.align_corners,mode:t.mode,paddingMode:t.padding_mode,format:t.format})}),Os,rM,u1,Km,sM,Np,c1,d1=ot(()=>{Bt(),qt(),or(),H_(),Q_(),Xt(),au(),Os=(t,s)=>t.length>s&&t[s].dims.length>0?t[s]:void 0,rM=(t,s)=>{let n=t[0],i=Os(t,1),l=Os(t,2),o=Os(t,3),c=Os(t,4),p=Os(t,5),d=Os(t,6),f=Os(t,7);if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let g=n.dims[0],_=n.dims[1],y=n.dims.length===3?n.dims[2]:s.numHeads*n.dims[4],T=_,b=0,k=0,L=Math.floor(y/s.numHeads);if(d&&f&&Ne.size(d.dims)&&Ne.size(f.dims)){if(d.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(d.dims[0]!==g||d.dims[1]!==s.numHeads||d.dims[3]!==L)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(f.dims[0]!==g||f.dims[1]!==s.numHeads||f.dims[3]!==L)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(d.dims[2]!==f.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(f.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');b=d.dims[2],k=d.dims[2]}else if(d&&Ne.size(d.dims)||f&&Ne.size(f.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let C;if(i&&Ne.size(i.dims)>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(i.dims[2]!==n.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');C=2,T=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==s.numHeads||i.dims[3]!==2||i.dims[4]!==L)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(l)throw new Error('Expect "value" be none when "key" has packed kv format.');C=5,T=i.dims[1]}else{if(i.dims[1]!==s.numHeads||i.dims[3]!==L)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');C=0,T=i.dims[2]}}else{if(n.dims.length!==5)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(n.dims[2]!==s.numHeads||n.dims[3]!==3)throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');C=3}if(o&&Ne.size(o.dims)>0){if(o.dims.length!==1)throw new Error('Input "bias" is expected to have 1 dimension');if(i&&i.dims.length===5&&i.dims[3]===2)throw new Error("bias is not allowed for packed kv.")}let S=b+T,I=0;if(c&&Ne.size(c.dims)>0){I=8;let A=c.dims;throw A.length===1?A[0]===g?I=1:A[0]===3*g+2&&(I=3):A.length===2&&A[0]===g&&A[1]===S&&(I=5),I===8?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let O=!1,x=y;if(l&&Ne.size(l.dims)>0){if(l.dims.length!==3&&l.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==l.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(l.dims.length===3){if(T!==l.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');x=l.dims[2]}else{if(T!==l.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');x=l.dims[1]*l.dims[3],O=!0}}let E=!1;if(c&&Ne.size(c.dims)>0)throw new Error("Key padding mask is not supported");if(p&&Ne.size(p.dims)>0){if(p.dims.length!==4)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(p.dims[0]!==g||p.dims[1]!==s.numHeads||p.dims[2]!==_||p.dims[3]!==S)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:g,sequenceLength:_,pastSequenceLength:b,kvSequenceLength:T,totalSequenceLength:S,maxSequenceLength:k,inputHiddenSize:0,hiddenSize:y,vHiddenSize:x,headSize:L,vHeadSize:Math.floor(x/s.numHeads),numHeads:s.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:s.maskFilterValue,maskType:I,scale:s.scale,broadcastResPosBias:E,passPastInKv:O,qkvFormat:C}},u1=t=>An({...t}),Km=An({perm:[0,2,1,3]}),sM=(t,s,n,i,l,o,c)=>{let p=[i,l,o],d=Ne.size(p),f=[{type:12,data:d},{type:12,data:c},{type:12,data:o}],g=_=>{let y=Tt("qkv_with_bias",s.dataType,p),T=Ke("qkv",s.dataType,p),b=Ke("bias",n.dataType,p),k=[{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}];return`
  ${_.registerUniforms(k).declareVariables(T,b,y)}
  ${_.mainStart()}
    ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;

    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];
  }`};return t.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:p,dataType:s.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:f}),getShaderSource:g},{inputs:[s,n],outputs:[-1]})[0]},Np=(t,s,n,i,l,o,c,p)=>{let d=o;if(c&&Ne.size(c.dims)>0){if(i===1)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return d=sM(t,o,c,s,i,n*l,p),d=d.reshape([s,i,n,l]),n===1||i===1?d:t.compute(_a(d,Km.perm),{inputs:[d],outputs:[-1]})[0]}else return o.dims.length===3&&(d=o.reshape([s,i,n,l])),n===1||i===1?d:t.compute(_a(d,Km.perm),{inputs:[d],outputs:[-1]})[0]},c1=(t,s)=>{let n=rM(t.inputs,s),i=t.inputs[0],l=Os(t.inputs,1),o=Os(t.inputs,2),c=Os(t.inputs,3),p=Os(t.inputs,4),d=Os(t.inputs,5),f=Os(t.inputs,6),g=Os(t.inputs,7);if(i.dims.length===5)throw new Error("Packed QKV is not implemented");if((l==null?void 0:l.dims.length)===5)throw new Error("Packed KV is not implemented");let _=l&&o&&l.dims.length===4&&o.dims.length===4,y=Np(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,i,c,0);if(_)return Vp(t,y,l,o,p,void 0,f,g,d,n);if(!l||!o)throw new Error("key and value must be provided");let T=Np(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.headSize,l,c,n.hiddenSize),b=Np(t,n.batchSize,n.numHeads,n.kvSequenceLength,n.vHeadSize,o,c,2*n.hiddenSize);Vp(t,y,T,b,p,void 0,f,g,d,n)}}),aM,iM,oM,lM,A_,f1,p1,h1=ot(()=>{Bt(),qt(),or(),Xt(),aM=t=>{if(!t||t.length<1)throw new Error("too few inputs")},iM=(t,s)=>{let n=[],i=s.numOutputs;return t[1].dims[0]>0&&(t[1].getBigInt64Array().forEach(l=>n.push(Number(l))),i=n.length),An({numOutputs:i,axis:s.axis,splitSizes:n})},oM=t=>`
fn calculateOutputIndex(index: u32) -> u32 {
    for (var i: u32 = 0u; i < ${t}u; i += 1u ) {
    if (index < ${xt("uniforms.size_in_split_axis","i",t)}) {
        return i;
    }
    }
    return ${t}u;
}`,lM=t=>{let s=t.length,n=[];for(let i=0;i<s;++i){let l=t[i].setByIndices("indices","input[global_idx]");s===1?n.push(l):i===0?n.push(`if (output_number == ${i}u) { ${l} }`):i===s-1?n.push(`else { ${l} }`):n.push(`else if (output_number == ${i}) { ${l} }`)}return`
      fn writeBufferData(output_number: u32, indices: ${t[0].type.indices}, global_idx: u32) {
        ${n.join(`
`)}
      }`},A_=(t,s)=>{let n=t[0].dims,i=Ne.size(n),l=t[0].dataType,o=Ne.normalizeAxis(s.axis,n.length),c=new Array(s.numOutputs),p=Ke("input",l,n.length),d=new Array(s.numOutputs),f=[],g=[],_=0,y=[{type:12,data:i}];for(let b=0;b<s.numOutputs;b++){_+=s.splitSizes[b],d[b]=_;let k=n.slice();k[o]=s.splitSizes[b],g.push(k),c[b]=Tt(`output${b}`,l,k.length),f.push({dims:g[b],dataType:t[0].dataType})}y.push({type:12,data:d},...Ct(n,...g));let T=b=>`
  ${b.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",d.length).declareVariables(p,...c)}
  ${oM(d.length)}
  ${lM(c)}

  ${b.mainStart()}
    ${b.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}

    var indices = ${p.offsetToIndices("global_idx")};
    var index = ${p.indicesGet("indices",o)};
    let output_number = calculateOutputIndex(index);
    if (output_number != 0) {
      index -= ${xt("uniforms.size_in_split_axis","output_number - 1u",d.length)};
      ${p.indicesSet("indices",o,"index")};
    }
    writeBufferData(output_number, indices, global_idx);
  }`;return{name:"Split",shaderCache:{hint:s.cacheKey,inputDependencies:["rank"]},getShaderSource:T,getRunData:()=>({outputs:f,dispatchGroup:{x:Math.ceil(i/64)},programUniforms:y})}},f1=(t,s)=>{aM(t.inputs);let n=t.inputs.length===1?s:iM(t.inputs,s);t.compute(A_(t.inputs,n),{inputs:[0]})},p1=t=>{let s=t.axis,n=t.splitSizes,i=t.numOutputs<0?n.length:t.numOutputs;if(i!==n.length)throw new Error("numOutputs and splitSizes lengh must be equal");return An({axis:s,numOutputs:i,splitSizes:n})}}),uM,cM,qm,m1,mE=ot(()=>{or(),Q_(),d1(),h1(),au(),uM=(t,s)=>{if(s.doRotary)throw new Error("GroupQuerryAttention do_rotary attribute is not supported");if(s.doRotary&&t.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let n=t[0],i=t[1],l=t[2],o=t[3],c=t[4];if(s.localWindowSize!==-1)throw new Error("Local attention is not supported");if(s.softcap!==0)throw new Error("Softcap is not supported");if(s.rotaryInterleaved!==0)throw new Error("Rotary interleaved is not supported");if(s.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(n.dims.length!==3&&n.dims.length!==5)throw new Error("Input query is expected to have 3 or 5 dimensions");let p=!1,d=n.dims[0],f=n.dims[1],g=n.dims.length===3?p?n.dims[2]/3:n.dims[2]:s.numHeads*n.dims[4],_=f,y=0,T=!i||i.dims.length===0,b=Math.floor(T?g/(s.numHeads+2*s.kvNumHeads):g/s.numHeads);T&&(g=b*s.numHeads);let k=o&&o.dims.length!==0,L=c&&c.dims.length!==0;if(k&&o.dims.length===4&&o.dims[0]===d&&o.dims[1]!==s.kvNumHeads&&o.dims[2]===s.kvNumHeads&&o.dims[3]===b)throw new Error("BSNH pastKey/pastValue is not supported");if(k&&L){if(o.dims.length!==4)throw new Error('Input "past_key" is expected to have 4 dimensions');if(c.dims.length!==4)throw new Error('Input "past_value" is expected to have 4 dimensions');y=o.dims[2]}else if(k||L)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let C=1;if(i&&i.dims.length>0){if(n.dims.length!==3)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(i.dims.length<3||i.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(n.dims[0]!==i.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(i.dims.length===3){if(n.dims[2]%i.dims[2]!==0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');_=i.dims[1]}else if(i.dims.length===5){if(i.dims[2]!==s.numHeads||i.dims[3]!==2||i.dims[4]!==b)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(l)throw new Error('Expect "value" be none when "key" has packed kv format.');_=i.dims[1]}else{if(i.dims[1]!==s.numHeads||i.dims[3]!==b)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');_=i.dims[2]}}else{if(n.dims.length!==3&&n.dims.length!==5)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(n.dims.length===5&&(n.dims[2]!==s.numHeads||n.dims[3]!==3))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');C=3}let S=0,I=!1,O=s.kvNumHeads?b*s.kvNumHeads:g;if(l&&l.dims.length>0){if(l.dims.length!==3&&l.dims.length!==4)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(n.dims[0]!==l.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(l.dims.length===3){if(_!==l.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');O=l.dims[2]}else{if(_!==l.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');O=l.dims[1]*l.dims[3],I=!0}}let x=t.length>4?t[5]:void 0;if(x&&x.dims.length!==1&&x.dims[0]!==d)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:d,sequenceLength:f,pastSequenceLength:y,kvSequenceLength:_,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:g,vHiddenSize:O,headSize:b,vHeadSize:Math.floor(O/s.kvNumHeads),numHeads:s.numHeads,kvNumHeads:s.kvNumHeads,nReps:s.numHeads/s.kvNumHeads,pastPresentShareBuffer:!1,maskType:S,scale:s.scale,broadcastResPosBias:!1,passPastInKv:I,qkvFormat:C}},cM=An({perm:[0,2,1,3]}),qm=(t,s,n)=>{let i=s,l=n.kvNumHeads;return s.dims.length===3&&n.kvSequenceLength!==0&&(i=s.reshape([n.batchSize,n.kvSequenceLength,l,n.headSize]),i=t.compute(_a(i,cM.perm),{inputs:[i],outputs:[-1]})[0]),i},m1=(t,s)=>{var L;let n=uM(t.inputs,s);if(t.inputs[0].dims.length===5)throw new Error("Packed QKV is not implemented");if(((L=t.inputs[1])==null?void 0:L.dims.length)===5)throw new Error("Packed KV is not implemented");let i=t.inputs[0],l=t.inputs[1]&&t.inputs[1].dims.length>0?t.inputs[1]:void 0,o=t.inputs[2]&&t.inputs[2].dims.length>0?t.inputs[2]:void 0,c=t.inputs[3]&&t.inputs[3].dims.length!==0?t.inputs[3]:void 0,p=t.inputs[4]&&t.inputs[4].dims.length!==0?t.inputs[4]:void 0,d=t.inputs.length>4?t.inputs[5]:void 0,f=t.inputs.length>5?t.inputs[6]:void 0,g=n.kvNumHeads?n.kvNumHeads:n.numHeads,_=An({axis:2,numOutputs:3,splitSizes:[n.numHeads*n.headSize,g*n.headSize,g*n.headSize]}),[y,T,b]=!l&&!o?t.compute(A_([i],_),{inputs:[i],outputs:[-1,-1,-1]}):[i,l,o],k=Np(t,n.batchSize,n.numHeads,n.sequenceLength,n.headSize,y,void 0,0);Vp(t,k,qm(t,T,n),qm(t,b,n),void 0,void 0,c,p,void 0,n,d,f)}}),Qm,dM,fM,_1,_E=ot(()=>{Bt(),qt(),au(),Xt(),Qm=(t,s,n,i,l,o,c,p)=>{let d=nr(o),f=d===1?"f32":`vec${d}f`,g=d===1?"vec2f":`mat2x${d}f`,_=l*c,y=64;_===1&&(y=256);let T=[l,c,o/d],b=[l,c,2],k=["rank","type","type"],L=[];L.push(...Ct(T,b));let C=S=>{let I=Ke("x",s.dataType,3,d),O=Ke("scale",n.dataType,n.dims),x=Ke("bias",i.dataType,i.dims),E=Tt("output",1,3,2),A=[I,O,x,E];return`
  var<workgroup> workgroup_shared : array<${g}, ${y}>;
  const workgroup_size = ${y}u;
  ${S.declareVariables(...A)}
  ${S.mainStart(y)}
    let batch = workgroup_index / uniforms.x_shape[1];
    let channel = workgroup_index % uniforms.x_shape[1];
    let hight = uniforms.x_shape[2];
    // initialize workgroup memory
    var sum = ${f}(0);
    var squared_sum = ${f}(0);
    for (var h = local_idx; h < hight; h += workgroup_size) {
      let value = ${f}(${I.get("batch","channel","h")});
      sum += value;
      squared_sum += value * value;
    }
    workgroup_shared[local_idx] = ${g}(sum, squared_sum);
    workgroupBarrier();

    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {
      if (local_idx < currSize) {
        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];
      }
      workgroupBarrier();
    }
    if (local_idx == 0) {
      let sum_final = ${su("workgroup_shared[0][0]",d)} / f32(hight * ${d});
      let squared_sum_final = ${su("workgroup_shared[0][1]",d)} / f32(hight * ${d});

      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${p}));
      let channel_scale = inv_std_dev * f32(scale[channel]);
      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;
      output[workgroup_index] = vec2f(channel_scale, channel_shift);
    }
  }`};return t.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${d};${p};${y}`,inputDependencies:k},getRunData:()=>({outputs:[{dims:b,dataType:1}],dispatchGroup:{x:_},programUniforms:L}),getShaderSource:C},{inputs:[s,n,i],outputs:[-1]})[0]},dM=(t,s,n)=>{let i=s[0].dims,l=i,o=2,c=i[0],p=i[1],d=Ne.sizeFromDimension(i,o),f=nr(d),g=Ne.size(l)/f,_=Qm(t,s[0],s[1],s[2],c,d,p,n.epsilon),y=[c,p,d/f],T=[c,p],b=["type","none"],k=L=>{let C=Ke("x",s[0].dataType,y.length,f),S=Ke("scale_shift",1,T.length,2),I=Tt("output",s[0].dataType,y.length,f),O=[C,S,I];return`
  ${L.registerUniform("output_size","u32").declareVariables(...O)}
  ${L.mainStart()}
  ${L.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let outputIndices = ${I.offsetToIndices("global_idx")};
      let batch = outputIndices[0];
      let channel = outputIndices[1];
      let scale_shift = ${S.getByIndices("vec2<u32>(batch, channel)")};
      let value = ${C.getByOffset("global_idx")} * ${I.type.value}(scale_shift.x) + ${I.type.value}(scale_shift.y);
      ${I.setByOffset("global_idx","value")};
  }`};t.compute({name:"InstanceNormalization",shaderCache:{hint:`${f}`,inputDependencies:b},getRunData:()=>({outputs:[{dims:l,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(g/64)},programUniforms:[{type:12,data:g},...Ct(y,T,y)]}),getShaderSource:k},{inputs:[s[0],_]})},fM=(t,s,n)=>{let i=s[0].dims,l=i,o=i[0],c=i[i.length-1],p=Ne.sizeFromDimension(i,1)/c,d=nr(c),f=Ne.size(l)/d,g=[{type:12,data:p},{type:12,data:Math.floor(c/d)}],_=["type","type"],y=!1,T=[0,i.length-1];for(let C=0;C<i.length-2;C++)y=y||i[C+1]!==1,T.push(C+1);y=y&&i[i.length-1]!==1;let b=y?t.compute(_a(t.inputs[0],T),{inputs:[t.inputs[0]],outputs:[-1]})[0]:t.inputs[0].reshape(Array.from({length:i.length},(C,S)=>i[T[S]])),k=Qm(t,b,s[1],s[2],o,p,c,n.epsilon),L=C=>{let S=zr(s[0].dataType),I=d===1?"vec2f":`mat${d}x2f`,O=A=>{let F=A===0?"x":"y",K=d===1?"f32":`vec${d}f`;switch(d){case 1:return`${S}(${K}(scale.${F}))`;case 2:return`vec2<${S}>(${K}(scale[0].${F}, scale[1].${F}))`;case 4:return`vec4<${S}>(${K}(scale[0].${F}, scale[1].${F}, scale[2].${F}, scale[3].${F}))`;default:throw new Error(`Not supported compoents ${d}`)}},x=Ke("input",s[0].dataType,s[0].dims,d),E=Tt("output",s[0].dataType,l,d);return`
  @group(0) @binding(0) var<storage, read> input : array<${x.type.storage}>;
  @group(0) @binding(1) var<storage, read> scale_input : array<${I}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${E.type.storage}>;
  struct Uniforms {H: u32, C : u32};
  @group(0) @binding(3) var<uniform> uniforms: Uniforms;

  ${C.mainStart()}
    let current_image_number = global_idx / (uniforms.C * uniforms.H);
    let current_channel_number = global_idx % uniforms.C;

    let scale_offset = current_image_number * uniforms.C + current_channel_number;
    let scale = scale_input[scale_offset];
    output[global_idx] = fma(input[global_idx], ${O(0)}, ${O(1)});
  }`};t.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${d}`,inputDependencies:_},getRunData:()=>({outputs:[{dims:l,dataType:s[0].dataType}],dispatchGroup:{x:Math.ceil(f/64)},programUniforms:g}),getShaderSource:L},{inputs:[s[0],k]})},_1=(t,s)=>{s.format==="NHWC"?fM(t,t.inputs,s):dM(t,t.inputs,s)}}),pM,hM,g1,gE=ot(()=>{Bt(),qt(),Xt(),pM=t=>{if(!t||t.length<2)throw new Error("layerNorm requires at least 2 inputs.")},hM=(t,s,n)=>{let i=s.simplified,l=t[0].dims,o=t[1],c=!i&&t[2],p=l,d=Ne.normalizeAxis(s.axis,l.length),f=Ne.sizeToDimension(l,d),g=Ne.sizeFromDimension(l,d),_=Ne.size(o.dims),y=c?Ne.size(c.dims):0;if(_!==g||c&&y!==g)throw new Error(`Size of X.shape()[axis:] == ${g}.
       Size of scale and bias (if provided) must match this.
       Got scale size of ${_} and bias size of ${y}`);let T=[];for(let x=0;x<l.length;++x)x<d?T.push(l[x]):T.push(1);let b=nr(g),k=["type","type"],L=[{type:12,data:f},{type:1,data:g},{type:12,data:Math.floor(g/b)},{type:1,data:s.epsilon}];c&&k.push("type");let C=n>1,S=n>2,I=x=>{let E=zr(t[0].dataType),A=[Ke("x",t[0].dataType,t[0].dims,b),Ke("scale",o.dataType,o.dims,b)];c&&A.push(Ke("bias",c.dataType,c.dims,b)),A.push(Tt("output",t[0].dataType,p,b)),C&&A.push(Tt("mean_data_output",1,T)),S&&A.push(Tt("inv_std_output",1,T));let F=[{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}];return`
  ${x.registerUniforms(F).declareVariables(...A)}
  ${x.mainStart()}
    ${x.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}
    let offset = global_idx * uniforms.norm_size_vectorized;
    var mean_vector = ${v_("f32",b)};
    var mean_square_vector = ${v_("f32",b)};

    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {
      let value = ${Vd(E,b,"x[h + offset]")};
      mean_vector += value;
      mean_square_vector += value * value;
    }
    let mean = ${su("mean_vector",b)} / uniforms.norm_size;
    let inv_std_dev = inverseSqrt(${su("mean_square_vector",b)} / uniforms.norm_size ${i?"":"- mean * mean"} + uniforms.epsilon);

    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {
      let f32input = ${Vd(E,b,"x[j + offset]")};
      let f32scale = ${Vd(E,b,"scale[j]")};
      output[j + offset] = ${A[0].type.value}((f32input ${i?"":"- mean"}) * inv_std_dev * f32scale
        ${c?`+ ${Vd(E,b,"bias[j]")}`:""}
      );
    }

    ${C?"mean_data_output[global_idx] = mean":""};
    ${S?"inv_std_output[global_idx] = inv_std_dev":""};
  }`},O=[{dims:p,dataType:t[0].dataType}];return C&&O.push({dims:T,dataType:1}),S&&O.push({dims:T,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${b};${n};${i}`,inputDependencies:k},getRunData:()=>({outputs:O,dispatchGroup:{x:Math.ceil(f/64)},programUniforms:L}),getShaderSource:I}},g1=(t,s)=>{pM(t.inputs),t.compute(hM(t.inputs,s,t.outputCount))}}),mM,y1,yE=ot(()=>{qt(),eg(),tg(),mM=t=>{if(!t||t.length!==2)throw new Error("MatMul requires 2 inputs.");if(t[0].dims[t[0].dims.length-1]!==t[1].dims[t[1].dims.length-2])throw new Error("shared dimension does not match.")},y1=t=>{mM(t.inputs);let s=Gd.calcShape(t.inputs[0].dims,t.inputs[1].dims,!0);if(!s)throw new Error("Can't use matmul on the given tensors");let n=s[s.length-1],i=t.inputs[0].dims[t.inputs[0].dims.length-1];if(n<8&&i<8)t.compute(J_(t.inputs,{activation:""},s));else{let l=s[s.length-2],o=Ne.size(t.inputs[0].dims.slice(0,-2)),c=Ne.size(t.inputs[1].dims.slice(0,-2));if(o!==1&&l===1&&c===1){let p=t.inputs[0].reshape([1,o,i]),d=t.inputs[1].reshape([1,i,n]),f=[1,o,n],g=[p,d];t.compute(qh(g,{activation:""},s,f),{inputs:g})}else t.compute(qh(t.inputs,{activation:""},s))}}}),_M,gM,yM,M1,v1,ME=ot(()=>{Bt(),qt(),or(),Xt(),_M=(t,s)=>{if(t.length<3||t.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let n=t[0],i=n.dims.length;if(n.dims[i-1]!==s.k)throw new Error("The last dim of input shape does not match the k value");let l=Math.floor((s.k+s.blockSize-1)/s.blockSize),o=s.blockSize/8*s.bits,c=t[1];if(!Ne.areEqual(c.dims,[s.n,l,o]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let p=t[2].dims;if(Ne.size(p)!==s.n*l)throw new Error("scales input size error.");if(t.length===4){let d=t[3].dims,f=s.bits>4?s.n*l:s.n*Math.floor((l+1)/2);if(Ne.size(d)!==f)throw new Error("zeroPoints input size error.")}},gM=(t,s)=>{let n=t[0].dims,i=n.length,l=n[i-2],o=s.k,c=s.n,p=n.slice(0,i-2),d=Ne.size(p),f=t[1].dims[2]/4,g=t[0].dataType,_=nr(s.k),y=nr(f),T=nr(c),b=p.concat([l,c]),k=l>1&&c/T%2===0?2:1,L=Ne.size(b)/T/k,C=64,S=[],I=[d,l,o/_],O=Ne.convertShape(t[1].dims).slice();O.splice(-1,1,f/y),S.push(...Ct(I)),S.push(...Ct(O)),S.push(...Ct(t[2].dims)),t.length===4&&S.push(...Ct(Ne.convertShape(t[3].dims)));let x=[d,l,c/T];S.push(...Ct(x));let E=A=>{let F=I.length,K=Ke("a",t[0].dataType,F,_),X=Ke("b",12,O.length,y),oe=Ke("scales",t[2].dataType,t[2].dims.length),ie=[K,X,oe],J=t.length===4?Ke("zero_points",12,t[3].dims.length):void 0;J&&ie.push(J);let ue=x.length,ne=Tt("output",t[0].dataType,ue,T),G=zr(t[0].dataType),se=(()=>{switch(_){case 1:return`array<${G}, 8>`;case 2:return`mat4x2<${G}>`;case 4:return`mat2x4<${G}>`;default:throw new Error(`${_}-component is not supported.`)}})(),ce=()=>{let U=`
          // reuse a data
            var input_offset = ${K.indicesToOffset(`${K.type.indices}(batch, row, word_offset)`)};
            var a_data: ${se};
            for (var j: u32 = 0; j < ${8/_}; j++) {
              a_data[j] = ${K.getByOffset("input_offset")};
              input_offset++;
            }
          `;for(let B=0;B<T*k;B++)U+=`
            b_value = ${y===1?`b${B}_data`:`b${B}_data[i]`};
            b_value_lower = unpack4xU8(b_value & b_mask);
            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);
            b_quantized_values = ${se}(${Array.from({length:4},(Q,le)=>`${G}(b_value_lower[${le}]), ${G}(b_value_upper[${le}])`).join(", ")});
            b_dequantized_values = ${_===1?`${se}(${Array.from({length:8},(Q,le)=>`(b_quantized_values[${le}] - ${J?`zero_point${B}`:"zero_point"}) * scale${B}`).join(", ")});`:`(b_quantized_values - ${se}(${Array(8).fill(`${J?`zero_point${B}`:"zero_point"}`).join(",")})) * scale${B};`};
            workgroup_shared[local_id.x * ${k} + ${Math.floor(B/T)}]${T>1?`[${B%T}]`:""} += ${Array.from({length:8/_},(Q,le)=>`${_===1?`a_data[${le}] * b_dequantized_values[${le}]`:`dot(a_data[${le}], b_dequantized_values[${le}])`}`).join(" + ")};
          `;return U},ge=()=>{let U=`
            var col_index = col * ${T};
            ${J?`
            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;
            var zero_point_byte_count: u32;
            var zero_point_word_index: u32;
            var zero_point_byte_offset: u32;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            var zero_point_bits_offset: u32;
            var zero_point_word: u32;`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${G}(8);`}
            `;for(let B=0;B<T*k;B++)U+=`
            let scale${B} = ${oe.getByOffset("col_index * nBlocksPerCol + block")};
            ${J?`
            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);
            zero_point_word_index = zero_point_byte_count >> 0x2u;
            zero_point_byte_offset = zero_point_byte_count & 0x3u;
            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            zero_point_word = ${J.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point${B} = ${G}((zero_point_word) & 0xFu);`:""}
            col_index += 1;`;return U},W=()=>{let U=`col_index = col * ${T};`;for(let B=0;B<T*k;B++)U+=`
            let b${B}_data = ${X.getByIndices(`${X.type.indices}(col_index, block, word)`)};
            col_index += 1;`;return U+=`
            var b_value: u32;
            let b_mask: u32 = 0x0F0F0F0Fu;
            var b_value_lower: vec4<u32>;
            var b_value_upper: vec4<u32>;
            var b_quantized_values: ${se};
            var b_dequantized_values: ${se};`,U};return`
        var<workgroup> workgroup_shared: array<${ne.type.value}, ${k*C}>;
        ${A.declareVariables(...ie,ne)}
        ${A.mainStart([C,1,1])}
          let output_indices = ${ne.offsetToIndices(`(global_idx / ${C}) * ${k}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let nBlocksPerCol = uniforms.b_shape[1];

          for (var block = local_id.x; block < nBlocksPerCol; block += ${C}) {
            //process one block
            var word_offset: u32 = block * ${s.blockSize/_};
            ${ge()}
            for (var word: u32 = 0; word < ${f}; word += ${y}) {
              ${W()}
              for (var i: u32 = 0; i < ${y}; i++) {
                ${ce()}
                word_offset += ${8/_};
              }
            }
          }
          workgroupBarrier();

          if (local_id.x < ${k}) {
            var output_value: ${ne.type.value} = ${ne.type.value}(0);
            var workgroup_shared_offset: u32 = local_id.x;
            for (var b: u32 = 0u; b < ${C}u; b++) {
              output_value += workgroup_shared[workgroup_shared_offset];
              workgroup_shared_offset += ${k};
            }
            ${ne.setByIndices(`${ne.type.indices}(batch, row, col + local_id.x)`,"output_value")};
          }
        }`};return{name:"MatMulNBits",shaderCache:{hint:`${s.blockSize};${s.bits};${_};${y};${T};${k};${C}`,inputDependencies:Array(t.length).fill("rank")},getRunData:()=>({outputs:[{dims:b,dataType:g}],dispatchGroup:{x:L},programUniforms:S}),getShaderSource:E}},yM=(t,s)=>{let n=t[0].dims,i=n.length,l=n[i-2],o=s.k,c=s.n,p=n.slice(0,i-2),d=Ne.size(p),f=t[1].dims[2]/4,g=t[0].dataType,_=nr(s.k),y=nr(f),T=p.concat([l,c]),b=128,k=c%8===0?8:c%4===0?4:1,L=b/k,C=L*y*8,S=C/_,I=C/s.blockSize,O=Ne.size(T)/k,x=[],E=[d,l,o/_],A=Ne.convertShape(t[1].dims).slice();A.splice(-1,1,f/y),x.push(...Ct(E)),x.push(...Ct(A)),x.push(...Ct(t[2].dims)),t.length===4&&x.push(...Ct(Ne.convertShape(t[3].dims)));let F=[d,l,c];x.push(...Ct(F));let K=X=>{let oe=E.length,ie=Ke("a",t[0].dataType,oe,_),J=Ke("b",12,A.length,y),ue=Ke("scales",t[2].dataType,t[2].dims.length),ne=[ie,J,ue],G=t.length===4?Ke("zero_points",12,t[3].dims.length):void 0;G&&ne.push(G);let se=F.length,ce=Tt("output",t[0].dataType,se),ge=zr(t[0].dataType),W=()=>{switch(_){case 1:return`
          let a_data0 = vec4<${ge}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);
          let a_data1 = vec4<${ge}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`
          let a_data0 = vec4<${ge}>(sub_a[word_offset], sub_a[word_offset + 1]);
          let a_data1 = vec4<${ge}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return`
          let a_data0 = sub_a[word_offset];
          let a_data1 = sub_a[word_offset + 1];`;default:throw new Error(`${_}-component is not supported.`)}};return`
        var<workgroup> sub_a: array<${ie.type.value}, ${S}>;
        var<workgroup> inter_results: array<array<${ce.type.value}, ${L}>, ${k}>;
        ${X.declareVariables(...ne,ce)}
        ${X.mainStart([L,k,1])}
          let output_indices = ${ce.offsetToIndices(`workgroup_index * ${k}`)};
          let col = output_indices[2];
          let row = output_indices[1];
          let batch = output_indices[0];
          let n_blocks_per_col = uniforms.b_shape[1];
          let num_tiles =  (n_blocks_per_col - 1) / ${I} + 1;

          // Loop over shared dimension.
          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {
            let a_col_start = tile * ${S};
            // load one tile A data into shared memory.
            for (var a_offset = local_idx; a_offset < ${S}; a_offset += ${b})
            {
              let a_col = a_col_start + a_offset;
              if (a_col < uniforms.a_shape[2])
              {
                sub_a[a_offset] = ${ie.getByIndices(`${ie.type.indices}(batch, row, a_col)`)};
              } else {
                sub_a[a_offset] = ${ie.type.value}(0);
              }
            }
            workgroupBarrier();

            // each thread process one block
            let b_row = col + local_id.y;
            let block = tile * ${I} + local_id.x;
            ${G?`
            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;
            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);
            let zero_point_word_index = zero_point_byte_count >> 0x2u;
            let zero_point_byte_offset = zero_point_byte_count & 0x3u;
            let zero_point_nibble_offset: u32 = block & 0x1u;
            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);
            let zero_point_word = ${G.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;
            let zero_point = ${ge}((zero_point_word) & 0xFu);`:`
            // The default zero point is 8 for unsigned 4-bit quantization.
            let zero_point = ${ge}(8);`}
            let scale = ${ue.getByOffset("b_row * n_blocks_per_col + block")};
            let b_data = ${J.getByIndices(`${J.type.indices}(b_row, block, 0)`)};
            var word_offset = local_id.x * ${s.blockSize/_};
            for (var i: u32 = 0; i < ${y}; i++) {
              ${W()}
              let b_value = ${y===1?"b_data":"b_data[i]"};
              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);
              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);
              let b_quantized_values = mat2x4<${ge}>(${Array.from({length:4},(U,B)=>`${ge}(b_value_lower[${B}]), ${ge}(b_value_upper[${B}])`).join(", ")});
              let b_dequantized_values = (b_quantized_values - mat2x4<${ge}>(${Array(8).fill("zero_point").join(",")})) * scale;
              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},(U,B)=>`${`dot(a_data${B}, b_dequantized_values[${B}])`}`).join(" + ")};
              word_offset += ${8/_};
            }
            workgroupBarrier();
          }

          if (local_idx < ${k}) {
            var output_value: ${ce.type.value} = ${ce.type.value}(0);
            for (var b = 0u; b < ${L}; b++) {
              output_value += inter_results[local_idx][b];
            }
            if (col + local_idx < uniforms.output_shape[2])
            {
              ${ce.setByIndices(`${ce.type.indices}(batch, row, col + local_idx)`,"output_value")}
            }
          }
        }`};return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${s.blockSize};${_};${y};${L};${k}`,inputDependencies:Array(t.length).fill("rank")},getRunData:()=>({outputs:[{dims:T,dataType:g}],dispatchGroup:{x:O},programUniforms:x}),getShaderSource:K}},M1=(t,s)=>{_M(t.inputs,s),s.blockSize===32&&t.adapterInfo.isVendor("intel")&&t.adapterInfo.isArchitecture("gen-12lp")?t.compute(yM(t.inputs,s)):t.compute(gM(t.inputs,s))},v1=t=>An(t)}),MM,vM,wM,bM,TM,xM,EM,SM,w1,vE=ot(()=>{Bt(),qt(),Xt(),MM=t=>{if(!t||t.length<1)throw new Error("Too few inputs");if(t[0].dataType!==1&&t[0].dataType!==10)throw new Error("Input type must be float or float16.");if(t.length>=2){let s=t[0].dims.length*2===t[1].dims[0];if(t.length===4&&(s=t[3].dims[0]*2===t[1].dims[0]),!s)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},vM=(t,s,n)=>{let i="";for(let l=s-1;l>=0;--l)i+=`
            k = i32(${t.indicesGet("indices",l)}) - ${xt("uniforms.pads",l,n)};
            if (k < 0) {
              break;
            }
            if (k >= i32(${xt("uniforms.x_shape",l,s)})) {
              break;
            }
            offset += k * i32(${xt("uniforms.x_strides",l,s)});
        `;return`
          value = ${t.type.value}(uniforms.constant_value);
          for (var i = 0; i < 1; i++) {
            var offset = 0;
            var k = 0;
            ${i}
            value = x[offset];
          }
      `},wM=(t,s,n)=>{let i="";for(let l=s-1;l>=0;--l)i+=`
                k = i32(${t.indicesGet("indices",l)}) - ${xt("uniforms.pads",l,n)};
                if (k < 0) {
                  k = -k;
                }
                {
                  let _2n_1 = 2 * (i32(${xt("uniforms.x_shape",l,s)}) - 1);
                  k = k % _2n_1;
                  if(k >= i32(${xt("uniforms.x_shape",l,s)})) {
                    k = _2n_1 - k;
                  }
                }
                offset += k * i32(${xt("uniforms.x_strides",l,s)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},bM=(t,s,n)=>{let i="";for(let l=s-1;l>=0;--l)i+=`
                k = i32(${t.indicesGet("indices",l)}) - ${xt("uniforms.pads",l,n)};
                if (k < 0) {
                  k = 0;
                }
                if (k >= i32(${xt("uniforms.x_shape",l,s)})) {
                  k = i32(${xt("uniforms.x_shape",l,s)}) - 1;
                }
                offset += k * i32(${xt("uniforms.x_strides",l,s)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},TM=(t,s,n)=>{let i="";for(let l=s-1;l>=0;--l)i+=`
                k = i32(${t.indicesGet("indices",l)}) - ${xt("uniforms.pads",l,n)};
                if (k < 0)  {
                  k += i32(${xt("uniforms.x_shape",l,s)}]);
                }
                if (k >= i32(${xt("uniforms.x_shape",l,s)})) {
                  k -= i32(${xt("uniforms.x_shape",l,s)});
                }
                offset += k * i32(${xt("uniforms.x_strides",l,s)});
            `;return`
              var offset = 0;
              var k = 0;
              ${i}
              value = x[offset];
          `},xM=(t,s,n)=>{switch(n.mode){case 0:return vM(t,s,n.pads.length);case 1:return wM(t,s,n.pads.length);case 2:return bM(t,s,n.pads.length);case 3:return TM(t,s,n.pads.length);default:throw new Error("Invalid mode")}},EM=(t,s)=>{let n=Ne.padShape(t[0].dims.slice(),s.pads),i=t[0].dims,l=Ne.size(n),o=[{type:12,data:l},{type:6,data:s.pads}],c=t.length>=3&&t[2].data;s.mode===0&&o.push({type:c?t[2].dataType:1,data:s.value}),o.push(...Ct(t[0].dims,n));let p=["rank"],d=f=>{let g=Tt("output",t[0].dataType,n.length),_=Ke("x",t[0].dataType,i.length),y=_.type.value,T=xM(g,i.length,s),b=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:s.pads.length}];return s.mode===0&&b.push({name:"constant_value",type:c?y:"f32"}),`
            ${f.registerUniforms(b).declareVariables(_,g)}
            ${f.mainStart()}
            ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}

            let indices = ${g.offsetToIndices("global_idx")};

            var value = ${y}(0);
            ${T}
            output[global_idx] = value;
        }`};return{name:"Pad",shaderCache:{hint:`${s.mode}${c}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:n,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(Ne.size(n)/64)},programUniforms:o}),getShaderSource:d}},SM=(t,s)=>{if(t.length>1){let n=t[1].getBigInt64Array(),i=t.length>=3&&t[2].data?t[2].dataType===10?t[2].getUint16Array()[0]:t[2].getFloat32Array()[0]:0,l=t[0].dims.length,o=new Int32Array(2*l).fill(0);if(t.length>=4){let p=t[3].getBigInt64Array();for(let d=0;d<p.length;d++)o[Number(p[d])]=Number(n[d]),o[Number(p[d])+l]=Number(n[d+p.length])}else n.forEach((p,d)=>o[Number(d)]=Number(p));let c=[];return o.forEach(p=>c.push(p)),{mode:s.mode,value:i,pads:c}}else return s},w1=(t,s)=>{MM(t.inputs);let n=SM(t.inputs,s);t.compute(EM(t.inputs,n),{inputs:[0]})}}),Dp,Xm,Ym,Zm,Jm,CM,PM,e_,t_,b1,T1,n_,x1,E1,r_,S1,C1,P1,A1,wE=ot(()=>{xi(),Bt(),qt(),Xt(),Dp=t=>{if(Hn.webgpu.validateInputContent&&(!t||t.length!==1))throw new Error("Pool ops requires 1 input.")},Xm=(t,s,n)=>{let i=s.format==="NHWC",l=t.dims.slice();i&&l.splice(1,0,l.pop());let o=Object.hasOwnProperty.call(s,"dilations"),c=s.kernelShape.slice(),p=s.strides.slice(),d=o?s.dilations.slice():[],f=s.pads.slice();Hh.adjustPoolAttributes(n,l,c,p,d,f);let g=Hh.computePoolOutputShape(n,l,p,d,c,f,s.autoPad),_=Object.assign({},s);o?Object.assign(_,{kernelShape:c,strides:p,pads:f,dilations:d,cacheKey:s.cacheKey}):Object.assign(_,{kernelShape:c,strides:p,pads:f,cacheKey:s.cacheKey});let y=g.slice();return y.push(y.splice(1,1)[0]),[_,i?y:g]},Ym=(t,s)=>{let n=s.format==="NHWC",i=Ne.size(t),l=Ne.size(s.kernelShape),o=[{type:12,data:i},{type:12,data:l}],c=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(s.kernelShape.length<=2){let p=s.kernelShape[s.kernelShape.length-1],d=s.strides[s.strides.length-1],f=s.pads[s.pads.length/2-1],g=s.pads[s.pads.length-1],_=!!(f+g);o.push({type:12,data:p},{type:12,data:d},{type:12,data:f},{type:12,data:g}),c.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let y=!1;if(s.kernelShape.length===2){let T=s.kernelShape[s.kernelShape.length-2],b=s.strides[s.strides.length-2],k=s.pads[s.pads.length/2-2],L=s.pads[s.pads.length-2];y=!!(k+L),o.push({type:12,data:T},{type:12,data:b},{type:12,data:k},{type:12,data:L}),c.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[o,c,!0,_,y]}else{if(n)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let p=Ne.computeStrides(s.kernelShape);o.push({type:12,data:p},{type:12,data:s.pads},{type:12,data:s.strides}),c.push({name:"kernelStrides",type:"u32",length:p.length},{name:"pads",type:"u32",length:s.pads.length},{name:"strides",type:"u32",length:s.strides.length});let d=s.pads.reduce((f,g)=>f+g);return[o,c,!!d,!1,!1]}},Zm=(t,s,n,i,l,o,c,p,d,f,g,_)=>{let y=l.format==="NHWC",T=s.type.value,b=Tt("output",s.type.tensor,i);if(l.kernelShape.length<=2){let k="",L="",C="",S=n-(y?2:1);if(g?k=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sw - uniforms.pwStart + i;
                  if (xIndices[${S}] < 0 || xIndices[${S}]
                      >= uniforms.x_shape[${S}]) {
                    pad++;
                    continue;
                  }
                  let x_val = x[${s.indicesToOffset("xIndices")}];
                  ${o}
                }`:k=`
                for (var i: u32 = 0u; i < uniforms.kw; i++) {
                  xIndices[${S}] = indices[${S}] * uniforms.sw - uniforms.pwStart + i;
                  let x_val = x[${s.indicesToOffset("xIndices")}];
                  ${o}
                }`,l.kernelShape.length===2){let I=n-(y?3:2);_?L=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${I}] = indices[${I}] * uniforms.sh - uniforms.phStart + j;
                  if (xIndices[${I}] < 0 || xIndices[${I}] >= uniforms.x_shape[${I}]) {
                    pad += i32(uniforms.kw);
                    continue;
                  }
              `:L=`
                for (var j: u32 = 0u; j < uniforms.kh; j++) {
                  xIndices[${I}] = indices[${I}] * uniforms.sh - uniforms.phStart + j;
                `,C=`
              }
            `}return`
            ${t.registerUniforms(d).declareVariables(s,b)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}

              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var value = ${T}(${p});
              var pad = 0;
              ${L}
              ${k}
              ${C}
              ${c}

              output[global_idx] = value;
            }`}else{if(y)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let k=l.kernelShape.length,L=l.pads.length,C="";return f?C=`
                if (xIndices[j] >= uniforms.x_shape[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${s.indicesToOffset("xIndices")}];
                ${o}
              }`:C=`
              }
              let x_val = x[${s.indicesToOffset("xIndices")}];
              ${o}
            `,`
            ${t.registerUniforms(d).declareVariables(s,b)}

            ${t.mainStart()}
              ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
              let indices = ${b.offsetToIndices("global_idx")};
              var xIndices = ${b.offsetToIndices("global_idx")};

              var offsets: array<u32, ${k}>;

              var value = ${T}(${p});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {
                var offset = i;
                for (var j = 0u; j < ${k-1}u; j++) {
                  offsets[j] = offset / ${xt("uniforms.kernelStrides","j",k)};
                  offset -= offsets[j] * ${xt("uniforms.kernelStrides","j",k)};
                }
                offsets[${k-1}] = offset;

                isPad = false;
                for (var j = ${n-k}u; j < ${n}u; j++) {
                  xIndices[j] = indices[j] * ${xt("uniforms.strides",`j - ${n-k}u`,k)}
                    + offsets[j - ${n-k}u] - ${xt("uniforms.pads","j - 2u",L)};
                  ${C}
              }
              ${c}

              output[global_idx] = value;
            }`}},Jm=t=>`${t.format};${t.ceilMode};${t.autoPad};${t.kernelShape.length}`,CM=t=>`${Jm(t)};${t.countIncludePad}`,PM=t=>`${Jm(t)};${t.storageOrder};${t.dilations}`,e_=t=>({format:t.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][t.auto_pad],ceilMode:t.ceil_mode,kernelShape:t.kernel_shape,strides:t.strides,pads:t.pads}),t_=(t,s,n,i)=>{let[l,o]=Xm(s,i,n),c=Ke("x",s.dataType,s.dims.length),p=c.type.value,d="value += x_val;",f="";l.countIncludePad?f+=`value /= ${p}(uniforms.kernelSize);`:f+=`value /= ${p}(i32(uniforms.kernelSize) - pad);`;let[g,_,y,T,b]=Ym(o,l);g.push(...Ct(s.dims,o));let k=["rank"];return{name:t,shaderCache:{hint:`${i.cacheKey};${y};${T};${b}`,inputDependencies:k},getRunData:()=>({outputs:[{dims:o,dataType:s.dataType}],dispatchGroup:{x:Math.ceil(Ne.size(o)/64)},programUniforms:g}),getShaderSource:L=>Zm(L,c,s.dims.length,o.length,l,d,f,0,_,y,T,b)}},b1=t=>{let s=t.count_include_pad!==0,n=e_(t);if(n.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let i={countIncludePad:s,...n,cacheKey:""};return{...i,cacheKey:CM(i)}},T1=(t,s)=>{Dp(t.inputs),t.compute(t_("AveragePool",t.inputs[0],!1,s))},n_={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},x1=t=>{let s=t.format;return{format:s,...n_,cacheKey:s}},E1=(t,s)=>{Dp(t.inputs),t.compute(t_("GlobalAveragePool",t.inputs[0],!0,s))},r_=(t,s,n,i)=>{let[l,o]=Xm(s,i,n),c=`
      value = max(x_val, value);
    `,p="",d=Ke("x",s.dataType,s.dims.length),f=["rank"],[g,_,y,T,b]=Ym(o,l);return g.push(...Ct(s.dims,o)),{name:t,shaderCache:{hint:`${i.cacheKey};${y};${T};${b}`,inputDependencies:f},getRunData:()=>({outputs:[{dims:o,dataType:s.dataType}],dispatchGroup:{x:Math.ceil(Ne.size(o)/64)},programUniforms:g}),getShaderSource:k=>Zm(k,d,s.dims.length,o.length,l,c,p,s.dataType===10?-65504:-1e5,_,y,T,b)}},S1=(t,s)=>{Dp(t.inputs),t.compute(r_("MaxPool",t.inputs[0],!1,s))},C1=t=>{let s=t.storage_order,n=t.dilations,i=e_(t);if(s!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i.ceilMode!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let l={storageOrder:s,dilations:n,...i,cacheKey:""};return{...l,cacheKey:PM(l)}},P1=t=>{let s=t.format;return{format:s,...n_,cacheKey:s}},A1=(t,s)=>{Dp(t.inputs),t.compute(r_("GlobalMaxPool",t.inputs[0],!0,s))}}),AM,$M,$1,O1,bE=ot(()=>{Bt(),qt(),or(),Xt(),AM=(t,s)=>{if(t.length<2||t.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(t.length===3&&t[1].dims===t[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(t.length===3&&t[0].dataType!==t[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(t[0].dataType===6&&t.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(t[1].dims.length!==0&&t[1].dims.length!==1&&t[1].dims.length!==t[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(t.length>2){if(t[0].dataType!==t[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(t[1].dims.length!==t[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!t[1].dims.map((n,i)=>n===t[2].dims[i]).reduce((n,i)=>n&&i,!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(s.blockSize>0){if(t[1].dims.length===0||t[1].dims.length===1&&t[1].dims[0]===1)throw new Error("blockSize must be set only for block quantization.");if(!t[1].dims.map((l,o)=>o===s.axis||l===t[0].dims[o]).reduce((l,o)=>l&&o,!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(t[1].dims.length!==t[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let n=t[0].dims[s.axis],i=t[1].dims[s.axis];if(s.blockSize<Math.ceil(n/i)||s.blockSize>Math.ceil(n/(i-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},$M=(t,s)=>{let n=Ne.normalizeAxis(s.axis,t[0].dims.length),i=t[0].dataType,l=i===3,o=t[0].dims,c=t[1].dataType,p=Ne.size(o),d=i===3||i===2,f=d?[Math.ceil(Ne.size(t[0].dims)/4)]:t[0].dims,g=t[1].dims,_=t.length>2?t[2]:void 0,y=_?d?[Math.ceil(Ne.size(_.dims)/4)]:_.dims:void 0,T=g.length===0||g.length===1&&g[0]===1,b=T===!1&&g.length===1,k=nr(p),L=T&&(!d||k===4),C=L?k:1,S=L&&!d?k:1,I=Ke("input",d?12:i,f.length,S),O=Ke("scale",c,g.length),x=_?Ke("zero_point",d?12:i,y.length):void 0,E=Tt("output",c,o.length,C),A=[I,O];x&&A.push(x);let F=[f,g];_&&F.push(y);let K=[{type:12,data:p/C},{type:12,data:n},{type:12,data:s.blockSize},...Ct(...F,o)],X=oe=>{let ie=[{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}];return`
      ${oe.registerUniforms(ie).declareVariables(...A,E)}
      ${oe.mainStart()}
          ${oe.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
          let output_indices = ${E.offsetToIndices("global_idx")};

          // Set input x
          ${d?`
            let input = ${I.getByOffset("global_idx / 4")};
            let x_vec = ${l?"unpack4xI8(input)":"unpack4xU8(input)"};
            let x_value = ${C===1?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${I.getByOffset("global_idx")};`};

          // Set scale input
          ${T?`let scale_value= ${O.getByOffset("0")}`:b?`
            let scale_index = ${E.indicesGet("output_indices","uniforms.axis")};
            let scale_value= ${O.getByOffset("scale_index")};`:`
            var scale_indices: ${O.type.indices} = output_indices;
            let index = ${O.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;
            ${O.indicesSet("scale_indices","uniforms.axis","index")};
            let scale_value= ${O.getByIndices("scale_indices")};`};

          // Set zero-point input
          ${x?T?d?`
                let zero_point_input = ${x.getByOffset("0")};
                let zero_point_vec =  ${l?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${x.getByOffset("0")}`:b?d?`
                let zero_point_index = ${E.indicesGet("output_indices","uniforms.axis")};
                let zero_point_input = ${x.getByOffset("zero_point_index / 4")};
                let zero_point_vec =  ${l?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`
                let zero_point_index = ${E.indicesGet("output_indices","uniforms.axis")};
                let zero_point_value = ${x.getByOffset("zero_point_index")};`:d?`
                let zero_point_offset = ${O.indicesToOffset("scale_indices")};
                let zero_point_input = ${x.getByOffset("zero_point_offset / 4")};
                let zero_point_vec = ${l?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};
                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${x.getByIndices("scale_indices")};`:`let zero_point_value = ${d?l?"i32":"u32":I.type.value}(0);`};
      // Compute and write output
      ${E.setByOffset("global_idx",`${E.type.value}(x_value - zero_point_value) * scale_value`)};
      }`};return{name:"DequantizeLinear",shaderCache:{hint:s.cacheKey,inputDependencies:x?["rank","rank","rank"]:["rank","rank"]},getShaderSource:X,getRunData:()=>({outputs:[{dims:o,dataType:c}],dispatchGroup:{x:Math.ceil(p/C/64),y:1,z:1},programUniforms:K})}},$1=(t,s)=>{AM(t.inputs,s),t.compute($M(t.inputs,s))},O1=t=>An({axis:t.axis,blockSize:t.blockSize})}),OM,kM,k1,TE=ot(()=>{xi(),Bt(),Xt(),OM=(t,s,n)=>{let i=t===s,l=t<s&&n<0,o=t>s&&n>0;if(i||l||o)throw new Error("Range these inputs' contents are invalid.")},kM=(t,s,n,i)=>{let l=Math.abs(Math.ceil((s-t)/n)),o=[l],c=l,p=[{type:12,data:c},{type:i,data:t},{type:i,data:n},...Ct(o)],d=f=>{let g=Tt("output",i,o.length),_=g.type.value,y=[{name:"outputSize",type:"u32"},{name:"start",type:_},{name:"delta",type:_}];return`
        ${f.registerUniforms(y).declareVariables(g)}
        ${f.mainStart()}
        ${f.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
        output[global_idx] = uniforms.start + ${_}(global_idx) * uniforms.delta;
      }`};return{name:"Range",shaderCache:{hint:`${i}`},getShaderSource:d,getRunData:()=>({outputs:[{dims:o,dataType:i}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:p})}},k1=t=>{let s=0,n=0,i=0;t.inputs[0].dataType===6?(s=t.inputs[0].getInt32Array()[0],n=t.inputs[1].getInt32Array()[0],i=t.inputs[2].getInt32Array()[0]):t.inputs[0].dataType===1&&(s=t.inputs[0].getFloat32Array()[0],n=t.inputs[1].getFloat32Array()[0],i=t.inputs[2].getFloat32Array()[0]),Hn.webgpu.validateInputContent&&OM(s,n,i),t.compute(kM(s,n,i,t.inputs[0].dataType),{inputs:[]})}}),DM,IM,D1,I1,xE=ot(()=>{Bt(),qt(),or(),Xt(),DM=(t,s,n,i)=>{if(t!=="none"&&i!=="i32"&&i!=="u32"&&i!=="f32")throw new Error(`Input ${i} is not supported with reduction ${t}.`);let l=`{
                var oldValue = 0;
                loop {
                  let newValueF32 =`,o=`;
                  let newValue = bitcast<i32>(newValueF32);
                  let res = atomicCompareExchangeWeak(&${s}, oldValue, newValue);
                  if res.exchanged {
                    break;
                  }
                  oldValue = res.old_value;
                }
              }`;switch(t){case"none":return`${s}=${n};`;case"add":return i==="i32"||i==="u32"?`atomicAdd(&${s}, bitcast<${i}>(${n}));`:`
              ${l}bitcast<${i}>(oldValue) + (${n})${o}`;case"max":return i==="i32"||i==="u32"?`atomicMax(&${s}, bitcast<${i}>(${n}));`:`
                ${l}max(bitcast<f32>(oldValue), (${n}))${o}`;case"min":return i==="i32"||i==="u32"?`atomicMin(&${s}, bitcast<${i}>(${n}));`:`${l}min(bitcast<${i}>(oldValue), (${n}))${o}`;case"mul":return`${l}(bitcast<${i}>(oldValue) * (${n}))${o}`;default:throw new Error(`Reduction ${t} is not supported.`)}},IM=(t,s)=>{let n=t[0].dims,i=t[1].dims,l=n,o=1,c=Math.ceil(Ne.size(i)/o),p=i[i.length-1],d=Ne.sizeFromDimension(n,p),f=[{type:12,data:c},{type:12,data:p},{type:12,data:d},...Ct(t[1].dims,t[2].dims,l)],g=_=>{let y=Ke("indices",t[1].dataType,t[1].dims.length),T=Ke("updates",t[2].dataType,t[2].dims.length,o),b=s.reduction!=="none"&&s.reduction!==""?cw("output",t[0].dataType,l.length):Tt("output",t[0].dataType,l.length,o);return`
      ${_.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(y,T,b)}
      ${_.mainStart()}
        ${_.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
  var hasDuplicates = false;
  if (${s.reduction==="none"}) {
    let n = ${Ne.size(i)};
    for (var i = 0; i < n; i = i + 1) {
      for (var j = i + 1; j < n; j = j + 1) {
        var index_i = i32(indices[i].x);
        var index_j = i32(indices[j].x);
        if (index_i == index_j) {
          hasDuplicates = true;
          break;
        }
      }
      if (hasDuplicates) {
        break;
      }
    }
  }

  var data_offset = 0u;
  var indices_start = uniforms.last_index_dimension * global_idx;
  if (${s.reduction==="none"} && hasDuplicates) {
    if (global_idx != 0u) {
      return;
    }
    indices_start = 0u;
  }
  let indices_end = indices_start + uniforms.last_index_dimension;
  for (var i = indices_start; i < indices_end; i++) {
    var index = i32(indices[i].x);
    ${t[0].dims.length===1?`
    let element_count_dim = uniforms.output_strides;
    let dim_value = uniforms.output_shape;`:`
    let element_count_dim = uniforms.output_strides[i - indices_start];
    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}
    if (index >= 0) {
      if (index >= i32(dim_value)) {
        index = i32(dim_value - 1);
      }
    } else {
      if (index < -i32(dim_value)) {
        index = 0;
      } else {
        index += i32(dim_value);
      }
    }
    data_offset += u32((u32(index) * element_count_dim));
  }

  for (var i = 0u; i < uniforms.num_updates_elements; i++) {
    let value = updates[uniforms.num_updates_elements * global_idx + i];
    ${DM(s.reduction,"output[data_offset + i]","value",b.type.value)}
  }

      }`};return{name:"ScatterND",shaderCache:{hint:`${s.cacheKey}_${s.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:l,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(c/64)},programUniforms:f}),getShaderSource:g}},D1=t=>An({reduction:t.reduction}),I1=(t,s)=>{t.compute(IM(t.inputs,s),{inputs:[t.inputs[1],t.inputs[2]],outputs:[]})}}),zM,FM,LM,s_,BM,RM,NM,jM,UM,VM,GM,WM,a_,HM,KM,qM,QM,XM,z1,F1,EE=ot(()=>{Bt(),qt(),or(),Xt(),zM=(t,s)=>{if(t.every(n=>n>0||(()=>{throw new Error("Resize requires scales input values to be positive")})),t.length>0){if(s.mode==="linear"){if(!(t.length===2||t.length===3||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1||t.length===5&&t[0]===1&&t[1]===1))throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and
            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`)}else if(s.mode==="cubic"&&!(t.length===2||t.length===4&&t[0]===1&&t[1]===1||t.length===4&&t[0]===1&&t[3]===1))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")}},FM=(t,s,n)=>{s.every(l=>l>=0&&l<n||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")}));let i=new Array(n).fill(1);return s.forEach((l,o)=>i[l]=t[o]),i},LM=(t,s,n,i,l,o)=>{let[c,p,d]=n>10?[1,2,3]:[-1,t.length>1?1:-1,-1],f=t[0].dims.length;if(c>0&&t.length>c&&t[c].dims.length>0)t[c].getFloat32Array().forEach(g=>o.push(g));else if(s.coordinateTransformMode==="tf_crop_and_resize")throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(p>0&&t.length>p&&t[p].dims.length===1&&t[p].dims[0]>0){if(t[p].getFloat32Array().forEach(g=>i.push(g)),i.length!==0&&i.length!==f&&n>=18&&i.length!==s.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");zM(i,s),s.axes.length>0&&FM(i,s.axes,f).forEach((g,_)=>i[_]=g)}if(d>0&&t.length>d&&t[d].dims.length===1&&t[d].dims[0]>0&&(t[d].getBigInt64Array().forEach(g=>l.push(Number(g))),l.length!==0&&l.length!==f&&n>=18&&l.length!==s.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(s.axes.length>0){if(i.length!==0&&i.length!==s.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(l.length!==0&&l.length!==s.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof i<"u"&&typeof l<"u"&&i.length>0&&l.length>f)throw new Error("Resize requires only of scales or sizes to be specified")},s_=(t,s,n,i)=>`
  // The whole part and the fractional part are calculated separately due to inaccuracy of floating
  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an
  // offset-by-one error later in floor().
  let big = (${t}) * (${s});
  let whole = ${i}(big / (${n}));
  let fract = ${i}(big % (${n})) / ${i}(${n});
  return whole + fract;
`,BM=(t,s)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,
     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${s} { `+(()=>{switch(t){case"asymmetric":return`
          if (xScale < 1.0 || floor(xScale) != xScale) {
            return ${s}(xResized) / ${s}(xScale);
          } else {
            ${s_("xResized","lengthOriginal","lengthResized",s)}
          }
        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {
                    return (${s}(xResized) + 0.5) / ${s}(xScale) - 0.5;
                  } else {
                    return 0.0;
                  }`;case"tf_half_pixel_for_nn":return`return (${s}(xResized) + 0.5) / ${s}(xScale);`;case"align_corners":return`if (lengthResized == 1) {
                    return 0.0;
                  } else {
                    ${s_("xResized","lengthOriginal - 1","lengthResized - 1",s)}
                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {
                    return ${s}(roiStart) * ${s}(lengthOriginal - 1) +
                        (${s}(xResized) * ${s}(roiEnd - roiStart) * ${s}(lengthOriginal - 1)) /
                        ${s}(lengthResized - 1);
                  } else {
                    return 0.5 * ${s}(roiStart + roiEnd) * ${s}(lengthOriginal - 1);
                  }`;case"half_pixel_symmetric":return`const outputWidth = ${s}xScale * ${s}(lengthResized);
                  const adjustment = ${s}(lengthResized) / outputWidth;
                  const center = ${s}(lengthOriginal) / 2;
                  const offset = center * (1 - adjustment);
                  return offset + ((${s}(xResized) + 0.5) / ${s}(xScale)) - 0.5;`;case"half_pixel":return`return ((${s}(xResized) + 0.5) / ${s}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${t} is not supported`)}})()+"}",RM=(t,s,n)=>`fn getNearestPixelFromOriginal(xOriginal: ${n}, isDownSample: bool) -> ${n} {`+(()=>{switch(t){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";case"simple":default:if(s<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${t} is not supported`)}})()+"}",NM=(t,s,n)=>{let i=new Array(n).fill(0).concat(new Array(n).fill(1)),l=t.length===0?i:t.slice();return s.length>0?(s.forEach((o,c)=>{i[o]=l[c],i[c+n]=l[s.length+c]}),i):l},jM=(t,s,n,i)=>{let l=[];if(n.length>0)if(i.length>0){if(t.forEach(o=>l.push(o)),Math.max(...i)>t.length)throw new Error("axes is out of bound");i.forEach((o,c)=>l[o]=n[c])}else n.forEach(o=>l.push(o));else{if(s.length===0)throw new Error("Resize requires either scales or sizes.");l=t.map((o,c)=>Math.round(o*s[c]))}return l},UM=(t,s,n)=>{let i=(()=>{switch(n.keepAspectRatioPolicy){case"not_larger":return n.axes.length>0?Math.min(...n.axes.map(o=>s[o]),Number.MAX_VALUE):Math.min(...s,Number.MAX_VALUE);case"not_smaller":return n.axes.length>0?Math.max(...n.axes.map(o=>s[o]),Number.MIN_VALUE):Math.max(...s,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${n.keepAspectRatioPolicy} is not supported`)}})();s.fill(1,0,s.length);let l=t.slice();return n.axes.length>0?(n.axes.forEach(o=>s[o]=i),n.axes.forEach(o=>l[o]=Math.round(t[o]*s[o]))):(s.fill(i,0,s.length),l.forEach((o,c)=>l[c]=Math.round(o*s[c]))),l},VM=(t,s,n,i,l)=>`
    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> array<${t.type.value}, ${n.length}> {
      var original_indices: array<${t.type.value}, ${n.length}>;
      for (var i:u32 = 0; i < ${n.length}; i++) {
        var output_index = ${t.indicesGet("output_indices","i")};
        var scale = ${xt("uniforms.scales","i",i)};
        var roi_low = ${xt("uniforms.roi","i",l)};
        var roi_hi = ${xt("uniforms.roi",`i + ${s.length}`,l)};
        if (scale == 1.0) {
          original_indices[i] = ${t.type.value}(output_index);
        } else {
          var input_shape_i = ${xt("uniforms.input_shape","i",s.length)};
          var output_shape_i = ${xt("uniforms.output_shape","i",n.length)};
          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                           input_shape_i, roi_low, roi_hi);
        }
      }
      return original_indices;
    }`,GM=(t,s,n,i,l,o,c)=>`
    fn calculateInputIndicesFromOutputIndices(output_indices: ${s.type.indices}) -> ${t.type.indices} {
      var input_indices: ${t.type.indices};
      for (var i:u32 = 0; i < ${i.length}; i++) {
        var output_index = ${s.indicesGet("output_indices","i")};
        var input_index: u32;
        var scale = ${xt("uniforms.scales","i",l)};
        if (scale == 1.0) {
          input_index = output_index;
        } else {
          var roi_low = ${xt("uniforms.roi","i",o)};
          var roi_hi = ${xt("uniforms.roi",`i + ${n.length}`,o)};
          var input_shape_i = ${xt("uniforms.input_shape","i",n.length)};
          var output_shape_i = ${xt("uniforms.output_shape","i",i.length)};
          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,
                                                                        input_shape_i, roi_low, roi_hi);
          if (!${c} || (original_idx >= 0 && original_idx < ${s.type.value}(input_shape_i))) {
            if (original_idx < 0) {
              input_index = 0;
            } else if (original_idx > ${s.type.value}(input_shape_i - 1)) {
              input_index = input_shape_i - 1;
            } else {
              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));
            }
          } else {
            input_index = u32(original_idx);
          }
        }
        ${t.indicesSet("input_indices","i","input_index")}
      }
      return input_indices;
    }`,WM=(t,s)=>`
    fn checkInputIndices(input_indices: ${t.type.indices}) -> bool {
      for (var i:u32 = 0; i < ${s.length}; i++) {
        var input_index = ${t.indicesGet("input_indices","i")};
        if (input_index < 0 || input_index >= ${xt("uniforms.input_shape","i",s.length)}) {
          return false;
        }
      }
      return true;
    }`,a_=(t,s,n,i)=>t.rank>i?`
    ${t.indicesSet("input_indices",s,"channel")};
    ${t.indicesSet("input_indices",n,"batch")};
`:"",HM=(t,s,n,i,l)=>{let[o,c,p,d]=n.length===2?[-1,0,1,-1]:[0,2,3,1],f=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${f} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",c,`max(0, min(row, ${n[c]} - 1))`)};
      ${t.indicesSet("input_indices",p,`max(0, min(col, ${n[p]} - 1))`)};
      ${a_(t,d,o,2)}
      return ${t.getByIndices("input_indices")};
    }

    fn bilinearInterpolation(output_indices: ${s.type.indices}) -> ${f} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var row:${f} = originalIndices[${c}];
      var col:${f} = originalIndices[${p}];
      ${i?`if (row < 0 || row > (${n[c]} - 1) || col < 0 || col > (${n[p]} - 1)) {
        return ${l};
      }`:""};
      row = max(0, min(row, ${n[c]} - 1));
      col = max(0, min(col, ${n[p]} - 1));
      var row1: u32 = u32(row);
      var col1: u32 = u32(col);
      var row2: u32 = u32(row + 1);
      var col2: u32 = u32(col + 1);
      var channel: u32 = ${n.length>2?`u32(originalIndices[${d}])`:"0"};
      var batch: u32 =  ${n.length>2?`u32(originalIndices[${o}])`:"0"};
      var x11: ${f} = getInputValue(batch, channel, row1, col1);
      var x12: ${f} = getInputValue(batch, channel, row1, col2);
      var x21: ${f} = getInputValue(batch, channel, row2, col1);
      var x22: ${f} = getInputValue(batch, channel, row2, col2);
      var dx1: ${f} = abs(row - ${f}(row1));
      var dx2: ${f} = abs(${f}(row2) - row);
      var dy1: ${f} = abs(col - ${f}(col1));
      var dy2: ${f} = abs(${f}(col2) - col);
      if (row1 == row2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (col1 == col2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);
    }`},KM=(t,s,n,i,l,o,c,p,d,f)=>{let g=n.length===2,[_,y]=g?[0,1]:[2,3],T=t.type.value,b=k=>{let L=k===_?"row":"col";return`
      fn ${L}CubicInterpolation(input_indices: ${t.type.indices}, output_indices: ${s.type.indices}) -> ${T} {
        var output_index = ${s.indicesGet("output_indices",k)};
        var originalIdx: ${T} = getOriginalCoordinateFromResizedCoordinate(output_index, ${l[k]},
        ${i[k]}, ${n[k]}, ${o[k]}, ${o[k]} + ${n.length});
        var fractOriginalIdx: ${T} = originalIdx - floor(originalIdx);
        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);

        if (${p} && (originalIdx < 0 || originalIdx > (${n[k]} - 1))) {
          return ${d};
        }
        var data: array<${T}, 4> = array<${T}, 4>(0.0, 0.0, 0.0, 0.0);
        for (var i: i32 = -1; i < 3; i++) {
          var ${L}: ${T} = originalIdx + ${T}(i);
          if (${L} < 0 || ${L} >= ${n[k]}) {
            ${f?`coefs[i + 1] = 0.0;
                        continue;`:p?`return ${d};`:`${L} = max(0, min(${L}, ${n[k]} - 1));`};
          }
        var input_indices_copy: ${t.type.indices} = input_indices;
          ${t.indicesSet("input_indices_copy",k,`u32(${L})`)};
          data[i + 1] = ${k===_?t.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};
        }
        return cubicInterpolation1D(data, coefs);
      }`};return`
    ${b(_)};
    ${b(y)};
  fn getCubicInterpolationCoefs(s: ${T}) -> array<${T}, 4> {
    var absS = abs(s);
    var coeffs: array<${T}, 4> = array<${T}, 4>(0.0, 0.0, 0.0, 0.0);
    var oneMinusAbsS: ${T} = 1.0 - absS;
    var twoMinusAbsS: ${T} = 2.0 - absS;
    var onePlusAbsS: ${T} = 1.0 + absS;
    coeffs[0] = ((${c} * onePlusAbsS - 5 * ${c}) * onePlusAbsS + 8 * ${c}) * onePlusAbsS - 4 * ${c};
    coeffs[1] = ((${c} + 2) * absS - (${c} + 3)) * absS * absS + 1;
    coeffs[2] = ((${c} + 2) * oneMinusAbsS - (${c} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;
    coeffs[3] = ((${c} * twoMinusAbsS - 5 * ${c}) * twoMinusAbsS + 8 * ${c}) * twoMinusAbsS - 4 * ${c};
    return coeffs;
  }

  fn cubicInterpolation1D(x: array<${T}, 4>, coefs: array<${T}, 4>) -> ${T} {
    var coefsSum: ${T} = coefs[0] + coefs[1] + coefs[2] + coefs[3];
    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;
  }

  fn bicubicInterpolation(output_indices: ${s.type.indices}) -> ${T} {
    var input_indices: ${t.type.indices} = output_indices;
    return colCubicInterpolation(input_indices, output_indices);
  }
    `},qM=(t,s,n,i,l)=>{let[o,c,p,d,f]=n.length===3?[-1,0,1,2,-1]:[0,2,3,4,1],g=t.type.value;return`
    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${g} {
      var input_indices: ${t.type.indices};
      ${t.indicesSet("input_indices",c,`max(0, min(depth, ${n[c]} - 1))`)};
      ${t.indicesSet("input_indices",p,`max(0, min(height, ${n[p]} - 1))`)};
      ${t.indicesSet("input_indices",d,`max(0, min(width, ${n[d]} - 1))`)};
      ${a_(t,f,o,3)}
      return ${t.getByIndices("input_indices")};
    }

    fn trilinearInterpolation(output_indices: ${s.type.indices}) -> ${g} {
      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);
      var depth:${g} = originalIndices[${c}];
      var height:${g} = originalIndices[${p}];
      var width:${g} = originalIndices[${d}];
      ${i?`if (depth < 0 || depth > (${n[c]} - 1) || height < 0 || height > (${n[p]} - 1) || width < 0 || (width > ${n[d]} - 1)) {
      return ${l};
        }`:""};

    depth = max(0, min(depth, ${n[c]} - 1));
      height = max(0, min(height, ${n[p]} - 1));
      width = max(0, min(width, ${n[d]} - 1));
      var depth1: u32 = u32(depth);
      var height1: u32 = u32(height);
      var width1: u32 = u32(width);
      var depth2: u32 = u32(depth + 1);
      var height2: u32 = u32(height + 1);
      var width2: u32 = u32(width + 1);
      var channel: u32 = ${n.length>3?`u32(originalIndices[${f}])`:"0"};
      var batch: u32 =  ${n.length>3?`u32(originalIndices[${o}])`:"0"};

      var x111: ${g} = getInputValue(batch, channel, depth1, height1, width1);
      var x112: ${g} = getInputValue(batch, channel, depth1, height1, width2);
      var x121: ${g} = getInputValue(batch, channel, depth1, height2, width1);
      var x122: ${g} = getInputValue(batch, channel, depth1, height2, width2);
      var x211: ${g} = getInputValue(batch, channel, depth2, height1, width1);
      var x212: ${g} = getInputValue(batch, channel, depth2, height1, width2);
      var x221: ${g} = getInputValue(batch, channel, depth2, height2, width1);
      var x222: ${g} = getInputValue(batch, channel, depth2, height2, width2);
      var dx1: ${g} = abs(depth - ${g}(depth1));
      var dx2: ${g} = abs(${g}(depth2) - depth);
      var dy1: ${g} = abs(height - ${g}(height1));
      var dy2: ${g} = abs(${g}(height2) - height);
      var dz1: ${g} = abs(width - ${g}(width1));
      var dz2: ${g} = abs(${g}(width2) - width);
      if (depth1 == depth2) {
        dx1 = 0.5;
        dx2 = 0.5;
      }
      if (height1 == height2) {
        dy1 = 0.5;
        dy2 = 0.5;
      }
      if (width1 == width2) {
        dz1 = 0.5;
        dz2 = 0.5;
      }
      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +
              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);
    }`},QM=(t,s,n,i,l,o)=>{let c=t.dims,p=NM(o,s.axes,c.length),d=jM(c,i,l,s.axes),f=i.slice();i.length===0&&(f=c.map((S,I)=>S===0?1:d[I]/S),s.keepAspectRatioPolicy!=="stretch"&&(d=UM(c,f,s)));let g=Tt("output",t.dataType,d.length),_=Ke("input",t.dataType,c.length),y=Ne.size(d),T=c.length===d.length&&c.every((S,I)=>S===d[I]),b=s.coordinateTransformMode==="tf_crop_and_resize",k=s.extrapolationValue,L=_.type.value,C=S=>`
      ${T?"":`
      ${BM(s.coordinateTransformMode,L)};
      ${(()=>{switch(s.mode){case"nearest":return`
              ${WM(_,c)};
              ${RM(s.nearestMode,n,L)};
              ${GM(_,g,c,d,f.length,p.length,b)};
              `;case"linear":return`
              ${VM(g,c,d,f.length,p.length)};
              ${(()=>{if(c.length===2||c.length===4)return`${HM(_,g,c,b,k)}`;if(c.length===3||c.length===5)return`${qM(_,g,c,b,k)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};
            `;case"cubic":return`
            ${(()=>{if(c.length===2||c.length===4)return`${KM(_,g,c,d,f,p,s.cubicCoeffA,b,s.extrapolationValue,s.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};
            `;default:throw Error("Invalid resize mode")}})()};
      `}
      ${S.registerUniform("output_size","u32").registerUniform("scales","f32",f.length).registerUniform("roi","f32",p.length).declareVariables(_,g)}
      ${S.mainStart()}
        ${S.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
        ${T?"output[global_idx] = input[global_idx];":`
        let output_indices = ${g.offsetToIndices("global_idx")};
        var input_indices: ${_.type.indices};
        ${(()=>{switch(s.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);
                if (checkInputIndices(input_indices)) {
                  output[global_idx] = ${_.getByIndices("input_indices")};
                } else {
                  output[global_idx] = ${s.extrapolationValue};
                }`;case"linear":return`output[global_idx] = ${c.length===2||c.length===4?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${s.mode}`)}})()};
`}
      }`;return{name:"Resize",shaderCache:{hint:`${s.cacheKey}|${n}|${f.length>0?s.mode==="cubic"?f:f.length:""}|${l.length>0?l:""}|${p.length>0?p:""}|${T}|${s.mode==="nearest"?c.length:c}`,inputDependencies:["rank"]},getShaderSource:C,getRunData:()=>({outputs:[{dims:d,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(y/64)},programUniforms:[{type:12,data:y},{type:1,data:f},{type:1,data:p},...Ct(c,d)]})}},XM=t=>{let s=t.customDataBuffer;return new Uint32Array(s,s.byteOffset,1)[0]},z1=(t,s)=>{let n=[],i=[],l=[],o=XM(t);if(s.antialias!==0)throw Error("Only default value (0) for Antialias attribute is supported");LM(t.inputs,s,o,n,i,l),t.compute(QM(t.inputs[0],s,o,n,i,l),{inputs:[0]})},F1=t=>{let s=t.antialias,n=t.axes,i=t.coordinateTransformMode,l=t.cubicCoeffA,o=t.excludeOutside!==0,c=t.extrapolationValue,p=t.keepAspectRatioPolicy,d=t.mode,f=t.nearestMode===""?"simple":t.nearestMode;return An({antialias:s,axes:n,coordinateTransformMode:i,cubicCoeffA:l,excludeOutside:o,extrapolationValue:c,keepAspectRatioPolicy:p,mode:d,nearestMode:f})}}),YM,ZM,L1,SE=ot(()=>{Bt(),qt(),or(),Xt(),YM=(t,s)=>{let[n,i,l,o]=t,{numHeads:c,rotaryEmbeddingDim:p}=s;if(n.dims.length!==3&&n.dims.length!==4)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${n.dims.length}`);if(!Ne.areEqual(i.dims,[])&&!Ne.areEqual(i.dims,[1])&&i.dims.length!==2)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${i.dims.length}`);if(l.dims.length!==2)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${l.dims.length}`);if(o.dims.length!==2)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(!Ne.areEqual(l.dims,o.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(p>0&&c===0)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let d=n.dims[0],f=n.dims[n.dims.length-2],g=l.dims[0],_=Ne.sizeFromDimension(n.dims,1)/f,y=p===0?l.dims[1]*2:_/c;if(p>y)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(i.dims.length===2){if(d!==i.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${i.dims[0]}`);if(f!==i.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${i.dims[1]}`)}if(y/2!==l.dims[1]&&p/2!==l.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${l.dims[1]}`);if(f>g)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},ZM=(t,s)=>{let{interleaved:n,numHeads:i,rotaryEmbeddingDim:l,scale:o}=s,c=t[0].dims[0],p=Ne.sizeFromDimension(t[0].dims,1),d=t[0].dims[t[0].dims.length-2],f=p/d,g=t[2].dims[1],_=l===0?g*2:f/i,y=new Array(c,d,f/_,_-g),T=Ne.computeStrides(y),b=[{type:1,data:o},{type:12,data:y},{type:12,data:T},...t[0].dims.length===3?new Array({type:12,data:[p,f,_,1]}):[],...t[0].dims.length===4?new Array({type:12,data:[p,_,d*_,1]}):[],...Ct(t[0].dims,t[1].dims,t[2].dims,t[3].dims,t[0].dims)],k=L=>{let C=Ke("input",t[0].dataType,t[0].dims.length),S=Ke("position_ids",t[1].dataType,t[1].dims.length),I=Ke("cos_cache",t[2].dataType,t[2].dims.length),O=Ke("sin_cache",t[3].dataType,t[3].dims.length),x=Tt("output",t[0].dataType,t[0].dims.length);return L.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:y.length},{name:"global_strides",type:"u32",length:T.length},{name:"input_output_strides",type:"u32",length:T.length}]),`
        ${L.declareVariables(C,S,I,O,x)}

        ${L.mainStart(Wd)}
          let half_rotary_emb_dim = uniforms.${I.name}_shape[1];
          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;
          let size = uniforms.global_shape[0] * uniforms.global_strides[0];
          ${L.guardAgainstOutOfBoundsWorkgroupSizes("size")}

          if (bsnh[3] < half_rotary_emb_dim) {
            let position_ids_idx =
                ${S.broadcastedIndicesToOffset("bsnh.xy",Tt("",S.type.tensor,2))};
            let position_id =
                u32(${S.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);
            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${n});
            let j = i + select(half_rotary_emb_dim, 1, ${n});
            let re = ${C.getByOffset("i")} * ${I.get("position_id","bsnh[3]")} -
                ${C.getByOffset("j")} * ${O.get("position_id","bsnh[3]")};
            ${x.setByOffset("i","re")}
            let im = ${C.getByOffset("i")} * ${O.get("position_id","bsnh[3]")} +
                ${C.getByOffset("j")} * ${I.get("position_id","bsnh[3]")};
            ${x.setByOffset("j","im")}
          } else {
            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;
            ${x.setByOffset("k",C.getByOffset("k"))}
          }
        }`};return{name:"RotaryEmbedding",shaderCache:{hint:An({interleaved:n}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:k,getRunData:()=>({outputs:[{dims:t[0].dims,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(Ne.size(y)/Wd)},programUniforms:b})}},L1=(t,s)=>{YM(t.inputs,s),t.compute(ZM(t.inputs,s))}}),JM,ev,B1,CE=ot(()=>{Bt(),qt(),Xt(),JM=t=>{if(!t||t.length<3)throw new Error("layerNorm requires at least 3 inputs.");let s=t[0],n=t[1],i=t[2];if(s.dataType!==n.dataType||s.dataType!==i.dataType)throw new Error("All inputs must have the same data type");if(s.dims.length!==3&&s.dims.length!==2)throw new Error("Input must be 2D or 3D");if(n.dims.length!==3&&n.dims.length!==2)throw new Error("Skip must be 2D or 3D");let l=s.dims[s.dims.length-1],o=s.dims[s.dims.length-2];if(n.dims[n.dims.length-1]!==l)throw new Error("Skip must have the same hidden size as input");if(n.dims[n.dims.length-2]!==o)throw new Error("Skip must have the same sequence length as input");if(i.dims.length!==1)throw new Error("Gamma must be 1D");if(i.dims[i.dims.length-1]!==l)throw new Error("Gamma must have the same hidden size as input");if(t.length>3){let c=t[3];if(c.dims.length!==1)throw new Error("Beta must be 1D");if(c.dims[c.dims.length-1]!==l)throw new Error("Beta must have the same hidden size as input")}if(t.length>4){let c=t[4];if(c.dims.length!==1)throw new Error("Bias must be 1D");if(c.dims[c.dims.length-1]!==l)throw new Error("Bias must have the same hidden size as input")}},ev=(t,s,n,i)=>{let l=s.simplified,o=t[0].dims,c=Ne.size(o),p=o,d=c,f=o.slice(-1)[0],g=i?o.slice(0,-1).concat(1):[],_=!l&&t.length>3,y=t.length>4,T=i&&n>1,b=i&&n>2,k=n>3,L=64,C=nr(f),S=[{type:12,data:d},{type:12,data:C},{type:12,data:f},{type:1,data:s.epsilon}],I=x=>{let E=[{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}],A=[Ke("x",t[0].dataType,t[0].dims,C),Ke("skip",t[1].dataType,t[1].dims,C),Ke("gamma",t[2].dataType,t[2].dims,C)];_&&A.push(Ke("beta",t[3].dataType,t[3].dims,C)),y&&A.push(Ke("bias",t[4].dataType,t[4].dims,C)),A.push(Tt("output",t[0].dataType,p,C)),T&&A.push(Tt("mean_output",1,g)),b&&A.push(Tt("inv_std_output",1,g)),k&&A.push(Tt("input_skip_bias_sum",t[0].dataType,p,C));let F=zr(t[0].dataType),K=zr(1,C);return`

      ${x.registerUniforms(E).declareVariables(...A)}
      var<workgroup> sum_shared : array<${K}, ${L}>;
      var<workgroup> sum_squared_shared : array<${K}, ${L}>;

      ${x.mainStart([L,1,1])}
        let ix = local_id.x;
        let iy = global_id.x / ${L};

        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;
        var stride = hidden_size_vectorized / ${L};
        let offset = ix * stride + iy * hidden_size_vectorized;
        let offset1d = stride * ix;
        if (ix == ${L-1}) {
          stride = hidden_size_vectorized - stride * ix;
        }
        for (var i: u32 = 0; i < stride; i++) {
          let skip_value = skip[offset + i];
          let bias_value = ${y?"bias[offset1d + i]":F+"(0.0)"};
          let input_value = x[offset + i];
          let value = input_value + skip_value + bias_value;
          ${k?"input_skip_bias_sum[offset + i] = value;":""}
          output[offset + i] = value;
          let f32_value = ${Vd(F,C,"value")};
          sum_shared[ix] += f32_value;
          sum_squared_shared[ix] += f32_value * f32_value;
        }
        workgroupBarrier();

        var reduce_size : u32 = ${L};
        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {
          reduce_size = curr_size + (reduce_size & 1);
          if (ix < curr_size) {
            sum_shared[ix] += sum_shared[ix + reduce_size];
            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];
          }
          workgroupBarrier();
        }

        let sum = sum_shared[0];
        let square_sum = sum_squared_shared[0];
        let mean = ${su("sum",C)} / f32(uniforms.hidden_size);
        let inv_std_dev = inverseSqrt(${su("square_sum",C)} / f32(uniforms.hidden_size) ${l?"":"- mean * mean"} + uniforms.epsilon);
        ${T?"mean_output[global_idx] = mean;":""}
        ${b?"inv_std_output[global_idx] = inv_std_dev;":""}

        for (var i: u32 = 0; i < stride; i++) {
          output[offset + i] = (output[offset + i] ${l?"":`- ${F}(mean)`}) *
            ${F}(inv_std_dev) * gamma[offset1d + i]
            ${_?"+ beta[offset1d + i]":""};
        }
      }`},O=[{dims:p,dataType:t[0].dataType}];return n>1&&O.push({dims:g,dataType:1}),n>2&&O.push({dims:g,dataType:1}),n>3&&O.push({dims:o,dataType:t[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${C};${T};${b};${k}`,inputDependencies:t.map((x,E)=>"type")},getShaderSource:I,getRunData:()=>({outputs:O,dispatchGroup:{x:Math.ceil(d/f)},programUniforms:S})}},B1=(t,s)=>{JM(t.inputs);let n=[0];t.outputCount>1&&n.push(-3),t.outputCount>2&&n.push(-3),t.outputCount>3&&n.push(3),t.compute(ev(t.inputs,s,t.outputCount,!1),{outputs:n})}}),tv,Ip,nv,i_,rv,sv,R1,N1,PE=ot(()=>{Bt(),qt(),or(),Xt(),tv=(t,s)=>{if(!t||t.length<1)throw new Error("too few inputs");if(s.axes.length!==0){if(s.axes.length!==s.starts.length||s.axes.length!==s.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(s.starts.length!==s.ends.length)throw new Error("starts and ends must have the same length");t.slice(1).forEach((n,i)=>{if(t[i+1].dataType!==6&&t[i+1].dataType!==7)throw new Error(`Input ${i} must be an array of int32 or int64`)})},Ip=(t,s)=>{let n=[];if(t.length>s)if(t[s].dataType===7)t[s].getBigInt64Array().forEach(i=>n.push(Number(i)));else if(t[s].dataType===6)t[s].getInt32Array().forEach(i=>n.push(Number(i)));else throw new Error(`Input ${s} must be an array of int32 or int64`);return n},nv=(t,s)=>{if(t.length>1){let n=Ip(t,1),i=Ip(t,2),l=Ip(t,3);return l.length===0&&(l=[...Array(t[0].dims.length).keys()]),An({starts:n,ends:i,axes:l})}else return s},i_=(t,s,n,i,l)=>{let o=t;return t<0&&(o+=n[i[s]]),l[s]<0?Math.max(0,Math.min(o,n[i[s]]-1)):Math.max(0,Math.min(o,n[i[s]]))},rv=(t,s,n)=>`fn calculateInputIndices(output_indices: ${s.type.indices}) -> ${t.type.indices} {
          var input_indices: ${t.type.indices};
          var carry = 0u;
          for (var i = ${n.length}; i >= 0; i--) {
            let input_shape_i = ${xt("uniforms.input_shape","i",n.length)};
            let steps_i = ${xt("uniforms.steps","i",n.length)};
            let signs_i = ${xt("uniforms.signs","i",n.length)};
            let starts_i = ${xt("uniforms.starts","i",n.length)};
            var output_index = ${s.indicesGet("output_indices","i")};
            var input_index = output_index * steps_i + starts_i + carry;
            carry = input_index / input_shape_i;
            input_index = input_index % input_shape_i;
            if (signs_i < 0) {
              input_index = input_shape_i - input_index - 1u + starts_i;
            }
            ${t.indicesSet("input_indices","i","input_index")};
          }
          return input_indices;
      }`,sv=(t,s)=>{let n=t[0].dims,i=Ne.size(n),l=s.axes.length>0?Ne.normalizeAxes(s.axes,n.length):[...Array(n.length).keys()],o=Ip(t,4);o.forEach(C=>C!==0||(()=>{throw new Error("step cannot be 0")})),o.length===0&&(o=Array(l.length).fill(1));let c=s.starts.map((C,S)=>i_(C,S,n,l,o)),p=s.ends.map((C,S)=>i_(C,S,n,l,o));if(l.length!==c.length||l.length!==p.length)throw new Error("start, ends and axes should have the same number of elements");if(l.length!==n.length)for(let C=0;C<n.length;++C)l.includes(C)||(c.splice(C,0,0),p.splice(C,0,n[C]),o.splice(C,0,1));let d=o.map(C=>Math.sign(C));o.forEach((C,S,I)=>{if(C<0){let O=(p[S]-c[S])/C,x=c[S],E=x+O*o[S];c[S]=E,p[S]=x,I[S]=-C}});let f=n.slice(0);l.forEach((C,S)=>{f[C]=Math.ceil((p[C]-c[C])/o[C])});let g={dims:f,dataType:t[0].dataType},_=Tt("output",t[0].dataType,f.length),y=Ke("input",t[0].dataType,t[0].dims.length),T=Ne.size(f),b=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:c.length},{name:"signs",type:"i32",length:d.length},{name:"steps",type:"u32",length:o.length}],k=[{type:12,data:T},{type:12,data:c},{type:6,data:d},{type:12,data:o},...Ct(t[0].dims,f)],L=C=>`
      ${C.registerUniforms(b).declareVariables(y,_)}
        ${rv(y,_,n)}
        ${C.mainStart()}
          ${C.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}
          let output_indices = ${_.offsetToIndices("global_idx")};
          let input_indices = calculateInputIndices(output_indices);
          ${_.setByOffset("global_idx",y.getByIndices("input_indices"))}
      }`;return{name:"Slice",shaderCache:{hint:`${d.length}_${c.length}_${o.length}`,inputDependencies:["rank"]},getShaderSource:L,getRunData:()=>({outputs:[g],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:k})}},R1=(t,s)=>{tv(t.inputs,s);let n=nv(t.inputs,s);t.compute(sv(t.inputs,n),{inputs:[0]})},N1=t=>{let s=t.starts,n=t.ends,i=t.axes;return An({starts:s,ends:n,axes:i})}}),av,iv,j1,U1,AE=ot(()=>{Bt(),qt(),or(),au(),Xt(),av=t=>{if(!t||t.length!==1)throw new Error("Softmax op requires 1 input.")},iv=(t,s)=>{let n=t.inputs[0],i=n.dims,l=Ne.size(i),o=i.length,c=Ne.normalizeAxis(s.axis,o),p=c<i.length-1,d,f=[];p?(f=Array.from({length:o},(A,F)=>F),f[c]=o-1,f[o-1]=c,d=t.compute(_a(n,f),{inputs:[n],outputs:[-1]})[0]):d=n;let g=d.dims,_=g[o-1],y=l/_,T=nr(_),b=_/T,k=64;y===1&&(k=256);let L=(A,F)=>F===4?`max(max(${A}.x, ${A}.y), max(${A}.z, ${A}.w))`:F===2?`max(${A}.x, ${A}.y)`:F===3?`max(max(${A}.x, ${A}.y), ${A}.z)`:A,C=Ke("x",d.dataType,d.dims,T),S=Tt("result",d.dataType,d.dims,T),I=C.type.value,O=zr(d.dataType)==="f32"?`var threadMax = ${I}(-3.402823e+38f);`:`var threadMax = ${I}(-65504.0h);`,x=A=>`
      var<workgroup> rowMaxShared : ${I};
      var<workgroup> rowSumShared : ${I};
      var<workgroup> threadShared : array<${I}, ${k}>;

      fn getValue(row: i32, col: i32, row_stride: i32) -> ${I} {
        let index = row * row_stride + col;
        return x[index];
      }

      fn setValue(row: i32, col: i32, row_stride: i32, value: ${I}) {
        let index = row * row_stride + col;
        result[index] = value;
      }
      ${A.registerUniform("packedCols","i32").declareVariables(C,S)}
      ${A.mainStart(k)}
        let gindex = i32(global_idx);
        let lindex = i32(local_idx);
        const wg = ${k};
        let row = gindex / wg;
        let cols = uniforms.packedCols;
        let row_stride : i32 = uniforms.packedCols;

        // find the rows max
        ${O}
        for (var col = lindex; col < cols; col += wg) {
          let value = getValue(row, col, row_stride);
          threadMax = max(threadMax, value);
        }
        if (lindex < cols) {
          threadShared[lindex] = threadMax;
        }
        workgroupBarrier();

        var reduceSize = min(cols, wg);
        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
          reduceSize = currSize + (reduceSize & 1);
          if (lindex < currSize) {
            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowMaxShared = ${I}(${L("threadShared[0]",T)});
        }
        workgroupBarrier();

        // find the rows sum
        var threadSum = ${I}(0.0);
        for (var col = lindex; col < cols; col += wg) {
          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);
          threadSum += subExp;
        }
        threadShared[lindex] = threadSum;
        workgroupBarrier();

        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {
          if (lindex < currSize) {
            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];
          }
          workgroupBarrier();
        }
        if (lindex == 0) {
          rowSumShared = ${I}(${su("threadShared[0]",T)});
        }
        workgroupBarrier();

        // calculate final value for each element in the row
        for (var col = lindex; col < cols; col += wg) {
          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;
          setValue(row, col, row_stride, value);
        }
      }`,E=t.compute({name:"Softmax",shaderCache:{hint:`${T};${k}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:g,dataType:d.dataType}],dispatchGroup:{x:y},programUniforms:[{type:6,data:b}]}),getShaderSource:x},{inputs:[d],outputs:[p?-1:0]})[0];p&&t.compute(_a(E,f),{inputs:[E]})},j1=(t,s)=>{av(t.inputs),iv(t,s)},U1=t=>An({axis:t.axis})}),o_,ov,lv,uv,V1,$E=ot(()=>{Bt(),qt(),Xt(),o_=t=>Array.from(t.getBigInt64Array(),Number),ov=t=>{if(!t||t.length!==2)throw new Error("Tile requires 2 inputs.");if(t[0].dataType!==1&&t[0].dataType!==10&&t[0].dataType!==6&&t[0].dataType!==12)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(t[1].dataType!==7)throw new Error("Tile `repeats` input should be of int64 data type");if(t[1].dims.length!==1)throw new Error("Tile `repeats` input should be 1-D");if(o_(t[1]).length!==t[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},lv=(t,s)=>{let n=[];for(let i=0;i<t.length;++i)n.push(t[i]*s[i]);return n},uv=(t,s)=>{let n=t[0].dims,i=s??o_(t[1]),l=lv(n,i),o=Ne.size(l),c=t[0].dataType,p=Ke("input",c,n.length),d=Tt("output",c,l.length),f=g=>`
      const inputShape = ${p.indices(...n)};
      ${g.registerUniform("output_size","u32").declareVariables(p,d)}
      ${g.mainStart()}
      ${g.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}
      let output_indices = ${d.offsetToIndices("global_idx")};
      var input_indices: ${p.type.indices};
      for (var i = 0; i < ${n.length}; i++) {
        let input_dim_i = ${p.indicesGet("uniforms.input_shape","i")};
        let input_dim_value = ${d.indicesGet("output_indices","i")}  % input_dim_i;

        ${p.indicesSet("input_indices","i","input_dim_value")}
      }
      ${d.setByOffset("global_idx",p.getByIndices("input_indices"))}
    }`;return{name:"Tile",shaderCache:{hint:`${i}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:l,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},...Ct(t[0].dims,l)]}),getShaderSource:f}},V1=t=>{ov(t.inputs),t.compute(uv(t.inputs),{inputs:[0]})}}),cv,dv,G1,OE=ot(()=>{Bt(),qt(),Xt(),cv=(t,s,n,i,l)=>{let o=Tt("output_data",l,n.length,4),c=Ke("a_data",s[1].dataType,s[1].dims.length,4),p=Ke("b_data",s[2].dataType,s[2].dims.length,4),d=Ke("c_data",s[0].dataType,s[0].dims.length,4),f,g=(_,y,T)=>`select(${y}, ${_}, ${T})`;if(!i)f=o.setByOffset("global_idx",g(c.getByOffset("global_idx"),p.getByOffset("global_idx"),d.getByOffset("global_idx")));else{let _=(y,T,b="")=>{let k=`a_data[index_a${T}][component_a${T}]`,L=`b_data[index_b${T}][component_b${T}]`,C=`bool(c_data[index_c${T}] & (0xffu << (component_c${T} * 8)))`;return`
            let output_indices${T} = ${o.offsetToIndices(`global_idx * 4u + ${T}u`)};
            let offset_a${T} = ${c.broadcastedIndicesToOffset(`output_indices${T}`,o)};
            let offset_b${T} = ${p.broadcastedIndicesToOffset(`output_indices${T}`,o)};
            let offset_c${T} = ${d.broadcastedIndicesToOffset(`output_indices${T}`,o)};
            let index_a${T} = offset_a${T} / 4u;
            let index_b${T} = offset_b${T} / 4u;
            let index_c${T} = offset_c${T} / 4u;
            let component_a${T} = offset_a${T} % 4u;
            let component_b${T} = offset_b${T} % 4u;
            let component_c${T} = offset_c${T} % 4u;
            ${y}[${T}] = ${b}(${g(k,L,C)});
          `};l===9?f=`
            var data = vec4<u32>(0);
            ${_("data",0,"u32")}
            ${_("data",1,"u32")}
            ${_("data",2,"u32")}
            ${_("data",3,"u32")}
            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:f=`
            ${_("output_data[global_idx]",0)}
            ${_("output_data[global_idx]",1)}
            ${_("output_data[global_idx]",2)}
            ${_("output_data[global_idx]",3)}
          `}return`
        ${t.registerUniform("vec_size","u32").declareVariables(d,c,p,o)}
        ${t.mainStart()}
        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}
        ${f}
      }`},dv=t=>{let s=t[1].dims,n=t[2].dims,i=t[0].dims,l=t[1].dataType,o=!(Ne.areEqual(s,n)&&Ne.areEqual(n,i)),c=s,p=Ne.size(s);if(o){let f=Gd.calcShape(Gd.calcShape(s,n,!1),i,!1);if(!f)throw new Error("Can't perform where op on the given tensors");c=f,p=Ne.size(c)}let d=Math.ceil(p/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:f=>cv(f,t,c,o,l),getRunData:()=>({outputs:[{dims:c,dataType:l}],dispatchGroup:{x:Math.ceil(p/64/4)},programUniforms:[{type:12,data:d},...Ct(i,s,n,c)]})}},G1=t=>{t.compute(dv(t.inputs))}}),W1,kE=ot(()=>{Wx(),Q_(),Hx(),Kx(),qx(),Qx(),Xx(),tE(),rE(),sE(),aE(),iE(),oE(),lE(),uE(),cE(),dE(),fE(),pE(),hE(),mE(),_E(),gE(),yE(),ME(),d1(),vE(),wE(),bE(),TE(),xE(),q_(),EE(),SE(),CE(),PE(),AE(),h1(),$E(),au(),X_(),OE(),W1=new Map([["Abs",[Rw]],["Acos",[Nw]],["Acosh",[jw]],["Add",[wb]],["ArgMax",[zw,b_]],["ArgMin",[Iw,b_]],["Asin",[Uw]],["Asinh",[Vw]],["Atan",[Gw]],["Atanh",[Ww]],["Attention",[Fw]],["AveragePool",[T1,b1]],["BatchNormalization",[Lw]],["BiasAdd",[Bw]],["BiasSplitGelu",[vb]],["Cast",[Kw,Hw]],["Ceil",[Qw]],["Clip",[qw]],["Concat",[Ob,kb]],["Conv",[P_,C_]],["ConvTranspose",[Ub,jb]],["Cos",[Xw]],["Cosh",[Yw]],["CumSum",[Vb,Gb]],["DepthToSpace",[Wb,Hb]],["DequantizeLinear",[$1,O1]],["Div",[bb]],["Einsum",[Kb,qb]],["Elu",[Zw,Rp]],["Equal",[Tb]],["Erf",[Jw]],["Exp",[eb]],["Expand",[Qb]],["FastGelu",[Xb]],["Floor",[tb]],["FusedConv",[P_,C_]],["Gather",[Zb,Yb]],["GatherElements",[s1,r1]],["GatherBlockQuantized",[t1,n1]],["GatherND",[Jb,e1]],["Gelu",[nb]],["Gemm",[i1,a1]],["GlobalAveragePool",[E1,x1]],["GlobalMaxPool",[A1,P1]],["Greater",[Cb]],["GreaterOrEqual",[Ab]],["GridSample",[o1,l1]],["GroupQueryAttention",[m1]],["HardSigmoid",[cb,ub]],["InstanceNormalization",[_1]],["LayerNormalization",[g1]],["LeakyRelu",[rb,Rp]],["Less",[Pb]],["LessOrEqual",[$b]],["Log",[yb]],["MatMul",[y1]],["MatMulNBits",[M1,v1]],["MaxPool",[S1,C1]],["Mul",[xb]],["MultiHeadAttention",[c1,u1]],["Neg",[ab]],["Not",[sb]],["Pad",[w1]],["Pow",[Eb]],["QuickGelu",[Mb,Rp]],["Range",[k1]],["Reciprocal",[ib]],["ReduceMin",[Aw]],["ReduceMean",[xw]],["ReduceMax",[Pw]],["ReduceSum",[Ow]],["ReduceProd",[$w]],["ReduceL1",[Ew]],["ReduceL2",[Sw]],["ReduceLogSum",[Dw]],["ReduceLogSumExp",[Cw]],["ReduceSumSquare",[kw]],["Relu",[ob]],["Resize",[z1,F1]],["RotaryEmbedding",[L1]],["ScatterND",[I1,D1]],["Sigmoid",[lb]],["Sin",[db]],["Sinh",[fb]],["Slice",[R1,N1]],["SkipLayerNormalization",[B1]],["Split",[f1,p1]],["Sqrt",[pb]],["Softmax",[j1,U1]],["Sub",[Sb]],["Tan",[hb]],["Tanh",[mb]],["ThresholdedRelu",[gb,Rp]],["Tile",[V1]],["Transpose",[fw,pw]],["Where",[G1]]])}),H1,DE=ot(()=>{xi(),qo(),Xt(),H1=class{constructor(t){this.backend=t,this.repo=new Map,this.attributesBound=!1}getArtifact(t){return this.repo.get(t)}setArtifact(t,s){this.repo.set(t,s)}run(t,s,n,i,l){Ti(t.programInfo.name);let o=this.backend.device,c=this.backend.getComputePassEncoder();this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2);let p=[];for(let f of s)p.push({binding:p.length,resource:{buffer:f.buffer}});for(let f of n)p.push({binding:p.length,resource:{buffer:f.buffer}});l&&p.push({binding:p.length,resource:l});let d=o.createBindGroup({layout:t.computePipeline.getBindGroupLayout(0),entries:p,label:t.programInfo.name});if(this.backend.sessionStatus==="capturing"){let f={kernelId:this.backend.currentKernelId,computePipeline:t.computePipeline,bindGroup:d,dispatchGroup:i};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(f)}c.setPipeline(t.computePipeline),c.setBindGroup(0,d),c.dispatchWorkgroups(...i),this.backend.writeTimestamp(this.backend.pendingDispatchNumber*2+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||this.backend.queryType==="at-passes")&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),ja(t.programInfo.name)}dispose(){}build(t,s){Ti(t.name);let n=this.backend.device,i=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach(f=>{n.features.has(f.feature)&&i.push(`enable ${f.extension};`)});let l=dw(s,this.backend.device.limits),o=t.getShaderSource(l),c=`${i.join(`
`)}
${l.additionalImplementations}
${o}`,p=n.createShaderModule({code:c,label:t.name});dn("verbose",()=>`[WebGPU] ${t.name} shader code: ${c}`);let d=n.createComputePipeline({compute:{module:p,entryPoint:"main"},layout:"auto",label:t.name});return ja(t.name),{programInfo:t,computePipeline:d,uniformVariablesInfo:l.variablesInfo}}normalizeDispatchGroupSize(t){let s=typeof t=="number"?t:t.x,n=typeof t=="number"?1:t.y||1,i=typeof t=="number"?1:t.z||1,l=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(s<=l&&n<=l&&i<=l)return[s,n,i];let o=s*n*i,c=Math.ceil(Math.sqrt(o));if(c>l){if(c=Math.ceil(Math.cbrt(o)),c>l)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[c,c,c]}else return[c,c,1]}}}),fv,pv,hv,K1,IE=ot(()=>{xi(),Bt(),qo(),aw(),Vx(),kE(),DE(),fv=(t,s)=>{if(s.length!==t.length)throw new Error(`inputDependencies length ${s.length} is not equal to inputTensors length ${t.length}.`);let n=[];for(let i=0;i<t.length;++i){let l=t[i].dataType;switch(s[i]){case"none":{n.push("");break}case"type":{n.push(`${l}`);break}case"rank":{let o=t[i].dims.length;n.push(`${l};${o}`);break}case"dims":{let o=t[i].dims.join(",");n.push(`${l};${o}`);break}default:throw new Error(`unsupported input dependency: ${s[i]}`)}}return n.join("|")},pv=(t,s,n)=>{var l,o;let i=t.name;return(l=t.shaderCache)!=null&&l.hint&&(i+="["+t.shaderCache.hint+"]"),i+=":"+n+`:${fv(s,((o=t.shaderCache)==null?void 0:o.inputDependencies)??new Array(s.length).fill("dims"))}`,i},hv=class{constructor(t){t&&(this.architecture=t.architecture,this.vendor=t.vendor)}isArchitecture(t){return this.architecture===t}isVendor(t){return this.vendor===t}},K1=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(this.currentKernelId===null)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let t=this.kernelCustomData.get(this.currentKernelId);return t||(t={},this.kernelCustomData.set(this.currentKernelId,t)),t}async initialize(t,s){this.env=t;let n=[],i={requiredLimits:{maxComputeWorkgroupStorageSize:s.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.limits.maxStorageBufferBindingSize,maxBufferSize:s.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:s.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:s.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:s.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:s.limits.maxComputeWorkgroupSizeZ},requiredFeatures:n},l=o=>s.features.has(o)&&n.push(o)&&!0;l("chromium-experimental-timestamp-query-inside-passes")||l("timestamp-query"),l("shader-f16"),l("subgroups"),this.device=await s.requestDevice(i),this.adapterInfo=new hv(s.info||await s.requestAdapterInfo()),this.gpuDataManager=iw(this),this.programManager=new H1(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,G_(t.logLevel,!!t.debug),this.device.onuncapturederror=o=>{o.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${o.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:s,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let t=this.getCommandEncoder(),s={};this.queryType==="at-passes"&&(s.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:this.pendingDispatchNumber*2,endOfPassWriteIndex:this.pendingDispatchNumber*2+1}),this.computePassEncoder=t.beginComputePass(s)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;Ti(),this.endComputePass();let t;this.queryType!=="none"&&(this.commandEncoder.resolveQuerySet(this.querySet,0,this.pendingDispatchNumber*2,this.queryResolveBuffer,0),t=this.device.createBuffer({size:this.pendingDispatchNumber*2*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(t,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,t,0,this.pendingDispatchNumber*2*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,this.queryType!=="none"&&t.mapAsync(GPUMapMode.READ).then(()=>{var i;let s=new BigUint64Array(t.getMappedRange()),n=this.pendingQueries.get(t);for(let l=0;l<s.length/2;l++){let o=n[l],c=o.kernelId,p=this.kernels.get(c),d=p.kernelType,f=p.kernelName,g=o.programName,_=o.inputTensorViews,y=o.outputTensorViews,T=s[l*2],b=s[l*2+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=T);let k=Number(T-this.queryTimeBase),L=Number(b-this.queryTimeBase);if(!Number.isSafeInteger(k)||!Number.isSafeInteger(L))throw new RangeError("incorrect timestamp range");if((i=this.env.webgpu.profiling)!=null&&i.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:_.map(C=>({dims:C.dims,dataType:yc(C.dataType)})),outputsMetadata:y.map(C=>({dims:C.dims,dataType:yc(C.dataType)})),kernelId:c,kernelType:d,kernelName:f,programName:g,startTime:k,endTime:L});else{let C="";_.forEach((I,O)=>{C+=`input[${O}]: [${I.dims}] | ${yc(I.dataType)}, `});let S="";y.forEach((I,O)=>{S+=`output[${O}]: [${I.dims}] | ${yc(I.dataType)}, `}),console.log(`[profiling] kernel "${c}|${d}|${f}|${g}" ${C}${S}execution time: ${L-k} ns`)}Up("GPU",`${g}::${T}::${b}`)}t.unmap(),this.pendingQueries.delete(t)}),ja()}run(t,s,n,i,l,o){Ti(t.name);let c=[];for(let S=0;S<s.length;++S){let I=s[S].data;if(I===0)continue;let O=this.gpuDataManager.get(I);if(!O)throw new Error(`no GPU data for input: ${I}`);c.push(O)}let{outputs:p,dispatchGroup:d,programUniforms:f}=t.getRunData(s),g=n.length===0?p.map((S,I)=>I):n;if(g.length!==p.length)throw new Error(`Output size ${g.length} must be equal to ${p.length}.`);let _=[],y=[];for(let S=0;S<p.length;++S){if(!Number.isInteger(g[S])||g[S]<-3||g[S]>=o)throw new Error(`Invalid output index: ${g[S]}`);if(g[S]===-3)continue;let I=g[S]===-1,O=g[S]===-2,x=I||O?l(p[S].dataType,p[S].dims):i(g[S],p[S].dataType,p[S].dims);if(_.push(x),x.data===0)continue;let E=this.gpuDataManager.get(x.data);if(!E)throw new Error(`no GPU data for output: ${x.data}`);if(I&&this.temporaryData.push(E),O){let A=this.kernelPersistentData.get(this.currentKernelId);A||(A=[],this.kernelPersistentData.set(this.currentKernelId,A)),A.push(E)}y.push(E)}if(c.length!==s.length||y.length!==_.length){if(y.length===0)return ja(t.name),_;throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}let T;if(f){let S=0,I=[];f.forEach(A=>{let F=typeof A.data=="number"?[A.data]:A.data;if(F.length===0)return;let K=A.type===10?2:4,X,oe;A.type===10?(oe=F.length>4?16:F.length>2?8:F.length*K,X=F.length>4?16:K*F.length):(oe=F.length<=2?F.length*K:16,X=16),S=Math.ceil(S/oe)*oe,I.push(S);let ie=A.type===10?8:4;S+=F.length>4?Math.ceil(F.length/ie)*X:F.length*K});let O=16;S=Math.ceil(S/O)*O;let x=new ArrayBuffer(S);f.forEach((A,F)=>{let K=I[F],X=typeof A.data=="number"?[A.data]:A.data;if(A.type===6)new Int32Array(x,K,X.length).set(X);else if(A.type===12)new Uint32Array(x,K,X.length).set(X);else if(A.type===10)new Uint16Array(x,K,X.length).set(X);else if(A.type===1)new Float32Array(x,K,X.length).set(X);else throw new Error(`Unsupported uniform type: ${yc(A.type)}`)});let E=this.gpuDataManager.create(S,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(E.buffer,0,x,0,S),this.gpuDataManager.release(E.id),T={offset:0,size:S,buffer:E.buffer}}let b=this.programManager.normalizeDispatchGroupSize(d),k=b[1]===1&&b[2]===1,L=pv(t,s,k),C=this.programManager.getArtifact(L);if(C||(C=this.programManager.build(t,b),this.programManager.setArtifact(L,C),dn("info",()=>`[artifact] key: ${L}, programName: ${t.name}`)),f&&C.uniformVariablesInfo){if(f.length!==C.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${C.uniformVariablesInfo.length}, got ${f.length} in program "${C.programInfo.name}".`);for(let S=0;S<f.length;S++){let I=f[S],O=I.type,x=typeof I.data=="number"?1:I.data.length,[E,A]=C.uniformVariablesInfo[S];if(O!==E||x!==A)throw new Error(`Uniform variable ${S} mismatch: expect type ${E} with size ${A}, got type ${O} with size ${x} in program "${C.programInfo.name}".`)}}if(dn("info",()=>`[ProgramManager] run "${t.name}" (key=${L}) with ${b[0]}x${b[1]}x${b[2]}`),this.queryType!=="none"||this.sessionStatus==="capturing"){let S={kernelId:this.currentKernelId,programName:C.programInfo.name,inputTensorViews:s,outputTensorViews:_};this.pendingKernels.push(S),this.sessionStatus==="capturing"&&this.capturedPendingKernels.get(this.currentSessionId).push(S)}return this.programManager.run(C,c,y,b,T),ja(t.name),_}upload(t,s){this.gpuDataManager.upload(t,s)}memcpy(t,s){this.gpuDataManager.memcpy(t,s)}async download(t,s){await this.gpuDataManager.download(t,s)}alloc(t){return this.gpuDataManager.create(t).id}free(t){return this.gpuDataManager.release(t)}createKernel(t,s,n,i){let l=W1.get(t);if(!l)throw new Error(`kernel not implemented: ${t}`);let o={kernelType:t,kernelName:i,kernelEntry:l[0],attributes:[l[1],n]};this.kernels.set(s,o)}releaseKernel(t){let s=this.kernelPersistentData.get(t);if(s){for(let n of s)this.gpuDataManager.release(n.id);this.kernelPersistentData.delete(t)}this.kernelCustomData.delete(t),this.kernels.delete(t)}computeKernel(t,s,n){let i=this.kernels.get(t);if(!i)throw new Error(`kernel not created: ${t}`);let l=i.kernelType,o=i.kernelName,c=i.kernelEntry,p=i.attributes;if(this.currentKernelId!==null)throw new Error(`kernel "[${l}] ${o}" is not allowed to be called recursively`);this.currentKernelId=t,p[0]&&(p[1]=p[0](p[1]),p[0]=void 0),dn("info",()=>`[WebGPU] Start to run kernel "[${l}] ${o}"...`);let d=this.env.debug;this.temporaryData=[];try{return d&&this.device.pushErrorScope("validation"),c(s,p[1]),0}catch(f){return n.push(Promise.resolve(`[WebGPU] Kernel "[${l}] ${o}" failed. ${f}`)),1}finally{d&&n.push(this.device.popErrorScope().then(f=>f?`GPU validation error for kernel "[${l}] ${o}": ${f.message}`:null));for(let f of this.temporaryData)this.gpuDataManager.release(f.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(t,s,n,i){let l=this.sessionExternalDataMapping.get(t);l||(l=new Map,this.sessionExternalDataMapping.set(t,l));let o=l.get(s),c=this.gpuDataManager.registerExternalBuffer(n,i,o);return l.set(s,[c,n]),c}unregisterBuffers(t){let s=this.sessionExternalDataMapping.get(t);s&&(s.forEach(n=>this.gpuDataManager.unregisterExternalBuffer(n[0])),this.sessionExternalDataMapping.delete(t))}getBuffer(t){let s=this.gpuDataManager.get(t);if(!s)throw new Error(`no GPU data for buffer: ${t}`);return s.buffer}createDownloader(t,s,n){return async()=>{let i=await M_(this,t,s);return W_(i.buffer,n)}}writeTimestamp(t){this.queryType==="inside-passes"&&this.computePassEncoder.writeTimestamp(this.querySet,t)}setQueryType(){var t;this.queryType="none",(((t=this.env.webgpu.profiling)==null?void 0:t.mode)==="default"||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),this.queryType!=="none"&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxDispatchNumber*2}),this.queryResolveBuffer=this.device.createBuffer({size:this.maxDispatchNumber*2*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){dn("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){dn("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){dn("info","replay"),this.sessionStatus="replaying";let t=this.capturedCommandList.get(this.currentSessionId),s=this.capturedPendingKernels.get(this.currentSessionId),n=t.length;this.pendingKernels=[];for(let i=0;i<n;i++){let l=this.getComputePassEncoder(),o=t[i];this.writeTimestamp(this.pendingDispatchNumber*2),l.setPipeline(o.computePipeline),l.setBindGroup(0,o.bindGroup),l.dispatchWorkgroups(...o.dispatchGroup),this.writeTimestamp(this.pendingDispatchNumber*2+1),this.pendingDispatchNumber++,this.queryType!=="none"&&this.pendingKernels.push(s[i]),(this.pendingDispatchNumber>=this.maxDispatchNumber||this.queryType==="at-passes")&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(t){this.unregisterBuffers(t),this.capturedCommandList.has(t)&&this.capturedCommandList.delete(t),this.capturedPendingKernels.has(t)&&this.capturedPendingKernels.delete(t),this.gpuDataManager.onReleaseSession(t)}onRunStart(t){this.currentSessionId=t,this.setQueryType()}}}),mv,l_,_v,u_,c_,d_,gv,q1,zE=ot(()=>{qo(),mv=1,l_=()=>mv++,_v=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),u_=(t,s)=>{let n=_v.get(t);if(!n)throw new Error("Unsupported data type.");return s.length>0?Math.ceil(s.reduce((i,l)=>i*l)*n/8):0},c_=class{constructor(t){this.sessionId=t.sessionId,this.mlContext=t.context,this.mlTensor=t.tensor,this.dataType=t.dataType,this.tensorShape=t.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return u_(this.dataType,this.tensorShape)}destroy(){dn("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(t){this.mlContext.writeTensor(this.mlTensor,t)}async read(t){return t?this.mlContext.readTensor(this.mlTensor,t):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(t,s,n){return this.mlContext===t&&this.dataType===s&&this.tensorShape.length===n.length&&this.tensorShape.every((i,l)=>i===n[l])}},d_=class{constructor(t,s){this.tensorManager=t,this.wrapper=s}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(t,s,n,i){let l=this.tensorManager.getMLContext(t);if(this.wrapper){if(this.wrapper.canReuseTensor(l,s,n))return this.wrapper.tensor;if(i){if(this.wrapper.byteLength!==u_(s,n))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let o=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(t,s,n,o,!0,!0),i&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(t){if(this.wrapper)if(t.byteLength===this.wrapper.byteLength){this.wrapper.write(t);return}else dn("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor();this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(t){if(this.activeUpload)if(t){t instanceof ArrayBuffer?new Uint8Array(t).set(this.activeUpload):new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(this.activeUpload);return}else return this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return t?this.wrapper.read(t):this.wrapper.read()}},gv=class{constructor(t){this.backend=t,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(t){let s=this.backend.getMLContext(t);if(!s)throw new Error("MLContext not found for session.");return s}reserveTensorId(){let t=l_();return this.tensorTrackersById.set(t,new d_(this)),t}releaseTensorId(t){let s=this.tensorTrackersById.get(t);s&&(this.tensorTrackersById.delete(t),s.tensorWrapper&&this.releaseTensor(s.tensorWrapper))}async ensureTensor(t,s,n,i,l){dn("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${s}, dataType: ${n}, shape: ${i}, copyOld: ${l}}`);let o=this.tensorTrackersById.get(s);if(!o)throw new Error("Tensor not found.");return o.ensureTensor(t,n,i,l)}upload(t,s){let n=this.tensorTrackersById.get(t);if(!n)throw new Error("Tensor not found.");n.upload(s)}async download(t,s){dn("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${s==null?void 0:s.byteLength}}`);let n=this.tensorTrackersById.get(t);if(!n)throw new Error("Tensor not found.");return n.download(s)}releaseTensorsForSession(t){for(let s of this.freeTensors)s.sessionId===t&&s.destroy();this.freeTensors=this.freeTensors.filter(s=>s.sessionId!==t)}registerTensor(t,s,n,i){let l=this.getMLContext(t),o=l_(),c=new c_({sessionId:t,context:l,tensor:s,dataType:n,shape:i});return this.tensorTrackersById.set(o,new d_(this,c)),this.externalTensors.add(c),o}async getCachedTensor(t,s,n,i,l,o){let c=this.getMLContext(t);for(let[d,f]of this.freeTensors.entries())if(f.canReuseTensor(c,s,n)){dn("verbose",()=>`[WebNN] Reusing tensor {dataType: ${s}, shape: ${n}}`);let g=this.freeTensors.splice(d,1)[0];return g.sessionId=t,g}dn("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${s}, shape: ${n}}`);let p=await c.createTensor({dataType:s,shape:n,dimensions:n,usage:i,writable:l,readable:o});return new c_({sessionId:t,context:c,tensor:p,dataType:s,shape:n})}releaseTensor(t){this.externalTensors.has(t)&&this.externalTensors.delete(t),this.freeTensors.push(t)}},q1=(...t)=>new gv(...t)}),zh,yv,Q1,FE=ot(()=>{Bt(),xc(),aw(),zE(),qo(),zh=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),yv=(t,s)=>{if(t===s)return!0;if(t===void 0||s===void 0)return!1;let n=Object.keys(t).sort(),i=Object.keys(s).sort();return n.length===i.length&&n.every((l,o)=>l===i[o]&&t[l]===s[l])},Q1=class{constructor(t){this.tensorManager=q1(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,G_(t.logLevel,!!t.debug)}get currentSessionId(){if(this.activeSessionId===void 0)throw new Error("No active session");return this.activeSessionId}onRunStart(t){dn("verbose",()=>`[WebNN] onRunStart {sessionId: ${t}}`),this.activeSessionId=t}onRunEnd(t){dn("verbose",()=>`[WebNN] onRunEnd {sessionId: ${t}}`);let s=this.temporarySessionTensorIds.get(t);if(s){for(let n of s)dn("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${n}}`),this.tensorManager.releaseTensorId(n);this.temporarySessionTensorIds.delete(t),this.activeSessionId=void 0}}async createMLContext(t){if(t instanceof GPUDevice){let n=this.mlContextCache.findIndex(i=>i.gpuDevice===t);if(n!==-1)return this.mlContextCache[n].mlContext;{let i=await navigator.ml.createContext(t);return this.mlContextCache.push({gpuDevice:t,mlContext:i}),i}}else if(t===void 0){let n=this.mlContextCache.findIndex(i=>i.options===void 0&&i.gpuDevice===void 0);if(n!==-1)return this.mlContextCache[n].mlContext;{let i=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:i}),i}}let s=this.mlContextCache.findIndex(n=>yv(n.options,t));if(s!==-1)return this.mlContextCache[s].mlContext;{let n=await navigator.ml.createContext(t);return this.mlContextCache.push({options:t,mlContext:n}),n}}registerMLContext(t,s){this.mlContextBySessionId.set(t,s);let n=this.sessionIdsByMLContext.get(s);n||(n=new Set,this.sessionIdsByMLContext.set(s,n)),n.add(t),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(t,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(t){this.sessionGraphInputs.delete(t);let s=this.mlContextBySessionId.get(t);if(!s)return;this.tensorManager.releaseTensorsForSession(t),this.mlContextBySessionId.delete(t);let n=this.sessionIdsByMLContext.get(s);if(n.delete(t),n.size===0){this.sessionIdsByMLContext.delete(s);let i=this.mlContextCache.findIndex(l=>l.mlContext===s);i!==-1&&this.mlContextCache.splice(i,1)}}getMLContext(t){return this.mlContextBySessionId.get(t)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(t){dn("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${t}}`),this.tensorManager.releaseTensorId(t)}async ensureTensor(t,s,n,i,l){let o=zh.get(n);if(!o)throw new Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(t??this.currentSessionId,s,o,i,l)}async createTemporaryTensor(t,s,n){dn("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${s}, shape: ${n}}`);let i=zh.get(s);if(!i)throw new Error(`Unsupported ONNX data type: ${s}`);let l=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(t,l,i,n,!1);let o=this.temporarySessionTensorIds.get(t);return o?o.push(l):this.temporarySessionTensorIds.set(t,[l]),l}uploadTensor(t,s){if(!Ir().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");dn("verbose",()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${s.byteLength}}`),this.tensorManager.upload(t,s)}async downloadTensor(t,s){return this.tensorManager.download(t,s)}createMLTensorDownloader(t,s){return async()=>{let n=await this.tensorManager.download(t);return W_(n,s)}}registerMLTensor(t,s,n,i){let l=zh.get(n);if(!l)throw new Error(`Unsupported ONNX data type: ${n}`);let o=this.tensorManager.registerTensor(t,s,l,i);return dn("verbose",()=>`[WebNN] registerMLTensor {tensor: ${s}, dataType: ${l}, dimensions: ${i}} -> {tensorId: ${o}}`),o}registerMLConstant(t,s,n,i,l,o){if(!o)throw new Error("External mounted files are not available.");let c=t;t.startsWith("./")&&(c=t.substring(2));let p=o.get(c);if(!p)throw new Error(`File with name ${c} not found in preloaded files.`);if(s+n>p.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let d=p.slice(s,s+n).buffer,f;switch(l.dataType){case"float32":f=new Float32Array(d);break;case"float16":f=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(d):new Uint16Array(d);break;case"int32":f=new Int32Array(d);break;case"uint32":f=new Uint32Array(d);break;case"int64":f=new BigInt64Array(d);break;case"uint64":f=new BigUint64Array(d);break;case"int8":f=new Int8Array(d);break;case"int4":case"uint4":case"uint8":f=new Uint8Array(d);break;default:throw new Error(`Unsupported data type: ${l.dataType} in creating WebNN Constant from external data.`)}return dn("verbose",()=>`[WebNN] registerMLConstant {dataType: ${l.dataType}, shape: ${l.shape}}}`),i.constant(l,f)}registerGraphInput(t){this.temporaryGraphInputs.push(t)}isGraphInput(t,s){let n=this.sessionGraphInputs.get(t);return n?n.includes(s):!1}flush(){}}}),X1={};Gp(X1,{init:()=>Y1});var Fh,Mv,Y1,LE=ot(()=>{Bt(),IE(),qo(),qt(),FE(),Fh=class Z1{constructor(s,n,i,l){this.module=s,this.dataType=n,this.data=i,this.dims=l}getFloat32Array(){if(this.dataType!==1)throw new Error("Invalid data type");let s=Ne.size(this.dims);return s===0?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,s)}getBigInt64Array(){if(this.dataType!==7)throw new Error("Invalid data type");let s=Ne.size(this.dims);return s===0?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,s)}getInt32Array(){if(this.dataType!==6)throw new Error("Invalid data type");let s=Ne.size(this.dims);return s===0?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,s)}getUint16Array(){if(this.dataType!==10&&this.dataType!==4)throw new Error("Invalid data type");let s=Ne.size(this.dims);return s===0?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,s)}reshape(s){if(Ne.size(s)!==Ne.size(this.dims))throw new Error("Invalid new shape");return new Z1(this.module,this.dataType,this.data,s)}},Mv=class{constructor(t,s,n){this.module=t,this.backend=s,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=s.adapterInfo;let i=t.PTR_SIZE,l=n/t.PTR_SIZE,o=i===4?"i32":"i64";this.opKernelContext=Number(t.getValue(i*l++,o));let c=Number(t.getValue(i*l++,o));this.outputCount=Number(t.getValue(i*l++,o)),this.customDataOffset=Number(t.getValue(i*l++,"*")),this.customDataSize=Number(t.getValue(i*l++,o));let p=[];for(let d=0;d<c;d++){let f=Number(t.getValue(i*l++,o)),g=Number(t.getValue(i*l++,"*")),_=Number(t.getValue(i*l++,o)),y=[];for(let T=0;T<_;T++)y.push(Number(t.getValue(i*l++,o)));p.push(new Fh(t,f,g,y))}this.inputs=p}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(t,s){var c;let n=((c=s==null?void 0:s.inputs)==null?void 0:c.map(p=>typeof p=="number"?this.inputs[p]:p))??this.inputs,i=(s==null?void 0:s.outputs)??[],l=(p,d,f)=>new Fh(this.module,d,this.output(p,f),f),o=(p,d)=>{let f=Mc(p,d);if(!f)throw new Error(`Unsupported data type: ${p}`);let g=f>0?this.backend.gpuDataManager.create(f).id:0;return new Fh(this.module,p,g,d)};return this.backend.run(t,n,i,l,o,this.outputCount)}output(t,s){let n=this.module.stackSave();try{let i=this.module.PTR_SIZE,l=i===4?"i32":"i64",o=this.module.stackAlloc((1+s.length)*i);this.module.setValue(o,s.length,l);for(let c=0;c<s.length;c++)this.module.setValue(o+i*(c+1),s[c],l);return this.module._JsepOutput(this.opKernelContext,t,o)}catch(i){throw new Error(`Failed to generate kernel's output[${t}] with dims [${s}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${i}`)}finally{this.module.stackRestore(n)}}},Y1=async(t,s,n,i)=>{let l=s.jsepInit;if(!l)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if(t==="webgpu"){let o=new K1;await o.initialize(n,i),l("webgpu",[o,c=>o.alloc(Number(c)),c=>o.free(c),(c,p,d,f=!1)=>{if(f)dn("verbose",()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(c)}, dst=${Number(p)}, size=${Number(d)}`),o.memcpy(Number(c),Number(p));else{dn("verbose",()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(c)}, gpuDataId=${Number(p)}, size=${Number(d)}`);let g=s.HEAPU8.subarray(Number(c>>>0),Number(c>>>0)+Number(d));o.upload(Number(p),g)}},async(c,p,d)=>{dn("verbose",()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${c}, dataOffset=${p}, size=${d}`),await o.download(Number(c),()=>s.HEAPU8.subarray(Number(p)>>>0,Number(p+d)>>>0))},(c,p,d)=>o.createKernel(c,Number(p),d,s.UTF8ToString(s._JsepGetNodeName(Number(p)))),c=>o.releaseKernel(c),(c,p,d,f)=>{dn("verbose",()=>`[WebGPU] jsepRun: sessionHandle=${d}, kernel=${c}, contextDataOffset=${p}`);let g=new Mv(s,o,Number(p));return o.computeKernel(Number(c),g,f)},()=>o.captureBegin(),()=>o.captureEnd(),()=>o.replay()])}else{let o=new Q1(n);l("webnn",[o,()=>o.reserveTensorId(),c=>o.releaseTensorId(c),async(c,p,d,f,g)=>o.ensureTensor(c,p,d,f,g),(c,p)=>{o.uploadTensor(c,p)},async(c,p)=>o.downloadTensor(c,p)])}}}),vv,ng,rg,nu,wv,Qh,sg,ag,f_,ig,og,lg,J1=ot(()=>{jx(),Ux(),Bt(),xc(),R_(),sw(),vv=(t,s)=>{Ir()._OrtInit(t,s)!==0&&vn("Can't initialize onnxruntime.")},ng=async t=>{vv(t.wasm.numThreads,Wh(t.logLevel))},rg=async(t,s)=>{{let n=(LE(),Vh(X1)).init;if(s==="webgpu"){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let i=t.webgpu.adapter;if(i){if(typeof i.limits!="object"||typeof i.features!="object"||typeof i.requestDevice!="function")throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let l=t.webgpu.powerPreference;if(l!==void 0&&l!=="low-power"&&l!=="high-performance")throw new Error(`Invalid powerPreference setting: "${l}"`);let o=t.webgpu.forceFallbackAdapter;if(o!==void 0&&typeof o!="boolean")throw new Error(`Invalid forceFallbackAdapter setting: "${o}"`);if(i=await navigator.gpu.requestAdapter({powerPreference:l,forceFallbackAdapter:o}),!i)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await n("webgpu",Ir(),t,i)}if(s==="webnn"){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await n("webnn",Ir(),t)}}},nu=new Map,wv=t=>{let s=Ir(),n=s.stackSave();try{let i=s.PTR_SIZE,l=s.stackAlloc(2*i);s._OrtGetInputOutputCount(t,l,l+i)!==0&&vn("Can't get session input/output count.");let o=i===4?"i32":"i64";return[Number(s.getValue(l,o)),Number(s.getValue(l+i,o))]}finally{s.stackRestore(n)}},Qh=t=>{let s=Ir(),n=s._malloc(t.byteLength);if(n===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return s.HEAPU8.set(t,n),[n,t.byteLength]},sg=async(t,s)=>{var _,y,T;let n,i,l=Ir();Array.isArray(t)?[n,i]=t:t.buffer===l.HEAPU8.buffer?[n,i]=[t.byteOffset,t.byteLength]:[n,i]=Qh(t);let o=0,c=0,p=0,d=[],f=[],g=[];try{if([c,d]=rw(s),(s==null?void 0:s.externalData)&&l.mountExternalData){let x=[];for(let E of s.externalData){let A=typeof E=="string"?E:E.path;x.push(V_(typeof E=="string"?E:E.data).then(F=>{l.mountExternalData(A,F)}))}await Promise.all(x)}for(let x of(s==null?void 0:s.executionProviders)??[])if((typeof x=="string"?x:x.name)==="webnn"){if(l.shouldTransferToMLTensor=!1,typeof x!="string"){let E=x,A=E==null?void 0:E.context,F=E==null?void 0:E.gpuDevice,K=E==null?void 0:E.deviceType,X=E==null?void 0:E.powerPreference;A?l.currentContext=A:F?l.currentContext=await l.jsepCreateMLContext(F):l.currentContext=await l.jsepCreateMLContext({deviceType:K,powerPreference:X})}else l.currentContext=await l.jsepCreateMLContext();break}o=await l._OrtCreateSession(n,i,c),o===0&&vn("Can't create a session."),(_=l.jsepOnCreateSession)==null||_.call(l),l.currentContext&&(l.jsepRegisterMLContext(o,l.currentContext),l.currentContext=void 0,l.shouldTransferToMLTensor=!0);let[b,k]=wv(o),L=!!(s!=null&&s.enableGraphCapture),C=[],S=[],I=[];for(let x=0;x<b;x++){let E=l._OrtGetInputName(o,x);E===0&&vn("Can't get an input name."),f.push(E),C.push(l.UTF8ToString(E))}for(let x=0;x<k;x++){let E=l._OrtGetOutputName(o,x);E===0&&vn("Can't get an output name."),g.push(E);let A=l.UTF8ToString(E);S.push(A);{if(L&&(s==null?void 0:s.preferredOutputLocation)===void 0){I.push("gpu-buffer");continue}let F=typeof(s==null?void 0:s.preferredOutputLocation)=="string"?s.preferredOutputLocation:((y=s==null?void 0:s.preferredOutputLocation)==null?void 0:y[A])??"cpu";if(F!=="cpu"&&F!=="cpu-pinned"&&F!=="gpu-buffer"&&F!=="ml-tensor")throw new Error(`Not supported preferred output location: ${F}.`);if(L&&F!=="gpu-buffer")throw new Error(`Not supported preferred output location: ${F}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);I.push(F)}}let O=null;return I.some(x=>x==="gpu-buffer"||x==="ml-tensor")&&(p=l._OrtCreateBinding(o),p===0&&vn("Can't create IO binding."),O={handle:p,outputPreferredLocations:I,outputPreferredLocationsEncoded:I.map(x=>y_(x))}),nu.set(o,[o,f,g,O,L,!1]),[o,C,S]}catch(b){throw f.forEach(k=>l._OrtFree(k)),g.forEach(k=>l._OrtFree(k)),p!==0&&l._OrtReleaseBinding(p)!==0&&vn("Can't release IO binding."),o!==0&&l._OrtReleaseSession(o)!==0&&vn("Can't release session."),b}finally{l._free(n),c!==0&&l._OrtReleaseSessionOptions(c)!==0&&vn("Can't release session options."),d.forEach(b=>l._free(b)),(T=l.unmountExternalData)==null||T.call(l)}},ag=t=>{var d;let s=Ir(),n=nu.get(t);if(!n)throw new Error(`cannot release session. invalid session id: ${t}`);let[i,l,o,c,p]=n;c&&(p&&s._OrtClearBoundOutputs(c.handle)!==0&&vn("Can't clear bound outputs."),s._OrtReleaseBinding(c.handle)!==0&&vn("Can't release IO binding.")),(d=s.jsepOnReleaseSession)==null||d.call(s,t),l.forEach(f=>s._OrtFree(f)),o.forEach(f=>s._OrtFree(f)),s._OrtReleaseSession(i)!==0&&vn("Can't release session."),nu.delete(t)},f_=async(t,s,n,i,l,o=!1)=>{if(!t){s.push(0);return}let c=Ir(),p=c.PTR_SIZE,d=t[0],f=t[1],g=t[3],_=g,y,T;if(d==="string"&&(g==="gpu-buffer"||g==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(o&&g!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${l} when enableGraphCapture is true.`);if(g==="gpu-buffer"){let L=t[2].gpuBuffer;T=Mc(jd(d),f);let C=c.jsepRegisterBuffer;if(!C)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');y=C(i,l,L,T)}else if(g==="ml-tensor"){let L=t[2].mlTensor;T=Mc(jd(d),f);let C=c.jsepRegisterMLTensor;if(!C)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');y=C(i,L,jd(d),f)}else{let L=t[2];if(Array.isArray(L)){T=p*L.length,y=c._malloc(T),n.push(y);for(let C=0;C<L.length;C++){if(typeof L[C]!="string")throw new TypeError(`tensor data at index ${C} is not a string`);c.setValue(y+C*p,ss(L[C],n),"*")}}else{let C=c.jsepIsGraphInput;if(d!=="string"&&C){let S=c._OrtGetInputName(i,l),I=c.UTF8ToString(S);if(C(i,I)){let O=jd(d);T=Mc(O,f),_="ml-tensor";let x=c.jsepCreateTemporaryTensor,E=c.jsepUploadTensor;if(!x||!E)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let A=await x(i,O,f);E(A,new Uint8Array(L.buffer,L.byteOffset,L.byteLength)),y=A}else T=L.byteLength,y=c._malloc(T),n.push(y),c.HEAPU8.set(new Uint8Array(L.buffer,L.byteOffset,T),y)}else T=L.byteLength,y=c._malloc(T),n.push(y),c.HEAPU8.set(new Uint8Array(L.buffer,L.byteOffset,T),y)}}let b=c.stackSave(),k=c.stackAlloc(4*f.length);try{f.forEach((C,S)=>c.setValue(k+S*p,C,p===4?"i32":"i64"));let L=c._OrtCreateTensor(jd(d),y,T,k,f.length,y_(_));L===0&&vn(`Can't create tensor for input/output. session=${i}, index=${l}.`),s.push(L)}finally{c.stackRestore(b)}},ig=async(t,s,n,i,l,o)=>{var oe,ie,J;let c=Ir(),p=c.PTR_SIZE,d=nu.get(t);if(!d)throw new Error(`cannot run inference. invalid session id: ${t}`);let f=d[0],g=d[1],_=d[2],y=d[3],T=d[4],b=d[5],k=s.length,L=i.length,C=0,S=[],I=[],O=[],x=[],E=c.stackSave(),A=c.stackAlloc(k*p),F=c.stackAlloc(k*p),K=c.stackAlloc(L*p),X=c.stackAlloc(L*p);try{[C,S]=nw(o);for(let G=0;G<k;G++)await f_(n[G],I,x,t,s[G],T);for(let G=0;G<L;G++)await f_(l[G],O,x,t,k+i[G],T);for(let G=0;G<k;G++)c.setValue(A+G*p,I[G],"*"),c.setValue(F+G*p,g[s[G]],"*");for(let G=0;G<L;G++)c.setValue(K+G*p,O[G],"*"),c.setValue(X+G*p,_[i[G]],"*");if(y&&!b){let{handle:G,outputPreferredLocations:se,outputPreferredLocationsEncoded:ce}=y;if(g.length!==k)throw new Error(`input count from feeds (${k}) is expected to be always equal to model's input count (${g.length}).`);for(let ge=0;ge<k;ge++){let W=s[ge];await c._OrtBindInput(G,g[W],I[ge])!==0&&vn(`Can't bind input[${ge}] for session=${t}.`)}for(let ge=0;ge<L;ge++){let W=i[ge];(oe=l[ge])!=null&&oe[3]?c._OrtBindOutput(G,_[W],O[ge],0)!==0&&vn(`Can't bind pre-allocated output[${ge}] for session=${t}.`):c._OrtBindOutput(G,_[W],0,ce[W])!==0&&vn(`Can't bind output[${ge}] to ${se[ge]} for session=${t}.`)}nu.set(t,[f,g,_,y,T,!0])}(ie=c.jsepOnRunStart)==null||ie.call(c,f);let ue;y?ue=await c._OrtRunWithBinding(f,y.handle,L,K,C):ue=await c._OrtRun(f,F,A,k,X,L,K,C),ue!==0&&vn("failed to call OrtRun().");let ne=[];for(let G=0;G<L;G++){let se=Number(c.getValue(K+G*p,"*"));if(se===O[G]){ne.push(l[G]);continue}let ce=c.stackSave(),ge=c.stackAlloc(4*p),W=!1,U,B=0;try{c._OrtGetTensorData(se,ge,ge+p,ge+2*p,ge+3*p)!==0&&vn(`Can't access output tensor data on index ${G}.`);let Q=p===4?"i32":"i64",le=Number(c.getValue(ge,Q));B=c.getValue(ge+p,"*");let re=c.getValue(ge+p*2,"*"),ve=Number(c.getValue(ge+p*3,Q)),Se=[];for(let Oe=0;Oe<ve;Oe++)Se.push(Number(c.getValue(re+Oe*p,Q)));c._OrtFree(re)!==0&&vn("Can't free memory for tensor dims.");let Be=Se.reduce((Oe,ae)=>Oe*ae,1);U=yc(le);let ut=y==null?void 0:y.outputPreferredLocations[i[G]];if(U==="string"){if(ut==="gpu-buffer"||ut==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let Oe=[];for(let ae=0;ae<Be;ae++){let Z=c.getValue(B+ae*p,"*"),Ee=c.getValue(B+(ae+1)*p,"*"),Ve=ae===Be-1?void 0:Ee-Z;Oe.push(c.UTF8ToString(Z,Ve))}ne.push([U,Se,Oe,"cpu"])}else if(ut==="gpu-buffer"&&Be>0){let Oe=c.jsepGetBuffer;if(!Oe)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let ae=Oe(B),Z=Mc(le,Be);if(Z===void 0||!j_(U))throw new Error(`Unsupported data type: ${U}`);W=!0,ne.push([U,Se,{gpuBuffer:ae,download:c.jsepCreateDownloader(ae,Z,U),dispose:()=>{c._OrtReleaseTensor(se)!==0&&vn("Can't release tensor.")}},"gpu-buffer"])}else if(ut==="ml-tensor"&&Be>0){let Oe=c.jsepEnsureTensor;if(!Oe)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(Mc(le,Be)===void 0||!U_(U))throw new Error(`Unsupported data type: ${U}`);let ae=await Oe(t,B,le,Se,!1);W=!0,ne.push([U,Se,{mlTensor:ae,download:c.jsepCreateMLTensorDownloader(B,U),dispose:()=>{c.jsepReleaseTensorId(B),c._OrtReleaseTensor(se)}},"ml-tensor"])}else{let Oe=N_(U),ae=new Oe(Be);new Uint8Array(ae.buffer,ae.byteOffset,ae.byteLength).set(c.HEAPU8.subarray(B,B+ae.byteLength)),ne.push([U,Se,ae,"cpu"])}}finally{c.stackRestore(ce),U==="string"&&B&&c._free(B),W||c._OrtReleaseTensor(se),(J=c.jsepOnRunEnd)==null||J.call(c,f)}}return y&&!T&&(c._OrtClearBoundOutputs(y.handle)!==0&&vn("Can't clear bound outputs."),nu.set(t,[f,g,_,y,T,!1])),ne}finally{c.stackRestore(E),I.forEach(ue=>c._OrtReleaseTensor(ue)),O.forEach(ue=>c._OrtReleaseTensor(ue)),x.forEach(ue=>c._free(ue)),C!==0&&c._OrtReleaseRunOptions(C),S.forEach(ue=>c._free(ue))}},og=t=>{let s=Ir(),n=nu.get(t);if(!n)throw new Error("invalid session id");let i=n[0],l=s._OrtEndProfiling(i);l===0&&vn("Can't get an profile file name."),s._OrtFree(l)},lg=t=>{let s=[];for(let n of t){let i=n[2];!Array.isArray(i)&&"buffer"in i&&s.push(i.buffer)}return s}}),ru,Gs,Nd,zp,Fp,Lh,p_,Bh,hc,mc,bv,eT,tT,nT,rT,sT,aT,iT,oT=ot(()=>{xi(),J1(),xc(),L_(),ru=()=>!!Hn.wasm.proxy&&typeof document<"u",Nd=!1,zp=!1,Fp=!1,Bh=new Map,hc=(t,s)=>{let n=Bh.get(t);n?n.push(s):Bh.set(t,[s])},mc=()=>{if(Nd||!zp||Fp||!Gs)throw new Error("worker not ready")},bv=t=>{switch(t.data.type){case"init-wasm":Nd=!1,t.data.err?(Fp=!0,p_[1](t.data.err)):(zp=!0,p_[0]()),Lh&&(URL.revokeObjectURL(Lh),Lh=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let s=Bh.get(t.data.type);t.data.err?s.shift()[1](t.data.err):s.shift()[0](t.data.out);break}}},eT=async()=>{if(!zp){if(Nd)throw new Error("multiple calls to 'initWasm()' detected.");if(Fp)throw new Error("previous call to 'initWasm()' failed.");if(Nd=!0,ru())return new Promise((t,s)=>{Gs==null||Gs.terminate(),ew().then(([n,i])=>{try{Gs=i,Gs.onerror=o=>s(o),Gs.onmessage=bv,p_=[t,s];let l={type:"init-wasm",in:Hn};!l.in.wasm.wasmPaths&&(n||g_)&&(l.in.wasm.wasmPaths={wasm:new URL("/whisper-in-browser/assets/ort-wasm-simd-threaded.jsep-BAR87mbD.wasm",import.meta.url).href}),Gs.postMessage(l),Lh=n}catch(l){s(l)}},s)});try{await B_(Hn.wasm),await ng(Hn),zp=!0}catch(t){throw Fp=!0,t}finally{Nd=!1}}},tT=async t=>{if(ru())return mc(),new Promise((s,n)=>{hc("init-ep",[s,n]);let i={type:"init-ep",in:{epName:t,env:Hn}};Gs.postMessage(i)});await rg(Hn,t)},nT=async t=>ru()?(mc(),new Promise((s,n)=>{hc("copy-from",[s,n]);let i={type:"copy-from",in:{buffer:t}};Gs.postMessage(i,[t.buffer])})):Qh(t),rT=async(t,s)=>{if(ru()){if(s!=null&&s.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return mc(),new Promise((n,i)=>{hc("create",[n,i]);let l={type:"create",in:{model:t,options:{...s}}},o=[];t instanceof Uint8Array&&o.push(t.buffer),Gs.postMessage(l,o)})}else return sg(t,s)},sT=async t=>{if(ru())return mc(),new Promise((s,n)=>{hc("release",[s,n]);let i={type:"release",in:t};Gs.postMessage(i)});ag(t)},aT=async(t,s,n,i,l,o)=>{if(ru()){if(n.some(c=>c[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(l.some(c=>c))throw new Error("pre-allocated output tensor is not supported for proxy.");return mc(),new Promise((c,p)=>{hc("run",[c,p]);let d=n,f={type:"run",in:{sessionId:t,inputIndices:s,inputs:d,outputIndices:i,options:o}};Gs.postMessage(f,lg(d))})}else return ig(t,s,n,i,l,o)},iT=async t=>{if(ru())return mc(),new Promise((s,n)=>{hc("end-profiling",[s,n]);let i={type:"end-profiling",in:t};Gs.postMessage(i)});og(t)}}),h_,Tv,lT,BE=ot(()=>{xi(),oT(),Bt(),F_(),sw(),h_=(t,s)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${t.location} for ${s()}`)}},Tv=t=>{switch(t[3]){case"cpu":return new wi(t[0],t[2],t[1]);case"gpu-buffer":{let s=t[0];if(!j_(s))throw new Error(`not supported data type: ${s} for deserializing GPU tensor`);let{gpuBuffer:n,download:i,dispose:l}=t[2];return wi.fromGpuBuffer(n,{dataType:s,dims:t[1],download:i,dispose:l})}case"ml-tensor":{let s=t[0];if(!U_(s))throw new Error(`not supported data type: ${s} for deserializing MLTensor tensor`);let{mlTensor:n,download:i,dispose:l}=t[2];return wi.fromMLTensor(n,{dataType:s,dims:t[1],download:i,dispose:l})}default:throw new Error(`invalid data location: ${t[3]}`)}},lT=class{async fetchModelAndCopyToWasmMemory(t){return nT(await V_(t))}async loadModel(t,s){Ti();let n;typeof t=="string"?n=await this.fetchModelAndCopyToWasmMemory(t):n=t,[this.sessionId,this.inputNames,this.outputNames]=await rT(n,s),ja()}async dispose(){return sT(this.sessionId)}async run(t,s,n){Ti();let i=[],l=[];Object.entries(t).forEach(_=>{let y=_[0],T=_[1],b=this.inputNames.indexOf(y);if(b===-1)throw new Error(`invalid input '${y}'`);i.push(T),l.push(b)});let o=[],c=[];Object.entries(s).forEach(_=>{let y=_[0],T=_[1],b=this.outputNames.indexOf(y);if(b===-1)throw new Error(`invalid output '${y}'`);o.push(T),c.push(b)});let p=i.map((_,y)=>h_(_,()=>`input "${this.inputNames[l[y]]}"`)),d=o.map((_,y)=>_?h_(_,()=>`output "${this.outputNames[c[y]]}"`):null),f=await aT(this.sessionId,l,p,c,d,n),g={};for(let _=0;_<f.length;_++)g[this.outputNames[c[_]]]=o[_]??Tv(f[_]);return ja(),g}startProfiling(){}endProfiling(){iT(this.sessionId)}}}),uT={};Gp(uT,{OnnxruntimeWebAssemblyBackend:()=>O_,initializeFlags:()=>$_,wasmBackend:()=>cT});var $_,O_,cT,RE=ot(()=>{xi(),oT(),BE(),$_=()=>{if((typeof Hn.wasm.initTimeout!="number"||Hn.wasm.initTimeout<0)&&(Hn.wasm.initTimeout=0),Hn.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof Hn.wasm.proxy!="boolean"&&(Hn.wasm.proxy=!1),typeof Hn.wasm.trace!="boolean"&&(Hn.wasm.trace=!1),typeof Hn.wasm.numThreads!="number"||!Number.isInteger(Hn.wasm.numThreads)||Hn.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)Hn.wasm.numThreads=1;else{let t=typeof navigator>"u"?xx("node:os").cpus().length:navigator.hardwareConcurrency;Hn.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},O_=class{async init(t){$_(),await eT(),await tT(t)}async createInferenceSessionHandler(t,s){let n=new lT;return await n.loadModel(t,s),Promise.resolve(n)}},cT=new O_});xi();xi();xi();var NE="1.22.0-dev.20250306-ccf8fdd9ea",jE=qv;{let t=(RE(),Vh(uT)).wasmBackend;vc("webgpu",t,5),vc("webnn",t,5),vc("cpu",t,10),vc("wasm",t,10)}Object.defineProperty(Hn.versions,"web",{value:NE,enumerable:!0});/**
* @license
* Copyright 2021 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*//**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 *//**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UE=Object.freeze(Object.defineProperty({__proto__:null,get InferenceSession(){return z_},get TRACE(){return Up},get TRACE_FUNC_BEGIN(){return Ti},get TRACE_FUNC_END(){return ja},get Tensor(){return wi},default:jE,get env(){return Hn},get registerBackend(){return vc}},Symbol.toStringTag,{value:"Module"}));var Ko={},VE={"onnxruntime-common":t=>{t.exports=vx},"onnxruntime-web":t=>{t.exports=UE},"?2ce3":()=>{},"?7a2c":()=>{},"?a42a":()=>{},"?2b25":()=>{},"?569f":()=>{},"?3f59":()=>{},"?154a":()=>{},"./node_modules/@huggingface/jinja/dist/index.js":(t,s,n)=>{n.r(s),n.d(s,{Environment:()=>qe,Interpreter:()=>We,Template:()=>ct,parse:()=>U,tokenize:()=>_});var i=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",NullLiteral:"NullLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),l=Object.freeze({set:i.Set,for:i.For,in:i.In,is:i.Is,if:i.If,else:i.Else,endif:i.EndIf,elif:i.ElseIf,endfor:i.EndFor,and:i.And,or:i.Or,not:i.Not,"not in":i.NotIn,macro:i.Macro,endmacro:i.EndMacro,true:i.BooleanLiteral,false:i.BooleanLiteral,none:i.NullLiteral,True:i.BooleanLiteral,False:i.BooleanLiteral,None:i.NullLiteral}),o=class{constructor(V,fe){this.value=V,this.type=fe}};function c(V){return/\w/.test(V)}function p(V){return/[0-9]/.test(V)}var d=[["{%",i.OpenStatement],["%}",i.CloseStatement],["{{",i.OpenExpression],["}}",i.CloseExpression],["(",i.OpenParen],[")",i.CloseParen],["{",i.OpenCurlyBracket],["}",i.CloseCurlyBracket],["[",i.OpenSquareBracket],["]",i.CloseSquareBracket],[",",i.Comma],[".",i.Dot],[":",i.Colon],["|",i.Pipe],["<=",i.ComparisonBinaryOperator],[">=",i.ComparisonBinaryOperator],["==",i.ComparisonBinaryOperator],["!=",i.ComparisonBinaryOperator],["<",i.ComparisonBinaryOperator],[">",i.ComparisonBinaryOperator],["+",i.AdditiveBinaryOperator],["-",i.AdditiveBinaryOperator],["*",i.MultiplicativeBinaryOperator],["/",i.MultiplicativeBinaryOperator],["%",i.MultiplicativeBinaryOperator],["=",i.Equals]],f=new Map([["n",`
`],["t","	"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function g(V,fe={}){return V.endsWith(`
`)&&(V=V.slice(0,-1)),V=V.replace(/{#.*?#}/gs,"{##}"),fe.lstrip_blocks&&(V=V.replace(/^[ \t]*({[#%])/gm,"$1")),fe.trim_blocks&&(V=V.replace(/([#%]})\n/g,"$1")),V.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}function _(V,fe={}){var De,rt,He;const q=[],pe=g(V,fe);let we=0;const Fe=it=>{let mt="";for(;it(pe[we]);){if(pe[we]==="\\"){if(++we,we>=pe.length)throw new SyntaxError("Unexpected end of input");const _t=pe[we++],Ot=f.get(_t);if(Ot===void 0)throw new SyntaxError(`Unexpected escaped character: ${_t}`);mt+=Ot;continue}if(mt+=pe[we++],we>=pe.length)throw new SyntaxError("Unexpected end of input")}return mt};e:for(;we<pe.length;){const it=(De=q.at(-1))==null?void 0:De.type;if(it===void 0||it===i.CloseStatement||it===i.CloseExpression){let _t="";for(;we<pe.length&&!(pe[we]==="{"&&(pe[we+1]==="%"||pe[we+1]==="{"));)_t+=pe[we++];if(_t.length>0){q.push(new o(_t,i.Text));continue}}Fe(_t=>/\s/.test(_t));const mt=pe[we];if(mt==="-"||mt==="+"){const _t=(rt=q.at(-1))==null?void 0:rt.type;if(_t===i.Text||_t===void 0)throw new SyntaxError(`Unexpected character: ${mt}`);switch(_t){case i.Identifier:case i.NumericLiteral:case i.BooleanLiteral:case i.NullLiteral:case i.StringLiteral:case i.CloseParen:case i.CloseSquareBracket:break;default:{++we;const Ot=Fe(p);q.push(new o(`${mt}${Ot}`,Ot.length>0?i.NumericLiteral:i.UnaryOperator));continue}}}for(const[_t,Ot]of d)if(pe.slice(we,we+_t.length)===_t){q.push(new o(_t,Ot)),we+=_t.length;continue e}if(mt==="'"||mt==='"'){++we;const _t=Fe(Ot=>Ot!==mt);q.push(new o(_t,i.StringLiteral)),++we;continue}if(p(mt)){const _t=Fe(p);q.push(new o(_t,i.NumericLiteral));continue}if(c(mt)){const _t=Fe(c),Ot=Object.hasOwn(l,_t)?l[_t]:i.Identifier;Ot===i.In&&((He=q.at(-1))==null?void 0:He.type)===i.Not?(q.pop(),q.push(new o("not in",i.NotIn))):q.push(new o(_t,Ot));continue}throw new SyntaxError(`Unexpected character: ${mt}`)}return q}var y=class{constructor(){he(this,"type","Statement")}},T=class extends y{constructor(fe){super();he(this,"type","Program");this.body=fe}},b=class extends y{constructor(fe,q,pe){super();he(this,"type","If");this.test=fe,this.body=q,this.alternate=pe}},k=class extends y{constructor(fe,q,pe,we){super();he(this,"type","For");this.loopvar=fe,this.iterable=q,this.body=pe,this.defaultBlock=we}},L=class extends y{constructor(fe,q){super();he(this,"type","Set");this.assignee=fe,this.value=q}},C=class extends y{constructor(fe,q,pe){super();he(this,"type","Macro");this.name=fe,this.args=q,this.body=pe}},S=class extends y{constructor(){super(...arguments);he(this,"type","Expression")}},I=class extends S{constructor(fe,q,pe){super();he(this,"type","MemberExpression");this.object=fe,this.property=q,this.computed=pe}},O=class extends S{constructor(fe,q){super();he(this,"type","CallExpression");this.callee=fe,this.args=q}},x=class extends S{constructor(fe){super();he(this,"type","Identifier");this.value=fe}},E=class extends S{constructor(fe){super();he(this,"type","Literal");this.value=fe}},A=class extends E{constructor(){super(...arguments);he(this,"type","NumericLiteral")}},F=class extends E{constructor(){super(...arguments);he(this,"type","StringLiteral")}},K=class extends E{constructor(){super(...arguments);he(this,"type","BooleanLiteral")}},X=class extends E{constructor(){super(...arguments);he(this,"type","NullLiteral")}},oe=class extends E{constructor(){super(...arguments);he(this,"type","ArrayLiteral")}},ie=class extends E{constructor(){super(...arguments);he(this,"type","TupleLiteral")}},J=class extends E{constructor(){super(...arguments);he(this,"type","ObjectLiteral")}},ue=class extends S{constructor(fe,q,pe){super();he(this,"type","BinaryExpression");this.operator=fe,this.left=q,this.right=pe}},ne=class extends S{constructor(fe,q){super();he(this,"type","FilterExpression");this.operand=fe,this.filter=q}},G=class extends S{constructor(fe,q){super();he(this,"type","SelectExpression");this.iterable=fe,this.test=q}},se=class extends S{constructor(fe,q,pe){super();he(this,"type","TestExpression");this.operand=fe,this.negate=q,this.test=pe}},ce=class extends S{constructor(fe,q){super();he(this,"type","UnaryExpression");this.operator=fe,this.argument=q}},ge=class extends S{constructor(fe=void 0,q=void 0,pe=void 0){super();he(this,"type","SliceExpression");this.start=fe,this.stop=q,this.step=pe}},W=class extends S{constructor(fe,q){super();he(this,"type","KeywordArgumentExpression");this.key=fe,this.value=q}};function U(V){const fe=new T([]);let q=0;function pe(st,yt){const Et=V[q++];if(!Et||Et.type!==st)throw new Error(`Parser Error: ${yt}. ${Et.type} !== ${st}.`);return Et}function we(){switch(V[q].type){case i.Text:return rt();case i.OpenStatement:return He();case i.OpenExpression:return it();default:throw new SyntaxError(`Unexpected token type: ${V[q].type}`)}}function Fe(...st){return q+st.length<=V.length&&st.some((yt,Et)=>yt!==V[q+Et].type)}function De(...st){return q+st.length<=V.length&&st.every((yt,Et)=>yt===V[q+Et].type)}function rt(){return new F(pe(i.Text,"Expected text token").value)}function He(){pe(i.OpenStatement,"Expected opening statement token");let st;switch(V[q].type){case i.Set:++q,st=mt(),pe(i.CloseStatement,"Expected closing statement token");break;case i.If:++q,st=_t(),pe(i.OpenStatement,"Expected {% token"),pe(i.EndIf,"Expected endif token"),pe(i.CloseStatement,"Expected %} token");break;case i.Macro:++q,st=Ot(),pe(i.OpenStatement,"Expected {% token"),pe(i.EndMacro,"Expected endmacro token"),pe(i.CloseStatement,"Expected %} token");break;case i.For:++q,st=Dn(),pe(i.OpenStatement,"Expected {% token"),pe(i.EndFor,"Expected endfor token"),pe(i.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${V[q].type}`)}return st}function it(){pe(i.OpenExpression,"Expected opening expression token");const st=hn();return pe(i.CloseExpression,"Expected closing expression token"),st}function mt(){const st=hn();if(De(i.Equals)){++q;const yt=mt();return new L(st,yt)}return st}function _t(){var Qn,_n,mr,vs,Fr,rr,qr,Lr;const st=hn();pe(i.CloseStatement,"Expected closing statement token");const yt=[],Et=[];for(;!(((Qn=V[q])==null?void 0:Qn.type)===i.OpenStatement&&(((_n=V[q+1])==null?void 0:_n.type)===i.ElseIf||((mr=V[q+1])==null?void 0:mr.type)===i.Else||((vs=V[q+1])==null?void 0:vs.type)===i.EndIf));)yt.push(we());if(((Fr=V[q])==null?void 0:Fr.type)===i.OpenStatement&&((rr=V[q+1])==null?void 0:rr.type)!==i.EndIf)if(++q,De(i.ElseIf))pe(i.ElseIf,"Expected elseif token"),Et.push(_t());else for(pe(i.Else,"Expected else token"),pe(i.CloseStatement,"Expected closing statement token");!(((qr=V[q])==null?void 0:qr.type)===i.OpenStatement&&((Lr=V[q+1])==null?void 0:Lr.type)===i.EndIf);)Et.push(we());return new b(st,yt,Et)}function Ot(){const st=mn();if(st.type!=="Identifier")throw new SyntaxError("Expected identifier following macro statement");const yt=ys();pe(i.CloseStatement,"Expected closing statement token");const Et=[];for(;Fe(i.OpenStatement,i.EndMacro);)Et.push(we());return new C(st,yt,Et)}function Ft(st=!1){const yt=st?mn:hn,Et=[yt()],Qn=De(i.Comma);for(;Qn&&(++q,Et.push(yt()),!!De(i.Comma)););return Qn?new ie(Et):Et[0]}function Dn(){const st=Ft(!0);if(!(st instanceof x||st instanceof ie))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${st.type} instead`);pe(i.In,"Expected `in` keyword following loop variable");const yt=hn();pe(i.CloseStatement,"Expected closing statement token");const Et=[];for(;Fe(i.OpenStatement,i.EndFor)&&Fe(i.OpenStatement,i.Else);)Et.push(we());const Qn=[];if(De(i.OpenStatement,i.Else))for(++q,++q,pe(i.CloseStatement,"Expected closing statement token");Fe(i.OpenStatement,i.EndFor);)Qn.push(we());return new k(st,yt,Et,Qn)}function hn(){return Kn()}function Kn(){const st=Ws();if(De(i.If)){++q;const yt=Ws();if(De(i.Else)){++q;const Et=Ws();return new b(yt,[st],[Et])}else return new G(st,yt)}return st}function Ws(){let st=ga();for(;De(i.Or);){const yt=V[q];++q;const Et=ga();st=new ue(yt,st,Et)}return st}function ga(){let st=Hr();for(;De(i.And);){const yt=V[q];++q;const Et=Hr();st=new ue(yt,st,Et)}return st}function Hr(){let st;for(;De(i.Not);){const yt=V[q];++q;const Et=Hr();st=new ce(yt,Et)}return st??ms()}function ms(){let st=_s();for(;De(i.ComparisonBinaryOperator)||De(i.In)||De(i.NotIn);){const yt=V[q];++q;const Et=_s();st=new ue(yt,st,Et)}return st}function _s(){let st=ya();for(;De(i.AdditiveBinaryOperator);){const yt=V[q];++q;const Et=ya();st=new ue(yt,st,Et)}return st}function gs(){const st=Hs(mn());return De(i.OpenParen)?Pt(st):st}function Pt(st){let yt=new O(st,ys());return yt=Hs(yt),De(i.OpenParen)&&(yt=Pt(yt)),yt}function ys(){pe(i.OpenParen,"Expected opening parenthesis for arguments list");const st=Kr();return pe(i.CloseParen,"Expected closing parenthesis for arguments list"),st}function Kr(){const st=[];for(;!De(i.CloseParen);){let yt=hn();if(De(i.Equals)){if(++q,!(yt instanceof x))throw new SyntaxError("Expected identifier for keyword argument");const Et=hn();yt=new W(yt,Et)}st.push(yt),De(i.Comma)&&++q}return st}function Ms(){const st=[];let yt=!1;for(;!De(i.CloseSquareBracket);)De(i.Colon)?(st.push(void 0),++q,yt=!0):(st.push(hn()),De(i.Colon)&&(++q,yt=!0));if(st.length===0)throw new SyntaxError("Expected at least one argument for member/slice expression");if(yt){if(st.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new ge(...st)}return st[0]}function Hs(st){for(;De(i.Dot)||De(i.OpenSquareBracket);){const yt=V[q];++q;let Et;const Qn=yt.type!==i.Dot;if(Qn)Et=Ms(),pe(i.CloseSquareBracket,"Expected closing square bracket");else if(Et=mn(),Et.type!=="Identifier")throw new SyntaxError("Expected identifier following dot operator");st=new I(st,Et,Qn)}return st}function ya(){let st=Pr();for(;De(i.MultiplicativeBinaryOperator);){const yt=V[q];++q;const Et=Pr();st=new ue(yt,st,Et)}return st}function Pr(){let st=Nn();for(;De(i.Is);){++q;const yt=De(i.Not);yt&&++q;let Et=mn();if(Et instanceof K?Et=new x(Et.value.toString()):Et instanceof X&&(Et=new x("none")),!(Et instanceof x))throw new SyntaxError("Expected identifier for the test");st=new se(st,yt,Et)}return st}function Nn(){let st=gs();for(;De(i.Pipe);){++q;let yt=mn();if(!(yt instanceof x))throw new SyntaxError("Expected identifier for the filter");De(i.OpenParen)&&(yt=Pt(yt)),st=new ne(st,yt)}return st}function mn(){const st=V[q];switch(st.type){case i.NumericLiteral:return++q,new A(Number(st.value));case i.StringLiteral:return++q,new F(st.value);case i.BooleanLiteral:return++q,new K(st.value.toLowerCase()==="true");case i.NullLiteral:return++q,new X(null);case i.Identifier:return++q,new x(st.value);case i.OpenParen:{++q;const yt=Ft();if(V[q].type!==i.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${V[q].type} instead`);return++q,yt}case i.OpenSquareBracket:{++q;const yt=[];for(;!De(i.CloseSquareBracket);)yt.push(hn()),De(i.Comma)&&++q;return++q,new oe(yt)}case i.OpenCurlyBracket:{++q;const yt=new Map;for(;!De(i.CloseCurlyBracket);){const Et=hn();pe(i.Colon,"Expected colon between key and value in object literal");const Qn=hn();yt.set(Et,Qn),De(i.Comma)&&++q}return++q,new J(yt)}default:throw new SyntaxError(`Unexpected token: ${st.type}`)}}for(;q<V.length;)fe.body.push(we());return fe}function B(V,fe,q=1){fe===void 0&&(fe=V,V=0);const pe=[];for(let we=V;we<fe;we+=q)pe.push(we);return pe}function Q(V,fe,q,pe=1){const we=Math.sign(pe);we>=0?(fe=(fe??(fe=0))<0?Math.max(V.length+fe,0):Math.min(fe,V.length),q=(q??(q=V.length))<0?Math.max(V.length+q,0):Math.min(q,V.length)):(fe=(fe??(fe=V.length-1))<0?Math.max(V.length+fe,-1):Math.min(fe,V.length-1),q=(q??(q=-1))<-1?Math.max(V.length+q,-1):Math.min(q,V.length-1));const Fe=[];for(let De=fe;we*De<we*q;De+=pe)Fe.push(V[De]);return Fe}function le(V){return V.replace(/\b\w/g,fe=>fe.toUpperCase())}var re=class{constructor(V=void 0){he(this,"type","RuntimeValue");he(this,"value");he(this,"builtins",new Map);this.value=V}__bool__(){return new Be(!!this.value)}},ve=class extends re{constructor(){super(...arguments);he(this,"type","NumericValue")}},Se=class extends re{constructor(){super(...arguments);he(this,"type","StringValue");he(this,"builtins",new Map([["upper",new Ee(()=>new Se(this.value.toUpperCase()))],["lower",new Ee(()=>new Se(this.value.toLowerCase()))],["strip",new Ee(()=>new Se(this.value.trim()))],["title",new Ee(()=>new Se(le(this.value)))],["length",new ve(this.value.length)],["rstrip",new Ee(()=>new Se(this.value.trimEnd()))],["lstrip",new Ee(()=>new Se(this.value.trimStart()))],["split",new Ee(fe=>{const q=fe[0]??new Ve;if(!(q instanceof Se||q instanceof Ve))throw new Error("sep argument must be a string or null");const pe=fe[1]??new ve(-1);if(!(pe instanceof ve))throw new Error("maxsplit argument must be a number");let we=[];if(q instanceof Ve){const Fe=this.value.trimStart();for(const{0:De,index:rt}of Fe.matchAll(/\S+/g)){if(pe.value!==-1&&we.length>=pe.value&&rt!==void 0){we.push(De+Fe.slice(rt+De.length));break}we.push(De)}}else{if(q.value==="")throw new Error("empty separator");we=this.value.split(q.value),pe.value!==-1&&we.length>pe.value&&we.push(we.splice(pe.value).join(q.value))}return new ae(we.map(Fe=>new Se(Fe)))})]]))}},Be=class extends re{constructor(){super(...arguments);he(this,"type","BooleanValue")}},ut=class extends re{constructor(){super(...arguments);he(this,"type","ObjectValue");he(this,"builtins",new Map([["get",new Ee(([fe,q])=>{if(!(fe instanceof Se))throw new Error(`Object key must be a string: got ${fe.type}`);return this.value.get(fe.value)??q??new Ve})],["items",new Ee(()=>new ae(Array.from(this.value.entries()).map(([fe,q])=>new ae([new Se(fe),q]))))]]))}__bool__(){return new Be(this.value.size>0)}},Oe=class extends ut{constructor(){super(...arguments);he(this,"type","KeywordArgumentsValue")}},ae=class extends re{constructor(){super(...arguments);he(this,"type","ArrayValue");he(this,"builtins",new Map([["length",new ve(this.value.length)]]))}__bool__(){return new Be(this.value.length>0)}},Z=class extends ae{constructor(){super(...arguments);he(this,"type","TupleValue")}},Ee=class extends re{constructor(){super(...arguments);he(this,"type","FunctionValue")}},Ve=class extends re{constructor(){super(...arguments);he(this,"type","NullValue")}},Ue=class extends re{constructor(){super(...arguments);he(this,"type","UndefinedValue")}},qe=class{constructor(V){he(this,"variables",new Map([["namespace",new Ee(V=>{if(V.length===0)return new ut(new Map);if(V.length!==1||!(V[0]instanceof ut))throw new Error("`namespace` expects either zero arguments or a single object argument");return V[0]})]]));he(this,"tests",new Map([["boolean",V=>V.type==="BooleanValue"],["callable",V=>V instanceof Ee],["odd",V=>{if(V.type!=="NumericValue")throw new Error(`Cannot apply test "odd" to type: ${V.type}`);return V.value%2!==0}],["even",V=>{if(V.type!=="NumericValue")throw new Error(`Cannot apply test "even" to type: ${V.type}`);return V.value%2===0}],["false",V=>V.type==="BooleanValue"&&!V.value],["true",V=>V.type==="BooleanValue"&&V.value],["none",V=>V.type==="NullValue"],["string",V=>V.type==="StringValue"],["number",V=>V.type==="NumericValue"],["integer",V=>V.type==="NumericValue"&&Number.isInteger(V.value)],["iterable",V=>V.type==="ArrayValue"||V.type==="StringValue"],["mapping",V=>V.type==="ObjectValue"],["lower",V=>{const fe=V.value;return V.type==="StringValue"&&fe===fe.toLowerCase()}],["upper",V=>{const fe=V.value;return V.type==="StringValue"&&fe===fe.toUpperCase()}],["none",V=>V.type==="NullValue"],["defined",V=>V.type!=="UndefinedValue"],["undefined",V=>V.type==="UndefinedValue"],["equalto",(V,fe)=>V.value===fe.value],["eq",(V,fe)=>V.value===fe.value]]));this.parent=V}set(V,fe){return this.declareVariable(V,nt(fe))}declareVariable(V,fe){if(this.variables.has(V))throw new SyntaxError(`Variable already declared: ${V}`);return this.variables.set(V,fe),fe}setVariable(V,fe){return this.variables.set(V,fe),fe}resolve(V){if(this.variables.has(V))return this;if(this.parent)return this.parent.resolve(V);throw new Error(`Unknown variable: ${V}`)}lookupVariable(V){try{return this.resolve(V).variables.get(V)??new Ue}catch{return new Ue}}},We=class{constructor(V){he(this,"global");this.global=V??new qe}run(V){return this.evaluate(V,this.global)}evaluateBinaryExpression(V,fe){const q=this.evaluate(V.left,fe);switch(V.operator.value){case"and":return q.__bool__().value?this.evaluate(V.right,fe):q;case"or":return q.__bool__().value?q:this.evaluate(V.right,fe)}const pe=this.evaluate(V.right,fe);switch(V.operator.value){case"==":return new Be(q.value==pe.value);case"!=":return new Be(q.value!=pe.value)}if(q instanceof Ue||pe instanceof Ue)throw new Error("Cannot perform operation on undefined values");if(q instanceof Ve||pe instanceof Ve)throw new Error("Cannot perform operation on null values");if(q instanceof ve&&pe instanceof ve)switch(V.operator.value){case"+":return new ve(q.value+pe.value);case"-":return new ve(q.value-pe.value);case"*":return new ve(q.value*pe.value);case"/":return new ve(q.value/pe.value);case"%":return new ve(q.value%pe.value);case"<":return new Be(q.value<pe.value);case">":return new Be(q.value>pe.value);case">=":return new Be(q.value>=pe.value);case"<=":return new Be(q.value<=pe.value)}else if(q instanceof ae&&pe instanceof ae)switch(V.operator.value){case"+":return new ae(q.value.concat(pe.value))}else if(pe instanceof ae){const we=pe.value.find(Fe=>Fe.value===q.value)!==void 0;switch(V.operator.value){case"in":return new Be(we);case"not in":return new Be(!we)}}if(q instanceof Se||pe instanceof Se)switch(V.operator.value){case"+":return new Se(q.value.toString()+pe.value.toString())}if(q instanceof Se&&pe instanceof Se)switch(V.operator.value){case"in":return new Be(pe.value.includes(q.value));case"not in":return new Be(!pe.value.includes(q.value))}if(q instanceof Se&&pe instanceof ut)switch(V.operator.value){case"in":return new Be(pe.value.has(q.value));case"not in":return new Be(!pe.value.has(q.value))}throw new SyntaxError(`Unknown operator "${V.operator.value}" between ${q.type} and ${pe.type}`)}evaluateArguments(V,fe){const q=[],pe=new Map;for(const we of V)if(we.type==="KeywordArgumentExpression"){const Fe=we;pe.set(Fe.key.value,this.evaluate(Fe.value,fe))}else{if(pe.size>0)throw new Error("Positional arguments must come before keyword arguments");q.push(this.evaluate(we,fe))}return[q,pe]}evaluateFilterExpression(V,fe){const q=this.evaluate(V.operand,fe);if(V.filter.type==="Identifier"){const pe=V.filter;if(pe.value==="tojson")return new Se(at(q));if(q instanceof ae)switch(pe.value){case"list":return q;case"first":return q.value[0];case"last":return q.value[q.value.length-1];case"length":return new ve(q.value.length);case"reverse":return new ae(q.value.reverse());case"sort":return new ae(q.value.sort((we,Fe)=>{if(we.type!==Fe.type)throw new Error(`Cannot compare different types: ${we.type} and ${Fe.type}`);switch(we.type){case"NumericValue":return we.value-Fe.value;case"StringValue":return we.value.localeCompare(Fe.value);default:throw new Error(`Cannot compare type: ${we.type}`)}}));case"join":return new Se(q.value.map(we=>we.value).join(""));default:throw new Error(`Unknown ArrayValue filter: ${pe.value}`)}else if(q instanceof Se)switch(pe.value){case"length":return new ve(q.value.length);case"upper":return new Se(q.value.toUpperCase());case"lower":return new Se(q.value.toLowerCase());case"title":return new Se(le(q.value));case"capitalize":return new Se(q.value.charAt(0).toUpperCase()+q.value.slice(1));case"trim":return new Se(q.value.trim());case"indent":return new Se(q.value.split(`
`).map((we,Fe)=>Fe===0||we.length===0?we:"    "+we).join(`
`));case"join":case"string":return q;default:throw new Error(`Unknown StringValue filter: ${pe.value}`)}else if(q instanceof ve)switch(pe.value){case"abs":return new ve(Math.abs(q.value));default:throw new Error(`Unknown NumericValue filter: ${pe.value}`)}else if(q instanceof ut)switch(pe.value){case"items":return new ae(Array.from(q.value.entries()).map(([we,Fe])=>new ae([new Se(we),Fe])));case"length":return new ve(q.value.size);default:throw new Error(`Unknown ObjectValue filter: ${pe.value}`)}throw new Error(`Cannot apply filter "${pe.value}" to type: ${q.type}`)}else if(V.filter.type==="CallExpression"){const pe=V.filter;if(pe.callee.type!=="Identifier")throw new Error(`Unknown filter: ${pe.callee.type}`);const we=pe.callee.value;if(we==="tojson"){const[,Fe]=this.evaluateArguments(pe.args,fe),De=Fe.get("indent")??new Ve;if(!(De instanceof ve||De instanceof Ve))throw new Error("If set, indent must be a number");return new Se(at(q,De.value))}else if(we==="join"){let Fe;if(q instanceof Se)Fe=Array.from(q.value);else if(q instanceof ae)Fe=q.value.map(it=>it.value);else throw new Error(`Cannot apply filter "${we}" to type: ${q.type}`);const[De,rt]=this.evaluateArguments(pe.args,fe),He=De.at(0)??rt.get("separator")??new Se("");if(!(He instanceof Se))throw new Error("separator must be a string");return new Se(Fe.join(He.value))}if(q instanceof ae){switch(we){case"selectattr":case"rejectattr":{const Fe=we==="selectattr";if(q.value.some(_t=>!(_t instanceof ut)))throw new Error(`\`${we}\` can only be applied to array of objects`);if(pe.args.some(_t=>_t.type!=="StringLiteral"))throw new Error(`arguments of \`${we}\` must be strings`);const[De,rt,He]=pe.args.map(_t=>this.evaluate(_t,fe));let it;if(rt){const _t=fe.tests.get(rt.value);if(!_t)throw new Error(`Unknown test: ${rt.value}`);it=_t}else it=(..._t)=>_t[0].__bool__().value;const mt=q.value.filter(_t=>{const Ot=_t.value.get(De.value),Ft=Ot?it(Ot,He):!1;return Fe?Ft:!Ft});return new ae(mt)}case"map":{const[,Fe]=this.evaluateArguments(pe.args,fe);if(Fe.has("attribute")){const De=Fe.get("attribute");if(!(De instanceof Se))throw new Error("attribute must be a string");const rt=Fe.get("default"),He=q.value.map(it=>{if(!(it instanceof ut))throw new Error("items in map must be an object");return it.value.get(De.value)??rt??new Ue});return new ae(He)}else throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${we}`)}else if(q instanceof Se){switch(we){case"indent":{const[Fe,De]=this.evaluateArguments(pe.args,fe),rt=Fe.at(0)??De.get("width")??new ve(4);if(!(rt instanceof ve))throw new Error("width must be a number");const He=Fe.at(1)??De.get("first")??new Be(!1),it=Fe.at(2)??De.get("blank")??new Be(!1),mt=q.value.split(`
`),_t=" ".repeat(rt.value),Ot=mt.map((Ft,Dn)=>!He.value&&Dn===0||!it.value&&Ft.length===0?Ft:_t+Ft);return new Se(Ot.join(`
`))}}throw new Error(`Unknown StringValue filter: ${we}`)}else throw new Error(`Cannot apply filter "${we}" to type: ${q.type}`)}throw new Error(`Unknown filter: ${V.filter.type}`)}evaluateTestExpression(V,fe){const q=this.evaluate(V.operand,fe),pe=fe.tests.get(V.test.value);if(!pe)throw new Error(`Unknown test: ${V.test.value}`);const we=pe(q);return new Be(V.negate?!we:we)}evaluateUnaryExpression(V,fe){const q=this.evaluate(V.argument,fe);switch(V.operator.value){case"not":return new Be(!q.value);default:throw new SyntaxError(`Unknown operator: ${V.operator.value}`)}}evalProgram(V,fe){return this.evaluateBlock(V.body,fe)}evaluateBlock(V,fe){let q="";for(const pe of V){const we=this.evaluate(pe,fe);we.type!=="NullValue"&&we.type!=="UndefinedValue"&&(q+=we.value)}return new Se(q)}evaluateIdentifier(V,fe){return fe.lookupVariable(V.value)}evaluateCallExpression(V,fe){const[q,pe]=this.evaluateArguments(V.args,fe);pe.size>0&&q.push(new Oe(pe));const we=this.evaluate(V.callee,fe);if(we.type!=="FunctionValue")throw new Error(`Cannot call something that is not a function: got ${we.type}`);return we.value(q,fe)}evaluateSliceExpression(V,fe,q){if(!(V instanceof ae||V instanceof Se))throw new Error("Slice object must be an array or string");const pe=this.evaluate(fe.start,q),we=this.evaluate(fe.stop,q),Fe=this.evaluate(fe.step,q);if(!(pe instanceof ve||pe instanceof Ue))throw new Error("Slice start must be numeric or undefined");if(!(we instanceof ve||we instanceof Ue))throw new Error("Slice stop must be numeric or undefined");if(!(Fe instanceof ve||Fe instanceof Ue))throw new Error("Slice step must be numeric or undefined");return V instanceof ae?new ae(Q(V.value,pe.value,we.value,Fe.value)):new Se(Q(Array.from(V.value),pe.value,we.value,Fe.value).join(""))}evaluateMemberExpression(V,fe){const q=this.evaluate(V.object,fe);let pe;if(V.computed){if(V.property.type==="SliceExpression")return this.evaluateSliceExpression(q,V.property,fe);pe=this.evaluate(V.property,fe)}else pe=new Se(V.property.value);let we;if(q instanceof ut){if(!(pe instanceof Se))throw new Error(`Cannot access property with non-string: got ${pe.type}`);we=q.value.get(pe.value)??q.builtins.get(pe.value)}else if(q instanceof ae||q instanceof Se)if(pe instanceof ve)we=q.value.at(pe.value),q instanceof Se&&(we=new Se(q.value.at(pe.value)));else if(pe instanceof Se)we=q.builtins.get(pe.value);else throw new Error(`Cannot access property with non-string/non-number: got ${pe.type}`);else{if(!(pe instanceof Se))throw new Error(`Cannot access property with non-string: got ${pe.type}`);we=q.builtins.get(pe.value)}return we instanceof re?we:new Ue}evaluateSet(V,fe){const q=this.evaluate(V.value,fe);if(V.assignee.type==="Identifier"){const pe=V.assignee.value;fe.setVariable(pe,q)}else if(V.assignee.type==="MemberExpression"){const pe=V.assignee,we=this.evaluate(pe.object,fe);if(!(we instanceof ut))throw new Error("Cannot assign to member of non-object");if(pe.property.type!=="Identifier")throw new Error("Cannot assign to member with non-identifier property");we.value.set(pe.property.value,q)}else throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(V.assignee)}`);return new Ve}evaluateIf(V,fe){const q=this.evaluate(V.test,fe);return this.evaluateBlock(q.__bool__().value?V.body:V.alternate,fe)}evaluateFor(V,fe){const q=new qe(fe);let pe,we;if(V.iterable.type==="SelectExpression"){const it=V.iterable;we=this.evaluate(it.iterable,q),pe=it.test}else we=this.evaluate(V.iterable,q);if(!(we instanceof ae))throw new Error(`Expected iterable type in for loop: got ${we.type}`);const Fe=[],De=[];for(let it=0;it<we.value.length;++it){const mt=new qe(q),_t=we.value[it];let Ot;if(V.loopvar.type==="Identifier")Ot=Ft=>Ft.setVariable(V.loopvar.value,_t);else if(V.loopvar.type==="TupleLiteral"){const Ft=V.loopvar;if(_t.type!=="ArrayValue")throw new Error(`Cannot unpack non-iterable type: ${_t.type}`);const Dn=_t;if(Ft.value.length!==Dn.value.length)throw new Error(`Too ${Ft.value.length>Dn.value.length?"few":"many"} items to unpack`);Ot=hn=>{for(let Kn=0;Kn<Ft.value.length;++Kn){if(Ft.value[Kn].type!=="Identifier")throw new Error(`Cannot unpack non-identifier type: ${Ft.value[Kn].type}`);hn.setVariable(Ft.value[Kn].value,Dn.value[Kn])}}}else throw new Error(`Invalid loop variable(s): ${V.loopvar.type}`);pe&&(Ot(mt),!this.evaluate(pe,mt).__bool__().value)||(Fe.push(_t),De.push(Ot))}let rt="",He=!0;for(let it=0;it<Fe.length;++it){const mt=new Map([["index",new ve(it+1)],["index0",new ve(it)],["revindex",new ve(Fe.length-it)],["revindex0",new ve(Fe.length-it-1)],["first",new Be(it===0)],["last",new Be(it===Fe.length-1)],["length",new ve(Fe.length)],["previtem",it>0?Fe[it-1]:new Ue],["nextitem",it<Fe.length-1?Fe[it+1]:new Ue]]);q.setVariable("loop",new ut(mt)),De[it](q);const _t=this.evaluateBlock(V.body,q);rt+=_t.value,He=!1}if(He){const it=this.evaluateBlock(V.defaultBlock,q);rt+=it.value}return new Se(rt)}evaluateMacro(V,fe){return fe.setVariable(V.name.value,new Ee((q,pe)=>{var De;const we=new qe(pe);q=q.slice();let Fe;((De=q.at(-1))==null?void 0:De.type)==="KeywordArgumentsValue"&&(Fe=q.pop());for(let rt=0;rt<V.args.length;++rt){const He=V.args[rt],it=q[rt];if(He.type==="Identifier"){const mt=He;if(!it)throw new Error(`Missing positional argument: ${mt.value}`);we.setVariable(mt.value,it)}else if(He.type==="KeywordArgumentExpression"){const mt=He,_t=it??(Fe==null?void 0:Fe.value.get(mt.key.value))??this.evaluate(mt.value,we);we.setVariable(mt.key.value,_t)}else throw new Error(`Unknown argument type: ${He.type}`)}return this.evaluateBlock(V.body,we)})),new Ve}evaluate(V,fe){if(V===void 0)return new Ue;switch(V.type){case"Program":return this.evalProgram(V,fe);case"Set":return this.evaluateSet(V,fe);case"If":return this.evaluateIf(V,fe);case"For":return this.evaluateFor(V,fe);case"Macro":return this.evaluateMacro(V,fe);case"NumericLiteral":return new ve(Number(V.value));case"StringLiteral":return new Se(V.value);case"BooleanLiteral":return new Be(V.value);case"NullLiteral":return new Ve(V.value);case"ArrayLiteral":return new ae(V.value.map(q=>this.evaluate(q,fe)));case"TupleLiteral":return new Z(V.value.map(q=>this.evaluate(q,fe)));case"ObjectLiteral":{const q=new Map;for(const[pe,we]of V.value){const Fe=this.evaluate(pe,fe);if(!(Fe instanceof Se))throw new Error(`Object keys must be strings: got ${Fe.type}`);q.set(Fe.value,this.evaluate(we,fe))}return new ut(q)}case"Identifier":return this.evaluateIdentifier(V,fe);case"CallExpression":return this.evaluateCallExpression(V,fe);case"MemberExpression":return this.evaluateMemberExpression(V,fe);case"UnaryExpression":return this.evaluateUnaryExpression(V,fe);case"BinaryExpression":return this.evaluateBinaryExpression(V,fe);case"FilterExpression":return this.evaluateFilterExpression(V,fe);case"TestExpression":return this.evaluateTestExpression(V,fe);default:throw new SyntaxError(`Unknown node type: ${V.type}`)}}};function nt(V){switch(typeof V){case"number":return new ve(V);case"string":return new Se(V);case"boolean":return new Be(V);case"undefined":return new Ue;case"object":return V===null?new Ve:Array.isArray(V)?new ae(V.map(nt)):new ut(new Map(Object.entries(V).map(([fe,q])=>[fe,nt(q)])));case"function":return new Ee((fe,q)=>{const pe=V(...fe.map(we=>we.value))??null;return nt(pe)});default:throw new Error(`Cannot convert to runtime value: ${V}`)}}function at(V,fe,q){const pe=q??0;switch(V.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(V.value);case"ArrayValue":case"ObjectValue":{const we=fe?" ".repeat(fe):"",Fe=`
`+we.repeat(pe),De=Fe+we;if(V.type==="ArrayValue"){const rt=V.value.map(He=>at(He,fe,pe+1));return fe?`[${De}${rt.join(`,${De}`)}${Fe}]`:`[${rt.join(", ")}]`}else{const rt=Array.from(V.value.entries()).map(([He,it])=>{const mt=`"${He}": ${at(it,fe,pe+1)}`;return fe?`${De}${mt}`:mt});return fe?`{${rt.join(",")}${Fe}}`:`{${rt.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${V.type}`)}}var ct=class{constructor(V){he(this,"parsed");const fe=_(V,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=U(fe)}render(V){const fe=new qe;if(fe.set("false",!1),fe.set("true",!0),fe.set("raise_exception",we=>{throw new Error(we)}),fe.set("range",B),V)for(const[we,Fe]of Object.entries(V))fe.set(we,Fe);return new We(fe).run(this.parsed).value}}},"./src/backends/onnx.js":(t,s,n)=>{var i;n.r(s),n.d(s,{Tensor:()=>p.Tensor,createInferenceSession:()=>L,deviceToExecutionProviders:()=>b,isONNXProxy:()=>I,isONNXTensor:()=>C});var l=n("./src/env.js"),o=n("?2ce3"),c=n("onnxruntime-web"),p=n("onnxruntime-common");const d=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),f=[];let g,_;const y=Symbol.for("onnxruntime");if(y in globalThis)_=globalThis[y];else if(l.apis.IS_NODE_ENV){switch(_=o??(i||(i=n.t(o,2))),process.platform){case"win32":f.push("dml");break;case"linux":process.arch==="x64"&&f.push("cuda");break}f.push("cpu"),g=["cpu"]}else _=c,l.apis.IS_WEBNN_AVAILABLE&&f.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),l.apis.IS_WEBGPU_AVAILABLE&&f.push("webgpu"),f.push("wasm"),g=["wasm"];const T=_.InferenceSession;function b(O=null){if(!O)return g;switch(O){case"auto":return f;case"gpu":return f.filter(x=>["webgpu","cuda","dml","webnn-gpu"].includes(x))}if(f.includes(O))return[d[O]??O];throw new Error(`Unsupported device: "${O}". Should be one of: ${f.join(", ")}.`)}let k=null;async function L(O,x,E){k&&await k;const A=T.create(O,x);k??(k=A);const F=await A;return F.config=E,F}function C(O){return O instanceof _.Tensor}const S=_==null?void 0:_.env;S!=null&&S.wasm&&(!(typeof ServiceWorkerGlobalScope<"u"&&self instanceof ServiceWorkerGlobalScope)&&!S.wasm.wasmPaths&&(S.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${l.env.version}/dist/`),S.wasm.proxy=!1),S!=null&&S.webgpu&&(S.webgpu.powerPreference="high-performance");function I(){var O;return(O=S==null?void 0:S.wasm)==null?void 0:O.proxy}l.env.backends.onnx=S},"./src/base/feature_extraction_utils.js":(t,s,n)=>{n.r(s),n.d(s,{FeatureExtractor:()=>c,validate_audio_inputs:()=>p});var i=n("./src/utils/constants.js"),l=n("./src/utils/generic.js"),o=n("./src/utils/hub.js");class c extends l.Callable{constructor(f){super(),this.config=f}static async from_pretrained(f,g){const _=await(0,o.getModelJSON)(f,i.FEATURE_EXTRACTOR_NAME,!0,g);return new this(_)}}function p(d,f){var g;if(!(d instanceof Float32Array||d instanceof Float64Array))throw new Error(`${f} expects input to be a Float32Array or a Float64Array, but got ${((g=d==null?void 0:d.constructor)==null?void 0:g.name)??typeof d} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}},"./src/base/image_processors_utils.js":(t,s,n)=>{n.r(s),n.d(s,{ImageProcessor:()=>O,center_to_corners_format:()=>_,post_process_instance_segmentation:()=>I,post_process_object_detection:()=>y,post_process_panoptic_segmentation:()=>S,post_process_semantic_segmentation:()=>T});var i=n("./src/utils/generic.js"),l=n("./src/utils/tensor.js"),o=n("./src/utils/maths.js");n("./src/utils/image.js");var c=n("./src/utils/core.js"),p=n("./src/utils/hub.js"),d=n("./src/utils/constants.js");function f(x,E,A=0,F=null){const K=x/E;let X=(0,o.bankers_round)(K)*E;return F!==null&&X>F&&(X=Math.floor(K)*E),X<A&&(X=Math.ceil(K)*E),X}function g([x,E],A){return[Math.max(Math.floor(x/A),1)*A,Math.max(Math.floor(E/A),1)*A]}function _([x,E,A,F]){return[x-A/2,E-F/2,x+A/2,E+F/2]}function y(x,E=.5,A=null,F=!1){const K=x.logits,X=x.pred_boxes,[oe,ie,J]=K.dims;if(A!==null&&A.length!==oe)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let ue=[];for(let ne=0;ne<oe;++ne){let G=A!==null?A[ne]:null,se={boxes:[],classes:[],scores:[]},ce=K[ne],ge=X[ne];for(let W=0;W<ie;++W){let U=ce[W],B=[],Q;if(F){Q=U.sigmoid().data;for(let le=0;le<Q.length;++le)Q[le]>E&&B.push(le)}else{let le=(0,o.max)(U.data)[1];if(le===J-1||(Q=(0,o.softmax)(U.data),Q[le]<E))continue;B.push(le)}for(const le of B){let re=ge[W].data;re=_(re),G!==null&&(re=re.map((ve,Se)=>ve*G[(Se+1)%2])),se.boxes.push(re),se.classes.push(le),se.scores.push(Q[le])}}ue.push(se)}return ue}function T(x,E=null){const A=x.logits,F=A.dims[0];if(E!==null&&E.length!==F)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const K=[];for(let X=0;X<F;++X){const oe=E!==null?E[X]:null;let ie=A[X];oe!==null&&(ie=(0,l.interpolate)(ie,oe,"bilinear",!1));const[J,ue]=oe??ie.dims.slice(-2),ne=new l.Tensor("int32",new Int32Array(J*ue),[J,ue]),G=ie[0].data,se=ne.data;for(let W=1;W<ie.dims[0];++W){const U=ie[W].data;for(let B=0;B<U.length;++B)U[B]>G[B]&&(G[B]=U[B],se[B]=W)}const ce=new Array(ie.dims[0]);for(let W=0;W<se.length;++W){const U=se[W];ce[U]=U}const ge=ce.filter(W=>W!==void 0);K.push({segmentation:ne,labels:ge})}return K}function b(x,E,A,F){const K=[],X=[],oe=[];for(let ie=0;ie<x.dims[0];++ie){const J=x[ie],ue=E[ie],ne=(0,o.max)(J.data)[1];if(ne===F)continue;const se=(0,o.softmax)(J.data)[ne];se>A&&(K.push(ue),X.push(se),oe.push(ne))}return[K,X,oe]}function k(x,E,A,F=.5,K=.8){const X=[];let oe=0,ie=0;const J=E[A].data;for(let ne=0;ne<x.length;++ne)x[ne]===A&&(X.push(ne),++oe),J[ne]>=F&&++ie;let ue=oe>0&&ie>0;return ue&&(ue=oe/ie>K),[ue,X]}function L(x,E,A,F,K,X=null,oe=null){const[ie,J]=oe??x[0].dims,ue=new l.Tensor("int32",new Int32Array(ie*J),[ie,J]),ne=[];if(oe!==null)for(let W=0;W<x.length;++W)x[W]=(0,l.interpolate)(x[W],oe,"bilinear",!1);const G=new Int32Array(x[0].data.length),se=new Float32Array(x[0].data.length);for(let W=0;W<x.length;++W){let U=E[W];const B=x[W].data;for(let Q=0;Q<B.length;++Q)B[Q]*=U,B[Q]>se[Q]&&(G[Q]=W,se[Q]=B[Q])}let ce=0;const ge=ue.data;for(let W=0;W<A.length;++W){const U=A[W],[B,Q]=k(G,x,W,F,K);if(B){++ce;for(const le of Q)ge[le]=ce;ne.push({id:ce,label_id:U,score:E[W]})}}return[ue,ne]}function C(x,E,A=28,F=56*56,K=14*14*4*1280){if(x<A||E<A)throw new Error(`height:${x} or width:${E} must be larger than factor:${A}`);if(Math.max(x,E)/Math.min(x,E)>200)throw new Error(`absolute aspect ratio must be smaller than 200, got ${Math.max(x,E)/Math.min(x,E)}`);let X=Math.round(x/A)*A,oe=Math.round(E/A)*A;if(X*oe>K){const ie=Math.sqrt(x*E/K);X=Math.floor(x/ie/A)*A,oe=Math.floor(E/ie/A)*A}else if(X*oe<F){const ie=Math.sqrt(F/(x*E));X=Math.ceil(x*ie/A)*A,oe=Math.ceil(E*ie/A)*A}return[X,oe]}function S(x,E=.5,A=.5,F=.8,K=null,X=null){K===null&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),K=new Set);const oe=x.class_queries_logits??x.logits,J=(x.masks_queries_logits??x.pred_masks).sigmoid();let[ue,ne,G]=oe.dims;if(G-=1,X!==null&&X.length!==ue)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let se=[];for(let ce=0;ce<ue;++ce){let ge=X!==null?X[ce]:null,W=oe[ce],U=J[ce],[B,Q,le]=b(W,U,E,G);if(le.length===0){let[Se,Be]=ge??U.dims.slice(-2),ut=new l.Tensor("int32",new Int32Array(Se*Be).fill(-1),[Se,Be]);se.push({segmentation:ut,segments_info:[]});continue}let[re,ve]=L(B,Q,le,A,F,K,ge);se.push({segmentation:re,segments_info:ve})}return se}function I(x,E=.5,A=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class O extends i.Callable{constructor(E){super(),this.image_mean=E.image_mean??E.mean,this.image_std=E.image_std??E.std,this.resample=E.resample??2,this.do_rescale=E.do_rescale??!0,this.rescale_factor=E.rescale_factor??1/255,this.do_normalize=E.do_normalize,this.do_thumbnail=E.do_thumbnail,this.size=E.size??E.image_size,this.do_resize=E.do_resize??this.size!==void 0,this.size_divisibility=E.size_divisibility??E.size_divisor,this.do_center_crop=E.do_center_crop,this.crop_size=E.crop_size,this.do_convert_rgb=E.do_convert_rgb??!0,this.do_crop_margin=E.do_crop_margin,this.pad_size=E.pad_size,this.do_pad=E.do_pad,this.do_pad&&!this.pad_size&&this.size&&this.size.width!==void 0&&this.size.height!==void 0&&(this.pad_size=this.size),this.do_flip_channel_order=E.do_flip_channel_order??!1,this.config=E}async thumbnail(E,A,F=2){const K=E.height,X=E.width,oe=A.height,ie=A.width;let J=Math.min(K,oe),ue=Math.min(X,ie);return J===K&&ue===X?E:(K>X?ue=Math.floor(X*J/K):X>K&&(J=Math.floor(K*ue/X)),await E.resize(ue,J,{resample:F}))}async crop_margin(E,A=200){const F=E.clone().grayscale(),K=(0,o.min)(F.data)[0],oe=(0,o.max)(F.data)[0]-K;if(oe===0)return E;const ie=A/255;let J=F.width,ue=F.height,ne=0,G=0;const se=F.data;for(let ce=0;ce<F.height;++ce){const ge=ce*F.width;for(let W=0;W<F.width;++W)(se[ge+W]-K)/oe<ie&&(J=Math.min(J,W),ue=Math.min(ue,ce),ne=Math.max(ne,W),G=Math.max(G,ce))}return E=await E.crop([J,ue,ne,G]),E}pad_image(E,A,F,{mode:K="constant",center:X=!1,constant_values:oe=0}={}){const[ie,J,ue]=A;let ne,G;if(typeof F=="number"?(ne=F,G=F):F==="square"?ne=G=Math.max(ie,J):(ne=F.width,G=F.height),ne!==J||G!==ie){const se=new Float32Array(ne*G*ue);if(Array.isArray(oe))for(let W=0;W<se.length;++W)se[W]=oe[W%ue];else oe!==0&&se.fill(oe);const[ce,ge]=X?[Math.floor((ne-J)/2),Math.floor((G-ie)/2)]:[0,0];for(let W=0;W<ie;++W){const U=(W+ge)*ne,B=W*J;for(let Q=0;Q<J;++Q){const le=(U+Q+ce)*ue,re=(B+Q)*ue;for(let ve=0;ve<ue;++ve)se[le+ve]=E[re+ve]}}if(K==="symmetric"){if(X)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const W=ie-1,U=J-1;for(let B=0;B<G;++B){const Q=B*ne,le=(0,c.calculateReflectOffset)(B,W)*J;for(let re=0;re<ne;++re){if(B<ie&&re<J)continue;const ve=(Q+re)*ue,Se=(le+(0,c.calculateReflectOffset)(re,U))*ue;for(let Be=0;Be<ue;++Be)se[ve+Be]=E[Se+Be]}}}E=se,A=[G,ne,ue]}return[E,A]}rescale(E){for(let A=0;A<E.length;++A)E[A]=this.rescale_factor*E[A]}get_resize_output_image_size(E,A){const[F,K]=E.size;let X,oe;if(this.do_thumbnail){const{height:ie,width:J}=A;X=Math.min(ie,J)}else Number.isInteger(A)?(X=A,oe=this.config.max_size??X):A!==void 0&&(X=A.shortest_edge,oe=A.longest_edge);if(X!==void 0||oe!==void 0){const ie=X===void 0?1:Math.max(X/F,X/K),J=F*ie,ue=K*ie,ne=oe===void 0?1:Math.min(oe/J,oe/ue);let G=Math.floor(Number((J*ne).toFixed(2))),se=Math.floor(Number((ue*ne).toFixed(2)));return this.size_divisibility!==void 0&&([G,se]=g([G,se],this.size_divisibility)),[G,se]}else if(A!==void 0&&A.width!==void 0&&A.height!==void 0){let ie=A.width,J=A.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let ue=J/K,ne=ie/F;Math.abs(1-ne)<Math.abs(1-ue)?ue=ne:ne=ue,J=f(ue*K,this.config.ensure_multiple_of),ie=f(ne*F,this.config.ensure_multiple_of)}return[ie,J]}else{if(this.size_divisibility!==void 0)return g([F,K],this.size_divisibility);if(A.min_pixels!==void 0&&A.max_pixels!==void 0){const{min_pixels:ie,max_pixels:J}=A,ue=this.config.patch_size*this.config.merge_size;return C(K,F,ue,ie,J)}else throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(A)}`)}}async resize(E){const[A,F]=this.get_resize_output_image_size(E,this.size);return await E.resize(A,F,{resample:this.resample})}async preprocess(E,{do_normalize:A=null,do_pad:F=null,do_convert_rgb:K=null,do_convert_grayscale:X=null,do_flip_channel_order:oe=null}={}){this.do_crop_margin&&(E=await this.crop_margin(E));const[ie,J]=E.size;if(K??this.do_convert_rgb?E=E.rgb():X&&(E=E.grayscale()),this.do_resize&&(E=await this.resize(E)),this.do_thumbnail&&(E=await this.thumbnail(E,this.size,this.resample)),this.do_center_crop){let ce,ge;Number.isInteger(this.crop_size)?(ce=this.crop_size,ge=this.crop_size):(ce=this.crop_size.width,ge=this.crop_size.height),E=await E.center_crop(ce,ge)}const ue=[E.height,E.width];let ne=Float32Array.from(E.data),G=[E.height,E.width,E.channels];if(this.do_rescale&&this.rescale(ne),A??this.do_normalize){let ce=this.image_mean;Array.isArray(this.image_mean)||(ce=new Array(E.channels).fill(ce));let ge=this.image_std;if(Array.isArray(this.image_std)||(ge=new Array(E.channels).fill(ce)),ce.length!==E.channels||ge.length!==E.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${ce.length}) and \`image_std\` (${ge.length}) must match the number of channels in the image (${E.channels}).`);for(let W=0;W<ne.length;W+=E.channels)for(let U=0;U<E.channels;++U)ne[W+U]=(ne[W+U]-ce[U])/ge[U]}if(F??this.do_pad){if(this.pad_size)[ne,G]=this.pad_image(ne,[E.height,E.width,E.channels],this.pad_size);else if(this.size_divisibility){const[ce,ge]=g([G[1],G[0]],this.size_divisibility);[ne,G]=this.pad_image(ne,G,{width:ce,height:ge})}}if(oe??this.do_flip_channel_order){if(G[2]!==3)throw new Error("Flipping channel order is only supported for RGB images.");for(let ce=0;ce<ne.length;ce+=3){const ge=ne[ce];ne[ce]=ne[ce+2],ne[ce+2]=ge}}const se=new l.Tensor("float32",ne,G).permute(2,0,1);return{original_size:[J,ie],reshaped_input_size:ue,pixel_values:se}}async _call(E,...A){Array.isArray(E)||(E=[E]);const F=await Promise.all(E.map(X=>this.preprocess(X)));return{pixel_values:(0,l.stack)(F.map(X=>X.pixel_values),0),original_sizes:F.map(X=>X.original_size),reshaped_input_sizes:F.map(X=>X.reshaped_input_size)}}static async from_pretrained(E,A){const F=await(0,p.getModelJSON)(E,d.IMAGE_PROCESSOR_NAME,!0,A);return new this(F)}}},"./src/base/processing_utils.js":(t,s,n)=>{n.r(s),n.d(s,{Processor:()=>c});var i=n("./src/utils/constants.js"),l=n("./src/utils/generic.js"),o=n("./src/utils/hub.js");class c extends l.Callable{constructor(d,f){super(),this.config=d,this.components=f}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(d,f={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(d,{tokenize:!1,...f})}batch_decode(...d){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...d)}decode(...d){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...d)}async _call(d,...f){for(const g of[this.image_processor,this.feature_extractor,this.tokenizer])if(g)return g(d,...f);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(d,f){const[g,_]=await Promise.all([this.uses_processor_config?(0,o.getModelJSON)(d,i.PROCESSOR_NAME,!0,f):{},Promise.all(this.classes.filter(y=>y in this).map(async y=>{const T=await this[y].from_pretrained(d,f);return[y.replace(/_class$/,""),T]})).then(Object.fromEntries)]);return new this(g,_)}}he(c,"classes",["image_processor_class","tokenizer_class","feature_extractor_class"]),he(c,"uses_processor_config",!1)},"./src/configs.js":(t,s,n)=>{n.r(s),n.d(s,{AutoConfig:()=>f,PretrainedConfig:()=>d,getKeyValueShapes:()=>p});var i=n("./src/utils/core.js"),l=n("./src/utils/hub.js");async function o(g,_){return await(0,l.getModelJSON)(g,"config.json",!0,_)}function c(g){const _={};let y={};switch(g.model_type){case"llava":case"paligemma":case"gemma3":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"smolvlm":y=c(g.text_config);break;case"moondream1":y=c(g.phi_config);break;case"musicgen":y=c(g.decoder);break;case"multi_modality":y=c(g.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":_.num_heads="n_head",_.num_layers="n_layer",_.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":_.num_heads="num_attention_heads",_.num_layers="num_hidden_layers",_.hidden_size="hidden_size";break;case"llama":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":_.num_heads="num_key_value_heads",_.num_layers="num_hidden_layers",_.hidden_size="hidden_size",_.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":case"gemma3_text":case"glm":case"helium":_.num_heads="num_key_value_heads",_.num_layers="num_hidden_layers",_.dim_kv="head_dim";break;case"openelm":_.num_heads="num_kv_heads",_.num_layers="num_transformer_layers",_.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":_.num_heads="num_heads",_.num_layers="num_layers",_.hidden_size="hidden_size";break;case"bloom":_.num_heads="n_head",_.num_layers="n_layer",_.hidden_size="hidden_size";break;case"mpt":_.num_heads="n_heads",_.num_layers="n_layers",_.hidden_size="d_model";break;case"exaone":_.num_heads="num_key_value_heads",_.num_layers="num_layers",_.dim_kv="head_dim",_.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":_.num_decoder_layers="num_decoder_layers",_.num_decoder_heads="num_heads",_.decoder_dim_kv="d_kv",_.num_encoder_layers="num_layers",_.num_encoder_heads="num_heads",_.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":_.num_decoder_layers="decoder_layers",_.num_decoder_heads="decoder_attention_heads",_.decoder_hidden_size="d_model",_.num_encoder_layers="encoder_layers",_.num_encoder_heads="encoder_attention_heads",_.encoder_hidden_size="d_model";break;case"speecht5":_.num_decoder_layers="decoder_layers",_.num_decoder_heads="decoder_attention_heads",_.decoder_hidden_size="hidden_size",_.num_encoder_layers="encoder_layers",_.num_encoder_heads="encoder_attention_heads",_.encoder_hidden_size="hidden_size";break;case"trocr":_.num_encoder_layers=_.num_decoder_layers="decoder_layers",_.num_encoder_heads=_.num_decoder_heads="decoder_attention_heads",_.encoder_hidden_size=_.decoder_hidden_size="d_model";break;case"musicgen_decoder":_.num_encoder_layers=_.num_decoder_layers="num_hidden_layers",_.num_encoder_heads=_.num_decoder_heads="num_attention_heads",_.encoder_hidden_size=_.decoder_hidden_size="hidden_size";break;case"moonshine":_.num_decoder_layers="decoder_num_hidden_layers",_.num_decoder_heads="decoder_num_key_value_heads",_.num_encoder_layers="encoder_num_hidden_layers",_.num_encoder_heads="encoder_num_key_value_heads",_.encoder_hidden_size=_.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const b=c(g.decoder),k="num_decoder_layers"in b,L=(0,i.pick)(g,["model_type","is_encoder_decoder"]);return k?(L.num_decoder_layers=b.num_decoder_layers,L.num_decoder_heads=b.num_decoder_heads,L.decoder_hidden_size=b.decoder_hidden_size,L.num_encoder_layers=b.num_encoder_layers,L.num_encoder_heads=b.num_encoder_heads,L.encoder_hidden_size=b.encoder_hidden_size):(L.num_layers=b.num_layers,L.num_heads=b.num_heads,L.hidden_size=b.hidden_size),L}const T={...y,...(0,i.pick)(g,["model_type","multi_query","is_encoder_decoder"])};for(const b in _)T[b]=g[_[b]];return T}function p(g,{prefix:_="past_key_values",batch_size:y=1}={}){const T={},b=g.normalized_config;if(b.is_encoder_decoder&&"num_encoder_heads"in b&&"num_decoder_heads"in b){const k=b.encoder_dim_kv??b.encoder_hidden_size/b.num_encoder_heads,L=b.decoder_dim_kv??b.decoder_hidden_size/b.num_decoder_heads,C=[y,b.num_encoder_heads,0,k],S=[y,b.num_decoder_heads,0,L];for(let I=0;I<b.num_decoder_layers;++I)T[`${_}.${I}.encoder.key`]=C,T[`${_}.${I}.encoder.value`]=C,T[`${_}.${I}.decoder.key`]=S,T[`${_}.${I}.decoder.value`]=S}else{const k=b.num_heads,L=b.num_layers,C=b.dim_kv??b.hidden_size/(b.num_attention_heads??k);if(b.model_type==="falcon"){const S=[y*k,0,C];for(let I=0;I<L;++I)T[`${_}.${I}.key`]=S,T[`${_}.${I}.value`]=S}else if(b.multi_query){const S=[y*k,0,2*C];for(let I=0;I<L;++I)T[`${_}.${I}.key_value`]=S}else if(b.model_type==="bloom"){const S=[y*k,C,0],I=[y*k,0,C];for(let O=0;O<L;++O)T[`${_}.${O}.key`]=S,T[`${_}.${O}.value`]=I}else if(b.model_type==="openelm")for(let S=0;S<L;++S){const I=[y,k[S],0,C];T[`${_}.${S}.key`]=I,T[`${_}.${S}.value`]=I}else{const S=[y,k,0,C];for(let I=0;I<L;++I)T[`${_}.${I}.key`]=S,T[`${_}.${I}.value`]=S}}return T}class d{constructor(_){he(this,"model_type",null);he(this,"is_encoder_decoder",!1);he(this,"max_position_embeddings");he(this,"transformers.js_config");Object.assign(this,_),this.normalized_config=c(this)}static async from_pretrained(_,{progress_callback:y=null,config:T=null,cache_dir:b=null,local_files_only:k=!1,revision:L="main"}={}){T&&!(T instanceof d)&&(T=new d(T));const C=T??await o(_,{progress_callback:y,config:T,cache_dir:b,local_files_only:k,revision:L});return new this(C)}}class f{static async from_pretrained(..._){return d.from_pretrained(..._)}}},"./src/env.js":(t,s,n)=>{var F,K;n.r(s),n.d(s,{apis:()=>L,env:()=>E});var i=n("?569f"),l=n("?3f59"),o=n("?154a");const c="3.4.2",p=typeof window<"u"&&typeof window.document<"u",d=typeof self<"u"&&((F=self.constructor)==null?void 0:F.name)==="DedicatedWorkerGlobalScope",f=typeof self<"u"&&"caches"in self,g=typeof navigator<"u"&&"gpu"in navigator,_=typeof navigator<"u"&&"ml"in navigator,y=typeof process<"u",T=y&&((K=process==null?void 0:process.release)==null?void 0:K.name)==="node",b=!A(i),k=!A(l),L=Object.freeze({IS_BROWSER_ENV:p,IS_WEBWORKER_ENV:d,IS_WEB_CACHE_AVAILABLE:f,IS_WEBGPU_AVAILABLE:g,IS_WEBNN_AVAILABLE:_,IS_PROCESS_AVAILABLE:y,IS_NODE_ENV:T,IS_FS_AVAILABLE:b,IS_PATH_AVAILABLE:k}),C=b&&k;let S="./";if(C){const X=Object(import.meta).url;X?S=l.dirname(l.dirname(o.fileURLToPath(X))):typeof __dirname<"u"&&(S=l.dirname(__dirname))}const I=C?l.join(S,"/.cache/"):null,O="/models/",x=C?l.join(S,O):O,E={version:c,backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(p||d),localModelPath:x,useFS:b,useBrowserCache:f,useFSCache:b,cacheDir:I,useCustomCache:!1,customCache:null};function A(X){return Object.keys(X).length===0}},"./src/generation/configuration_utils.js":(t,s,n)=>{n.r(s),n.d(s,{GenerationConfig:()=>l});var i=n("./src/utils/core.js");class l{constructor(c){he(this,"max_length",20);he(this,"max_new_tokens",null);he(this,"min_length",0);he(this,"min_new_tokens",null);he(this,"early_stopping",!1);he(this,"max_time",null);he(this,"do_sample",!1);he(this,"num_beams",1);he(this,"num_beam_groups",1);he(this,"penalty_alpha",null);he(this,"use_cache",!0);he(this,"temperature",1);he(this,"top_k",50);he(this,"top_p",1);he(this,"typical_p",1);he(this,"epsilon_cutoff",0);he(this,"eta_cutoff",0);he(this,"diversity_penalty",0);he(this,"repetition_penalty",1);he(this,"encoder_repetition_penalty",1);he(this,"length_penalty",1);he(this,"no_repeat_ngram_size",0);he(this,"bad_words_ids",null);he(this,"force_words_ids",null);he(this,"renormalize_logits",!1);he(this,"constraints",null);he(this,"forced_bos_token_id",null);he(this,"forced_eos_token_id",null);he(this,"remove_invalid_values",!1);he(this,"exponential_decay_length_penalty",null);he(this,"suppress_tokens",null);he(this,"streamer",null);he(this,"begin_suppress_tokens",null);he(this,"forced_decoder_ids",null);he(this,"guidance_scale",null);he(this,"num_return_sequences",1);he(this,"output_attentions",!1);he(this,"output_hidden_states",!1);he(this,"output_scores",!1);he(this,"return_dict_in_generate",!1);he(this,"pad_token_id",null);he(this,"bos_token_id",null);he(this,"eos_token_id",null);he(this,"encoder_no_repeat_ngram_size",0);he(this,"decoder_start_token_id",null);he(this,"generation_kwargs",{});Object.assign(this,(0,i.pick)(c,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":(t,s,n)=>{n.r(s),n.d(s,{ClassifierFreeGuidanceLogitsProcessor:()=>C,ForcedBOSTokenLogitsProcessor:()=>d,ForcedEOSTokenLogitsProcessor:()=>f,LogitsProcessor:()=>o,LogitsProcessorList:()=>p,LogitsWarper:()=>c,MinLengthLogitsProcessor:()=>b,MinNewTokensLengthLogitsProcessor:()=>k,NoBadWordsLogitsProcessor:()=>L,NoRepeatNGramLogitsProcessor:()=>y,RepetitionPenaltyLogitsProcessor:()=>T,SuppressTokensAtBeginLogitsProcessor:()=>g,TemperatureLogitsWarper:()=>S,TopKLogitsWarper:()=>O,TopPLogitsWarper:()=>I,WhisperTimeStampLogitsProcessor:()=>_});var i=n("./src/utils/generic.js");n("./src/utils/tensor.js");var l=n("./src/utils/maths.js");class o extends i.Callable{_call(E,A){throw Error("`_call` should be implemented in a subclass")}}class c extends i.Callable{_call(E,A){throw Error("`_call` should be implemented in a subclass")}}class p extends i.Callable{constructor(){super(),this.processors=[]}push(E){this.processors.push(E)}extend(E){this.processors.push(...E)}_call(E,A){let F=A;for(const K of this.processors)F=K(E,F);return F}[Symbol.iterator](){return this.processors.values()}}class d extends o{constructor(E){super(),this.bos_token_id=E}_call(E,A){for(let F=0;F<E.length;++F)if(E[F].length===1){const K=A[F].data;K.fill(-1/0),K[this.bos_token_id]=0}return A}}class f extends o{constructor(E,A){super(),this.max_length=E,this.eos_token_id=Array.isArray(A)?A:[A]}_call(E,A){for(let F=0;F<E.length;++F)if(E[F].length===this.max_length-1){const K=A[F].data;K.fill(-1/0);for(const X of this.eos_token_id)K[X]=0}return A}}class g extends o{constructor(E,A){super(),this.begin_suppress_tokens=E,this.begin_index=A}_call(E,A){for(let F=0;F<E.length;++F)if(E[F].length===this.begin_index){const K=A[F].data;for(const X of this.begin_suppress_tokens)K[X]=-1/0}return A}}class _ extends o{constructor(E,A){super(),this.eos_token_id=Array.isArray(E.eos_token_id)?E.eos_token_id[0]:E.eos_token_id,this.no_timestamps_token_id=E.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=A.length,A.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=E.max_initial_timestamp_index}_call(E,A){for(let F=0;F<E.length;++F){const K=A[F].data;if(K[this.no_timestamps_token_id]=-1/0,E[F].length===this.begin_index-1){K.fill(-1/0),K[this.timestamp_begin]=0;continue}const X=E[F].slice(this.begin_index),oe=X.length>=1&&X[X.length-1]>=this.timestamp_begin,ie=X.length<2||X[X.length-2]>=this.timestamp_begin;if(oe&&(ie?K.subarray(this.timestamp_begin).fill(-1/0):K.subarray(0,this.eos_token_id).fill(-1/0)),E[F].length===this.begin_index&&this.max_initial_timestamp_index!==null){const G=this.timestamp_begin+this.max_initial_timestamp_index;K.subarray(G+1).fill(-1/0)}const J=(0,l.log_softmax)(K),ue=Math.log(J.subarray(this.timestamp_begin).map(Math.exp).reduce((G,se)=>G+se)),ne=(0,l.max)(J.subarray(0,this.timestamp_begin))[0];ue>ne&&K.subarray(0,this.timestamp_begin).fill(-1/0)}return A}}class y extends o{constructor(E){super(),this.no_repeat_ngram_size=E}getNgrams(E){const A=E.length,F=[];for(let X=0;X<A+1-this.no_repeat_ngram_size;++X){const oe=[];for(let ie=0;ie<this.no_repeat_ngram_size;++ie)oe.push(E[X+ie]);F.push(oe.map(Number))}const K=new Map;for(const X of F){const oe=X.slice(0,X.length-1),ie=JSON.stringify(oe),J=K.get(ie)??[];J.push(X[X.length-1]),K.set(ie,J)}return K}getGeneratedNgrams(E,A){const F=A.slice(A.length+1-this.no_repeat_ngram_size,A.length);return E.get(JSON.stringify(F.map(Number)))??[]}calcBannedNgramTokens(E){const A=[];if(E.length+1<this.no_repeat_ngram_size)return A;{const F=this.getNgrams(E);return this.getGeneratedNgrams(F,E)}}_call(E,A){for(let F=0;F<E.length;++F){const K=A[F].data,X=this.calcBannedNgramTokens(E[F]);for(const oe of X)K[oe]=-1/0}return A}}class T extends o{constructor(E){super(),this.penalty=E}_call(E,A){for(let F=0;F<E.length;++F){const K=A[F].data;for(const X of new Set(E[F])){const oe=Number(X);K[oe]<0?K[oe]*=this.penalty:K[oe]/=this.penalty}}return A}}class b extends o{constructor(E,A){super(),this.min_length=E,this.eos_token_id=Array.isArray(A)?A:[A]}_call(E,A){for(let F=0;F<E.length;++F)if(E[F].length<this.min_length){const K=A[F].data;for(const X of this.eos_token_id)K[X]=-1/0}return A}}class k extends o{constructor(E,A,F){super(),this.prompt_length_to_skip=E,this.min_new_tokens=A,this.eos_token_id=Array.isArray(F)?F:[F]}_call(E,A){for(let F=0;F<E.length;++F)if(E[F].length-this.prompt_length_to_skip<this.min_new_tokens){const X=A[F].data;for(const oe of this.eos_token_id)X[oe]=-1/0}return A}}class L extends o{constructor(E,A){super(),this.bad_words_ids=E,this.eos_token_id=Array.isArray(A)?A:[A]}_call(E,A){for(let F=0;F<E.length;++F){const K=A[F].data,X=E[F];for(const oe of this.bad_words_ids){let ie=!0;for(let J=1;J<=oe.length-1&&oe.length<X.length;++J)if(oe.at(-J-1)!=X.at(-J)){ie=!1;break}ie&&(K[oe.at(-1)]=-1/0)}}return A}}class C extends o{constructor(E){if(super(),E<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${E}.`);this.guidance_scale=E}_call(E,A){if(A.dims[0]!==2*E.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${A.dims[0]} for the logits and ${E.length} for the input ids.`);const F=E.length,K=A.slice([0,F],null),X=A.slice([F,A.dims[0]],null);for(let oe=0;oe<X.data.length;++oe)X.data[oe]+=(K.data[oe]-X.data[oe])*this.guidance_scale;return X}}class S extends c{constructor(E){super(),this.temperature=E}_call(E,A){const F=A.data;for(let K=0;K<F.length;++K)F[K]/=this.temperature;return A}}class I extends c{constructor(E,{filter_value:A=-1/0,min_tokens_to_keep:F=1}={}){if(super(),E<0||E>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${E}`);if(!Number.isInteger(F)||F<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${F}`);this.top_p=E,this.filter_value=A,this.min_tokens_to_keep=F}}class O extends c{constructor(E,{filter_value:A=-1/0,min_tokens_to_keep:F=1}={}){if(super(),!Number.isInteger(E)||E<0)throw new Error(`\`top_k\` must be a positive integer, but is ${E}`);this.top_k=Math.max(E,F),this.filter_value=A}}},"./src/generation/logits_sampler.js":(t,s,n)=>{n.r(s),n.d(s,{LogitsSampler:()=>c});var i=n("./src/utils/generic.js"),l=n("./src/utils/tensor.js"),o=n("./src/utils/maths.js");n("./src/generation/configuration_utils.js");class c extends i.Callable{constructor(_){super(),this.generation_config=_}async _call(_){return this.sample(_)}async sample(_){throw Error("sample should be implemented in subclasses.")}getLogits(_,y){let T=_.dims.at(-1),b=_.data;if(y===-1)b=b.slice(-T);else{let k=y*T;b=b.slice(k,k+T)}return b}randomSelect(_){let y=0;for(let b=0;b<_.length;++b)y+=_[b];let T=Math.random()*y;for(let b=0;b<_.length;++b)if(T-=_[b],T<=0)return b;return 0}static getSampler(_){if(_.do_sample)return new d(_);if(_.num_beams>1)return new f(_);if(_.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${_.num_return_sequences}.`);return new p(_)}}class p extends c{async sample(_){const y=(0,o.max)(_.data)[1];return[[BigInt(y),0]]}}class d extends c{async sample(_){let y=_.dims.at(-1);this.generation_config.top_k>0&&(y=Math.min(this.generation_config.top_k,y));const[T,b]=await(0,l.topk)(_,y),k=(0,o.softmax)(T.data);return Array.from({length:this.generation_config.num_beams},()=>{const L=this.randomSelect(k);return[b.data[L],Math.log(k[L])]})}}class f extends c{async sample(_){let y=_.dims.at(-1);this.generation_config.top_k>0&&(y=Math.min(this.generation_config.top_k,y));const[T,b]=await(0,l.topk)(_,y),k=(0,o.softmax)(T.data);return Array.from({length:this.generation_config.num_beams},(L,C)=>[b.data[C],Math.log(k[C])])}}},"./src/generation/stopping_criteria.js":(t,s,n)=>{n.r(s),n.d(s,{EosTokenCriteria:()=>p,InterruptableStoppingCriteria:()=>d,MaxLengthCriteria:()=>c,StoppingCriteria:()=>l,StoppingCriteriaList:()=>o});var i=n("./src/utils/generic.js");class l extends i.Callable{_call(g,_){throw Error("StoppingCriteria needs to be subclassed")}}class o extends i.Callable{constructor(){super(),this.criteria=[]}push(g){this.criteria.push(g)}extend(g){g instanceof o?g=g.criteria:g instanceof l&&(g=[g]),this.criteria.push(...g)}_call(g,_){const y=new Array(g.length).fill(!1);for(const T of this.criteria){const b=T(g,_);for(let k=0;k<y.length;++k)y[k]||(y[k]=b[k])}return y}[Symbol.iterator](){return this.criteria.values()}}class c extends l{constructor(g,_=null){super(),this.max_length=g,this.max_position_embeddings=_}_call(g){return g.map(_=>_.length>=this.max_length)}}class p extends l{constructor(g){super(),Array.isArray(g)||(g=[g]),this.eos_token_id=g}_call(g,_){return g.map(y=>{const T=y.at(-1);return this.eos_token_id.some(b=>T==b)})}}class d extends l{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(g,_){return new Array(g.length).fill(this.interrupted)}}},"./src/generation/streamers.js":(t,s,n)=>{n.r(s),n.d(s,{BaseStreamer:()=>c,TextStreamer:()=>d,WhisperTextStreamer:()=>f});var i=n("./src/utils/core.js"),l=n("./src/tokenizers.js"),o=n("./src/env.js");class c{put(_){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const p=o.apis.IS_PROCESS_AVAILABLE?g=>process.stdout.write(g):g=>console.log(g);class d extends c{constructor(_,{skip_prompt:y=!1,callback_function:T=null,token_callback_function:b=null,skip_special_tokens:k=!0,decode_kwargs:L={},...C}={}){super(),this.tokenizer=_,this.skip_prompt=y,this.callback_function=T??p,this.token_callback_function=b,this.decode_kwargs={skip_special_tokens:k,...L,...C},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(_){var L;if(_.length>1)throw Error("TextStreamer only supports batch size of 1");const y=this.next_tokens_are_prompt;if(y&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const T=_[0];(L=this.token_callback_function)==null||L.call(this,T),this.token_cache=(0,i.mergeArrays)(this.token_cache,T);const b=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let k;y||b.endsWith(`
`)?(k=b.slice(this.print_len),this.token_cache=[],this.print_len=0):b.length>0&&(0,l.is_chinese_char)(b.charCodeAt(b.length-1))?(k=b.slice(this.print_len),this.print_len+=k.length):(k=b.slice(this.print_len,b.lastIndexOf(" ")+1),this.print_len+=k.length),this.on_finalized_text(k,!1)}end(){let _;this.token_cache.length>0?(_=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0):_="",this.next_tokens_are_prompt=!0,this.on_finalized_text(_,!0)}on_finalized_text(_,y){var T,b;_.length>0&&((T=this.callback_function)==null||T.call(this,_)),y&&this.callback_function===p&&o.apis.IS_PROCESS_AVAILABLE&&((b=this.callback_function)==null||b.call(this,`
`))}}class f extends d{constructor(_,{skip_prompt:y=!1,callback_function:T=null,token_callback_function:b=null,on_chunk_start:k=null,on_chunk_end:L=null,on_finalize:C=null,time_precision:S=.02,skip_special_tokens:I=!0,decode_kwargs:O={}}={}){super(_,{skip_prompt:y,skip_special_tokens:I,callback_function:T,token_callback_function:b,decode_kwargs:O}),this.timestamp_begin=_.timestamp_begin,this.on_chunk_start=k,this.on_chunk_end=L,this.on_finalize=C,this.time_precision=S,this.waiting_for_timestamp=!1}put(_){var T,b;if(_.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const y=_[0];if(y.length===1){const k=Number(y[0])-this.timestamp_begin;if(k>=0){const L=k*this.time_precision;this.waiting_for_timestamp?(T=this.on_chunk_end)==null||T.call(this,L):(b=this.on_chunk_start)==null||b.call(this,L),this.waiting_for_timestamp=!this.waiting_for_timestamp,_=[[]]}}return super.put(_)}end(){var _;super.end(),(_=this.on_finalize)==null||_.call(this)}}},"./src/models.js":(t,s,n)=>{n.r(s),n.d(s,{ASTForAudioClassification:()=>Ac,ASTModel:()=>Pc,ASTPreTrainedModel:()=>ou,AlbertForMaskedLM:()=>ee,AlbertForQuestionAnswering:()=>N,AlbertForSequenceClassification:()=>Te,AlbertModel:()=>Ci,AlbertPreTrainedModel:()=>Is,AutoModel:()=>Ro,AutoModelForAudioClassification:()=>ip,AutoModelForAudioFrameClassification:()=>oh,AutoModelForAudioTextToText:()=>kd,AutoModelForCTC:()=>ds,AutoModelForCausalLM:()=>Cr,AutoModelForDepthEstimation:()=>Uo,AutoModelForDocumentQuestionAnswering:()=>pi,AutoModelForImageClassification:()=>Cd,AutoModelForImageFeatureExtraction:()=>cp,AutoModelForImageMatting:()=>cc,AutoModelForImageSegmentation:()=>Pd,AutoModelForImageTextToText:()=>Od,AutoModelForImageToImage:()=>$d,AutoModelForMaskGeneration:()=>ap,AutoModelForMaskedLM:()=>fi,AutoModelForNormalEstimation:()=>lp,AutoModelForObjectDetection:()=>Ad,AutoModelForPoseEstimation:()=>up,AutoModelForQuestionAnswering:()=>No,AutoModelForSemanticSegmentation:()=>sp,AutoModelForSeq2SeqLM:()=>Sd,AutoModelForSequenceClassification:()=>ns,AutoModelForSpeechSeq2Seq:()=>lc,AutoModelForTextToSpectrogram:()=>uc,AutoModelForTextToWaveform:()=>di,AutoModelForTokenClassification:()=>Ed,AutoModelForUniversalSegmentation:()=>Vl,AutoModelForVision2Seq:()=>jo,AutoModelForXVector:()=>op,AutoModelForZeroShotObjectDetection:()=>cs,BartForConditionalGeneration:()=>gn,BartForSequenceClassification:()=>en,BartModel:()=>sn,BartPretrainedModel:()=>Zt,BaseModelOutput:()=>Ve,BeitForImageClassification:()=>Au,BeitModel:()=>Ki,BeitPreTrainedModel:()=>bl,BertForMaskedLM:()=>We,BertForQuestionAnswering:()=>ct,BertForSequenceClassification:()=>nt,BertForTokenClassification:()=>at,BertModel:()=>qe,BertPreTrainedModel:()=>Ue,BlenderbotForConditionalGeneration:()=>bn,BlenderbotModel:()=>wn,BlenderbotPreTrainedModel:()=>bs,BlenderbotSmallForConditionalGeneration:()=>zs,BlenderbotSmallModel:()=>Zr,BlenderbotSmallPreTrainedModel:()=>ur,BloomForCausalLM:()=>zn,BloomModel:()=>Mr,BloomPreTrainedModel:()=>Ui,CLIPModel:()=>gu,CLIPPreTrainedModel:()=>Ts,CLIPSegForImageSegmentation:()=>nl,CLIPSegModel:()=>Ka,CLIPSegPreTrainedModel:()=>Xs,CLIPTextModel:()=>zc,CLIPTextModelWithProjection:()=>yu,CLIPVisionModel:()=>Fc,CLIPVisionModelWithProjection:()=>po,CamembertForMaskedLM:()=>Hs,CamembertForQuestionAnswering:()=>Nn,CamembertForSequenceClassification:()=>ya,CamembertForTokenClassification:()=>Pr,CamembertModel:()=>Ms,CamembertPreTrainedModel:()=>Kr,CausalLMOutput:()=>La,CausalLMOutputWithPast:()=>uh,ChineseCLIPModel:()=>Mu,ChineseCLIPPreTrainedModel:()=>Rc,ClapAudioModelWithProjection:()=>Zp,ClapModel:()=>Df,ClapPreTrainedModel:()=>Il,ClapTextModelWithProjection:()=>If,CodeGenForCausalLM:()=>Or,CodeGenModel:()=>Qa,CodeGenPreTrainedModel:()=>Ys,CohereForCausalLM:()=>pl,CohereModel:()=>xa,CoherePreTrainedModel:()=>Li,ConvBertForMaskedLM:()=>hn,ConvBertForQuestionAnswering:()=>ga,ConvBertForSequenceClassification:()=>Kn,ConvBertForTokenClassification:()=>Ws,ConvBertModel:()=>Dn,ConvBertPreTrainedModel:()=>Ft,ConvNextForImageClassification:()=>Hp,ConvNextModel:()=>tf,ConvNextPreTrainedModel:()=>Lu,ConvNextV2ForImageClassification:()=>rf,ConvNextV2Model:()=>nf,ConvNextV2PreTrainedModel:()=>Zc,DPTForDepthEstimation:()=>Qd,DPTModel:()=>qd,DPTPreTrainedModel:()=>Du,DacDecoderModel:()=>Ia,DacDecoderOutput:()=>Zf,DacEncoderModel:()=>ts,DacEncoderOutput:()=>Yf,DacModel:()=>Rn,DacPreTrainedModel:()=>yd,DebertaForMaskedLM:()=>yt,DebertaForQuestionAnswering:()=>_n,DebertaForSequenceClassification:()=>Et,DebertaForTokenClassification:()=>Qn,DebertaModel:()=>st,DebertaPreTrainedModel:()=>mn,DebertaV2ForMaskedLM:()=>Fr,DebertaV2ForQuestionAnswering:()=>Lr,DebertaV2ForSequenceClassification:()=>rr,DebertaV2ForTokenClassification:()=>qr,DebertaV2Model:()=>vs,DebertaV2PreTrainedModel:()=>mr,DecisionTransformerModel:()=>nh,DecisionTransformerPreTrainedModel:()=>th,DeiTForImageClassification:()=>je,DeiTModel:()=>$e,DeiTPreTrainedModel:()=>me,DepthAnythingForDepthEstimation:()=>Hc,DepthAnythingPreTrainedModel:()=>Wp,DepthProForDepthEstimation:()=>Pl,DepthProPreTrainedModel:()=>qc,DetrForObjectDetection:()=>$u,DetrForSegmentation:()=>qi,DetrModel:()=>Tl,DetrObjectDetectionOutput:()=>xl,DetrPreTrainedModel:()=>ni,DetrSegmentationOutput:()=>Qi,Dinov2ForImageClassification:()=>af,Dinov2Model:()=>sf,Dinov2PreTrainedModel:()=>Bu,Dinov2WithRegistersForImageClassification:()=>lf,Dinov2WithRegistersModel:()=>of,Dinov2WithRegistersPreTrainedModel:()=>Jc,DistilBertForMaskedLM:()=>Ei,DistilBertForQuestionAnswering:()=>ws,DistilBertForSequenceClassification:()=>Ua,DistilBertForTokenClassification:()=>as,DistilBertModel:()=>Ks,DistilBertPreTrainedModel:()=>Pn,DonutSwinModel:()=>ef,DonutSwinPreTrainedModel:()=>Jd,EfficientNetForImageClassification:()=>Nf,EfficientNetModel:()=>Rf,EfficientNetPreTrainedModel:()=>Qu,ElectraForMaskedLM:()=>_s,ElectraForQuestionAnswering:()=>ys,ElectraForSequenceClassification:()=>gs,ElectraForTokenClassification:()=>Pt,ElectraModel:()=>ms,ElectraPreTrainedModel:()=>Hr,EsmForMaskedLM:()=>Si,EsmForSequenceClassification:()=>qs,EsmForTokenClassification:()=>Ar,EsmModel:()=>Va,EsmPreTrainedModel:()=>Ds,ExaoneForCausalLM:()=>It,ExaoneModel:()=>xu,ExaonePreTrainedModel:()=>Ta,FalconForCausalLM:()=>kf,FalconModel:()=>Ku,FalconPreTrainedModel:()=>ud,FastViTForImageClassification:()=>Uc,FastViTModel:()=>jc,FastViTPreTrainedModel:()=>Cu,Florence2ForConditionalGeneration:()=>pu,Florence2PreTrainedModel:()=>Dc,GLPNForDepthEstimation:()=>Zd,GLPNModel:()=>Yd,GLPNPreTrainedModel:()=>Yc,GPT2LMHeadModel:()=>go,GPT2Model:()=>rl,GPT2PreTrainedModel:()=>_o,GPTBigCodeForCausalLM:()=>Tu,GPTBigCodeModel:()=>ul,GPTBigCodePreTrainedModel:()=>Je,GPTJForCausalLM:()=>ki,GPTJModel:()=>ll,GPTJPreTrainedModel:()=>ol,GPTNeoForCausalLM:()=>bu,GPTNeoModel:()=>wu,GPTNeoPreTrainedModel:()=>al,GPTNeoXForCausalLM:()=>qa,GPTNeoXModel:()=>Rr,GPTNeoXPreTrainedModel:()=>il,Gemma2ForCausalLM:()=>xs,Gemma2Model:()=>bo,Gemma2PreTrainedModel:()=>Sr,Gemma3ForCausalLM:()=>ta,Gemma3Model:()=>Bi,Gemma3PreTrainedModel:()=>To,GemmaForCausalLM:()=>Eu,GemmaModel:()=>Ea,GemmaPreTrainedModel:()=>Xa,GlmForCausalLM:()=>Lt,GlmModel:()=>cl,GlmPreTrainedModel:()=>Ls,GraniteForCausalLM:()=>Fi,GraniteModel:()=>zi,GranitePreTrainedModel:()=>Ii,GroundingDinoForObjectDetection:()=>uf,GroundingDinoPreTrainedModel:()=>Kp,GroupViTModel:()=>Su,GroupViTPreTrainedModel:()=>Ao,HeliumForCausalLM:()=>vo,HeliumModel:()=>Mo,HeliumPreTrainedModel:()=>Js,HieraForImageClassification:()=>pt,HieraModel:()=>Xe,HieraPreTrainedModel:()=>Ye,HubertForCTC:()=>Gu,HubertForSequenceClassification:()=>kl,HubertModel:()=>Ol,HubertPreTrainedModel:()=>$l,IJepaForImageClassification:()=>Po,IJepaModel:()=>Ja,IJepaPreTrainedModel:()=>Co,Idefics3ForConditionalGeneration:()=>el,Idefics3PreTrainedModel:()=>Ic,ImageMattingOutput:()=>dp,JAISLMHeadModel:()=>vu,JAISModel:()=>sl,JAISPreTrainedModel:()=>Oi,JinaCLIPModel:()=>Ai,JinaCLIPPreTrainedModel:()=>mo,JinaCLIPTextModel:()=>$i,JinaCLIPVisionModel:()=>Nc,LiteWhisperForConditionalGeneration:()=>$c,LlamaForCausalLM:()=>Zs,LlamaModel:()=>yo,LlamaPreTrainedModel:()=>ba,LlavaForConditionalGeneration:()=>Jo,LlavaOnevisionForConditionalGeneration:()=>fu,LlavaPreTrainedModel:()=>Oc,LongT5ForConditionalGeneration:()=>ht,LongT5Model:()=>lt,LongT5PreTrainedModel:()=>Ge,M2M100ForConditionalGeneration:()=>mf,M2M100Model:()=>nd,M2M100PreTrainedModel:()=>td,MBartForCausalLM:()=>Bn,MBartForConditionalGeneration:()=>yr,MBartForSequenceClassification:()=>Br,MBartModel:()=>gr,MBartPreTrainedModel:()=>$n,MPNetForMaskedLM:()=>Qr,MPNetForQuestionAnswering:()=>Xr,MPNetForSequenceClassification:()=>xr,MPNetForTokenClassification:()=>va,MPNetModel:()=>uo,MPNetPreTrainedModel:()=>os,MT5ForConditionalGeneration:()=>kt,MT5Model:()=>Mt,MT5PreTrainedModel:()=>ft,MarianMTModel:()=>hf,MarianModel:()=>pf,MarianPreTrainedModel:()=>ed,MaskFormerForInstanceSegmentation:()=>Xd,MaskFormerModel:()=>Xc,MaskFormerPreTrainedModel:()=>Fu,MaskedLMOutput:()=>br,Metric3DForDepthEstimation:()=>Qc,Metric3DPreTrainedModel:()=>Iu,Metric3Dv2ForDepthEstimation:()=>zu,Metric3Dv2PreTrainedModel:()=>Aa,MgpstrForSceneTextRecognition:()=>Kf,MgpstrModelOutput:()=>oi,MgpstrPreTrainedModel:()=>Hf,MimiDecoderModel:()=>wr,MimiDecoderOutput:()=>Jn,MimiEncoderModel:()=>Xf,MimiEncoderOutput:()=>Da,MimiModel:()=>gd,MimiPreTrainedModel:()=>sc,MistralForCausalLM:()=>eo,MistralModel:()=>Af,MistralPreTrainedModel:()=>ld,MobileBertForMaskedLM:()=>Ma,MobileBertForQuestionAnswering:()=>$r,MobileBertForSequenceClassification:()=>is,MobileBertModel:()=>_r,MobileBertPreTrainedModel:()=>Tr,MobileLLMForCausalLM:()=>dl,MobileLLMModel:()=>zt,MobileLLMPreTrainedModel:()=>wo,MobileNetV1ForImageClassification:()=>Zu,MobileNetV1ForSemanticSegmentation:()=>pd,MobileNetV1Model:()=>fd,MobileNetV1PreTrainedModel:()=>Yu,MobileNetV2ForImageClassification:()=>Vf,MobileNetV2ForSemanticSegmentation:()=>Oa,MobileNetV2Model:()=>hd,MobileNetV2PreTrainedModel:()=>Ju,MobileNetV3ForImageClassification:()=>Gf,MobileNetV3ForSemanticSegmentation:()=>ka,MobileNetV3Model:()=>eh,MobileNetV3PreTrainedModel:()=>zl,MobileNetV4ForImageClassification:()=>Fl,MobileNetV4ForSemanticSegmentation:()=>Un,MobileNetV4Model:()=>tc,MobileNetV4PreTrainedModel:()=>ec,MobileViTForImageClassification:()=>Ml,MobileViTModel:()=>Hi,MobileViTPreTrainedModel:()=>ei,MobileViTV2ForImageClassification:()=>Vc,MobileViTV2Model:()=>ti,MobileViTV2PreTrainedModel:()=>Pa,ModelOutput:()=>Ee,ModernBertForMaskedLM:()=>q,ModernBertForSequenceClassification:()=>pe,ModernBertForTokenClassification:()=>we,ModernBertModel:()=>fe,ModernBertPreTrainedModel:()=>V,Moondream1ForConditionalGeneration:()=>kc,MoonshineForConditionalGeneration:()=>Zo,MoonshineModel:()=>Hd,MoonshinePreTrainedModel:()=>cu,MptForCausalLM:()=>ls,MptModel:()=>ra,MptPreTrainedModel:()=>an,MultiModalityCausalLM:()=>Ll,MultiModalityPreTrainedModel:()=>Wf,MusicgenForCausalLM:()=>Uf,MusicgenForConditionalGeneration:()=>Xu,MusicgenModel:()=>jf,MusicgenPreTrainedModel:()=>dd,NomicBertModel:()=>De,NomicBertPreTrainedModel:()=>Fe,OPTForCausalLM:()=>ml,OPTModel:()=>sa,OPTPreTrainedModel:()=>Vi,Olmo2ForCausalLM:()=>ea,Olmo2Model:()=>Nr,Olmo2PreTrainedModel:()=>kr,OlmoForCausalLM:()=>fl,OlmoModel:()=>Jr,OlmoPreTrainedModel:()=>Di,OpenELMForCausalLM:()=>Sa,OpenELMModel:()=>xo,OpenELMPreTrainedModel:()=>Ri,OwlViTForObjectDetection:()=>Pu,OwlViTModel:()=>Gc,OwlViTPreTrainedModel:()=>vl,Owlv2ForObjectDetection:()=>$o,Owlv2Model:()=>wl,Owlv2PreTrainedModel:()=>ia,PaliGemmaForConditionalGeneration:()=>mu,PaliGemmaPreTrainedModel:()=>hu,PatchTSMixerForPrediction:()=>md,PatchTSMixerModel:()=>Qf,PatchTSMixerPreTrainedModel:()=>nc,PatchTSTForPrediction:()=>qf,PatchTSTModel:()=>da,PatchTSTPreTrainedModel:()=>Lo,Phi3ForCausalLM:()=>Eo,Phi3Model:()=>hl,Phi3PreTrainedModel:()=>Rs,Phi3VForCausalLM:()=>Qs,Phi3VPreTrainedModel:()=>_u,PhiForCausalLM:()=>Ss,PhiModel:()=>Es,PhiPreTrainedModel:()=>Bs,PreTrainedModel:()=>Z,PretrainedMixin:()=>Gt,PvtForImageClassification:()=>_l,PvtModel:()=>js,PvtPreTrainedModel:()=>Ns,PyAnnoteForAudioFrameClassification:()=>Mf,PyAnnoteModel:()=>yf,PyAnnotePreTrainedModel:()=>ju,QuestionAnsweringModelOutput:()=>ir,Qwen2ForCausalLM:()=>ji,Qwen2Model:()=>Ni,Qwen2PreTrainedModel:()=>na,Qwen2VLForConditionalGeneration:()=>Ur,Qwen2VLPreTrainedModel:()=>jr,RFDetrForObjectDetection:()=>h,RFDetrModel:()=>Do,RFDetrObjectDetectionOutput:()=>M,RFDetrPreTrainedModel:()=>ko,RTDetrForObjectDetection:()=>oa,RTDetrModel:()=>Ou,RTDetrObjectDetectionOutput:()=>Xi,RTDetrPreTrainedModel:()=>El,RTDetrV2ForObjectDetection:()=>ua,RTDetrV2Model:()=>la,RTDetrV2ObjectDetectionOutput:()=>Yi,RTDetrV2PreTrainedModel:()=>Oo,ResNetForImageClassification:()=>cr,ResNetModel:()=>fn,ResNetPreTrainedModel:()=>vt,RoFormerForMaskedLM:()=>it,RoFormerForQuestionAnswering:()=>Ot,RoFormerForSequenceClassification:()=>mt,RoFormerForTokenClassification:()=>_t,RoFormerModel:()=>He,RoFormerPreTrainedModel:()=>rt,RobertaForMaskedLM:()=>Tn,RobertaForQuestionAnswering:()=>In,RobertaForSequenceClassification:()=>nn,RobertaForTokenClassification:()=>yn,RobertaModel:()=>Xn,RobertaPreTrainedModel:()=>On,SamImageSegmentationOutput:()=>ff,SamModel:()=>df,SamPreTrainedModel:()=>Al,SapiensForDepthEstimation:()=>es,SapiensForNormalEstimation:()=>ar,SapiensForSemanticSegmentation:()=>Kc,SapiensPreTrainedModel:()=>Cl,SegformerForImageClassification:()=>Ff,SegformerForSemanticSegmentation:()=>Lf,SegformerModel:()=>Jp,SegformerPreTrainedModel:()=>pr,Seq2SeqLMOutput:()=>Xh,SequenceClassifierOutput:()=>Vt,SiglipModel:()=>Ha,SiglipPreTrainedModel:()=>ho,SiglipTextModel:()=>Lc,SiglipVisionModel:()=>Bc,SmolVLMForConditionalGeneration:()=>tl,SnacDecoderModel:()=>Md,SnacEncoderModel:()=>rh,SnacModel:()=>Jf,SnacPreTrainedModel:()=>ac,SpeechT5ForSpeechToText:()=>$a,SpeechT5ForTextToSpeech:()=>dr,SpeechT5HifiGan:()=>Hu,SpeechT5Model:()=>Ji,SpeechT5PreTrainedModel:()=>Wu,SqueezeBertForMaskedLM:()=>sr,SqueezeBertForQuestionAnswering:()=>Er,SqueezeBertForSequenceClassification:()=>Ga,SqueezeBertModel:()=>lr,SqueezeBertPreTrainedModel:()=>Yr,StableLmForCausalLM:()=>qu,StableLmModel:()=>Bf,StableLmPreTrainedModel:()=>cd,Starcoder2ForCausalLM:()=>Of,Starcoder2Model:()=>$f,Starcoder2PreTrainedModel:()=>Dl,StyleTextToSpeech2Model:()=>ii,StyleTextToSpeech2PreTrainedModel:()=>ca,Swin2SRForImageSuperResolution:()=>Wc,Swin2SRModel:()=>Zn,Swin2SRPreTrainedModel:()=>Kd,SwinForImageClassification:()=>Sl,SwinForSemanticSegmentation:()=>Io,SwinModel:()=>ku,SwinPreTrainedModel:()=>Vr,T5ForConditionalGeneration:()=>xe,T5Model:()=>Me,T5PreTrainedModel:()=>de,TableTransformerForObjectDetection:()=>R,TableTransformerModel:()=>D,TableTransformerObjectDetectionOutput:()=>te,TableTransformerPreTrainedModel:()=>$,TokenClassifierOutput:()=>hr,TrOCRForCausalLM:()=>od,TrOCRPreTrainedModel:()=>id,UltravoxModel:()=>rc,UltravoxPreTrainedModel:()=>_d,UniSpeechForCTC:()=>Xp,UniSpeechForSequenceClassification:()=>wf,UniSpeechModel:()=>Qp,UniSpeechPreTrainedModel:()=>Uu,UniSpeechSatForAudioFrameClassification:()=>Tf,UniSpeechSatForCTC:()=>Vu,UniSpeechSatForSequenceClassification:()=>bf,UniSpeechSatModel:()=>ad,UniSpeechSatPreTrainedModel:()=>si,ViTForImageClassification:()=>Za,ViTMAEModel:()=>Gi,ViTMAEPreTrainedModel:()=>gl,ViTMSNForImageClassification:()=>vr,ViTMSNModel:()=>Ca,ViTMSNPreTrainedModel:()=>Wi,ViTModel:()=>Ya,ViTPreTrainedModel:()=>So,VisionEncoderDecoderModel:()=>du,VitMatteForImageMatting:()=>yl,VitMattePreTrainedModel:()=>Yn,VitPoseForPoseEstimation:()=>Cs,VitPosePreTrainedModel:()=>aa,VitsModel:()=>fr,VitsModelOutput:()=>fp,VitsPreTrainedModel:()=>zf,Wav2Vec2BertForCTC:()=>Ef,Wav2Vec2BertForSequenceClassification:()=>Yp,Wav2Vec2BertModel:()=>xf,Wav2Vec2BertPreTrainedModel:()=>zo,Wav2Vec2ForAudioFrameClassification:()=>qp,Wav2Vec2ForCTC:()=>_f,Wav2Vec2ForSequenceClassification:()=>gf,Wav2Vec2Model:()=>rd,Wav2Vec2PreTrainedModel:()=>ri,WavLMForAudioFrameClassification:()=>Ps,WavLMForCTC:()=>Cf,WavLMForSequenceClassification:()=>Fo,WavLMForXVector:()=>Pf,WavLMModel:()=>Sf,WavLMPreTrainedModel:()=>ai,WeSpeakerResNetModel:()=>vf,WeSpeakerResNetPreTrainedModel:()=>sd,WhisperForConditionalGeneration:()=>uu,WhisperModel:()=>lu,WhisperPreTrainedModel:()=>Yo,XLMForQuestionAnswering:()=>co,XLMForSequenceClassification:()=>Qo,XLMForTokenClassification:()=>Wa,XLMModel:()=>Pi,XLMPreTrainedModel:()=>jn,XLMRobertaForMaskedLM:()=>Cc,XLMRobertaForQuestionAnswering:()=>iu,XLMRobertaForSequenceClassification:()=>fo,XLMRobertaForTokenClassification:()=>Xo,XLMRobertaModel:()=>Sc,XLMRobertaPreTrainedModel:()=>Fs,XLMWithLMHeadModel:()=>wa,XVectorOutput:()=>lh,YolosForObjectDetection:()=>cf,YolosModel:()=>Ru,YolosObjectDetectionOutput:()=>Nu,YolosPreTrainedModel:()=>Zi});var i=n("./src/configs.js"),l=n("./src/backends/onnx.js"),o=n("./src/utils/dtypes.js"),c=n("./src/utils/generic.js"),p=n("./src/utils/core.js"),d=n("./src/utils/hub.js"),f=n("./src/utils/constants.js"),g=n("./src/generation/logits_process.js"),_=n("./src/generation/configuration_utils.js"),y=n("./src/utils/tensor.js"),T=n("./src/utils/image.js"),b=n("./src/utils/maths.js"),k=n("./src/generation/stopping_criteria.js"),L=n("./src/generation/logits_sampler.js"),C=n("./src/env.js"),S=n("./src/models/whisper/generation_whisper.js"),I=n("./src/models/whisper/common_whisper.js");const O={EncoderOnly:0,EncoderDecoder:1,Seq2Seq:2,Vision2Seq:3,DecoderOnly:4,MaskGeneration:5,ImageTextToText:6,Musicgen:7,MultiModality:8,Phi3V:9,AudioTextToText:10,AutoEncoder:11},x=new Map,E=new Map,A=new Map;async function F(P,z,H){var er;const ye=((er=H.config)==null?void 0:er["transformers.js_config"])??{};let Ae=H.device??ye.device;Ae&&typeof Ae!="string"&&(Ae.hasOwnProperty(z)?Ae=Ae[z]:(console.warn(`device not specified for "${z}". Using the default device.`),Ae=null));const Pe=Ae??(C.apis.IS_NODE_ENV?"cpu":"wasm"),ze=(0,l.deviceToExecutionProviders)(Pe);let et=H.dtype??ye.dtype;if(typeof et!="string"&&(et&&et.hasOwnProperty(z)?et=et[z]:(et=o.DEFAULT_DEVICE_DTYPE_MAPPING[Pe]??o.DATA_TYPES.fp32,console.warn(`dtype not specified for "${z}". Using the default dtype (${et}) for this device (${Pe}).`))),et===o.DATA_TYPES.auto){let Qt=ye.dtype;typeof Qt!="string"&&(Qt=Qt[z]),Qt&&Qt!==o.DATA_TYPES.auto&&o.DATA_TYPES.hasOwnProperty(Qt)?et=Qt:et=o.DEFAULT_DEVICE_DTYPE_MAPPING[Pe]??o.DATA_TYPES.fp32}const dt=et;if(o.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(dt)){if(dt===o.DATA_TYPES.fp16&&Pe==="webgpu"&&!await(0,o.isWebGpuFp16Supported)())throw new Error(`The device (${Pe}) does not support fp16.`)}else throw new Error(`Invalid dtype: ${dt}. Should be one of: ${Object.keys(o.DATA_TYPES).join(", ")}`);const gt=ye.kv_cache_dtype?typeof ye.kv_cache_dtype=="string"?ye.kv_cache_dtype:ye.kv_cache_dtype[dt]??"float32":void 0;if(gt&&!["float32","float16"].includes(gt))throw new Error(`Invalid kv_cache_dtype: ${gt}. Should be one of: float32, float16`);const At={dtype:dt,kv_cache_dtype:gt},Nt=o.DEFAULT_DTYPE_SUFFIX_MAPPING[dt],bt=`${z}${Nt}.onnx`,Wt=`${H.subfolder??""}/${bt}`,wt={...H.session_options};wt.executionProviders??(wt.executionProviders=ze);const jt=ye.free_dimension_overrides;jt?wt.freeDimensionOverrides??(wt.freeDimensionOverrides=jt):Pe.startsWith("webnn")&&!wt.freeDimensionOverrides&&console.warn('WebNN does not currently support dynamic shapes and requires `free_dimension_overrides` to be set in config.json as a field within "transformers.js_config". When `free_dimension_overrides` is not set, you may experience significant performance degradation.');const $t=(0,d.getModelFile)(P,Wt,!0,H,C.apis.IS_NODE_ENV),Ht=H.use_external_data_format??ye.use_external_data_format;let rn=[];if(Ht){let Qt;typeof Ht=="object"?Ht.hasOwnProperty(bt)?Qt=Ht[bt]:Ht.hasOwnProperty(z)?Qt=Ht[z]:Qt=!1:Qt=Ht;const Sn=+Qt;if(Sn>d.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${Sn}) exceeds the maximum allowed value (${d.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let Vn=0;Vn<Sn;++Vn){const tr=`${bt}_data${Vn===0?"":"_"+Vn}`,fs=`${H.subfolder??""}/${tr}`;rn.push(new Promise(async(so,Gl)=>{const Dr=await(0,d.getModelFile)(P,fs,!0,H,C.apis.IS_NODE_ENV);so(Dr instanceof Uint8Array?{path:tr,data:Dr}:tr)}))}}else wt.externalData!==void 0&&(rn=wt.externalData.map(async Qt=>{if(typeof Qt.data=="string"){const Sn=await(0,d.getModelFile)(P,Qt.data,!0,H);return{...Qt,data:Sn}}return Qt}));if(rn.length>0){const Qt=await Promise.all(rn);C.apis.IS_NODE_ENV||(wt.externalData=Qt)}if(Pe==="webgpu"){const Qt=(0,i.getKeyValueShapes)(H.config,{prefix:"present"});if(Object.keys(Qt).length>0&&!(0,l.isONNXProxy)()){const Sn={};for(const Vn in Qt)Sn[Vn]="gpu-buffer";wt.preferredOutputLocation=Sn}}return{buffer_or_path:await $t,session_options:wt,session_config:At}}async function K(P,z,H){return Object.fromEntries(await Promise.all(Object.keys(z).map(async ye=>{const{buffer_or_path:Ae,session_options:Pe,session_config:ze}=await F(P,z[ye],H),et=await(0,l.createInferenceSession)(Ae,Pe,ze);return[ye,et]})))}async function X(P,z,H){return Object.fromEntries(await Promise.all(Object.keys(z).map(async ye=>{const Ae=await(0,d.getModelJSON)(P,z[ye],!1,H);return[ye,Ae]})))}function oe(P,z){const H=Object.create(null),ye=[];for(const ze of P.inputNames){const et=z[ze];if(!(et instanceof y.Tensor)){ye.push(ze);continue}H[ze]=(0,l.isONNXProxy)()?et.clone():et}if(ye.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${ye.join(", ")}.`);const Ae=Object.keys(z).length,Pe=P.inputNames.length;if(Ae>Pe){let ze=Object.keys(z).filter(et=>!P.inputNames.includes(et));console.warn(`WARNING: Too many inputs were provided (${Ae} > ${Pe}). The following inputs will be ignored: "${ze.join(", ")}".`)}return H}async function ie(P,z){const H=oe(P,z);try{const ye=Object.fromEntries(Object.entries(H).map(([Pe,ze])=>[Pe,ze.ort_tensor]));let Ae=await P.run(ye);return Ae=J(Ae),Ae}catch(ye){const Ae=Object.fromEntries(Object.entries(H).map(([Pe,{type:ze,dims:et,data:dt}])=>[Pe,{type:ze,dims:et,data:dt}]));throw console.error(`An error occurred during model execution: "${ye}".`),console.error("Inputs given to model:",Ae),ye}}function J(P){for(let z in P)(0,l.isONNXTensor)(P[z])?P[z]=new y.Tensor(P[z]):typeof P[z]=="object"&&J(P[z]);return P}function ue(P){if(P instanceof y.Tensor)return P;if(P.length===0)throw Error("items must be non-empty");if(Array.isArray(P[0])){if(P.some(z=>z.length!==P[0].length))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new y.Tensor("int64",BigInt64Array.from(P.flat().map(z=>BigInt(z))),[P.length,P[0].length])}else return new y.Tensor("int64",BigInt64Array.from(P.map(z=>BigInt(z))),[1,P.length])}function ne(P){return new y.Tensor("bool",[P],[1])}async function G(P,z){let{encoder_outputs:H,input_ids:ye,decoder_input_ids:Ae,...Pe}=z;if(!H){const et=(0,p.pick)(z,P.sessions.model.inputNames);H=(await se(P,et)).last_hidden_state}return Pe.input_ids=Ae,Pe.encoder_hidden_states=H,P.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(Pe.encoder_attention_mask=z.attention_mask),await ge(P,Pe,!0)}async function se(P,z){const H=P.sessions.model,ye=(0,p.pick)(z,H.inputNames);if(H.inputNames.includes("inputs_embeds")&&!ye.inputs_embeds){if(!z.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");ye.inputs_embeds=await P.encode_text({input_ids:z.input_ids})}if(H.inputNames.includes("token_type_ids")&&!ye.token_type_ids){if(!ye.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");ye.token_type_ids=(0,y.zeros_like)(ye.input_ids)}if(H.inputNames.includes("pixel_mask")&&!ye.pixel_mask){if(!ye.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const Ae=ye.pixel_values.dims;ye.pixel_mask=(0,y.ones)([Ae[0],Ae[2],Ae[3]])}return await ie(H,ye)}async function ce(P,z){const H=await P.encode(z);return await P.decode(H)}async function ge(P,z,H=!1){const ye=P.sessions[H?"decoder_model_merged":"model"],{past_key_values:Ae,...Pe}=z;if(ye.inputNames.includes("use_cache_branch")&&(Pe.use_cache_branch=ne(!!Ae)),ye.inputNames.includes("position_ids")&&Pe.attention_mask&&!Pe.position_ids){const et=["paligemma","gemma3_text","gemma3"].includes(P.config.model_type)?1:0;Pe.position_ids=Se(Pe,Ae,et)}P.addPastKeyValues(Pe,Ae);const ze=(0,p.pick)(Pe,ye.inputNames);return await ie(ye,ze)}function W({modality_token_id:P,inputs_embeds:z,modality_features:H,input_ids:ye,attention_mask:Ae}){const Pe=ye.tolist().map(gt=>gt.reduce((At,Nt,bt)=>(Nt==P&&At.push(bt),At),[])),ze=Pe.reduce((gt,At)=>gt+At.length,0),et=H.dims[0];if(ze!==et)throw new Error(`Number of tokens and features do not match: tokens: ${ze}, features ${et}`);let dt=0;for(let gt=0;gt<Pe.length;++gt){const At=Pe[gt],Nt=z[gt];for(let bt=0;bt<At.length;++bt)Nt[At[bt]].data.set(H[dt++].data)}return{inputs_embeds:z,attention_mask:Ae}}function U({image_token_id:P,inputs_embeds:z,image_features:H,input_ids:ye,attention_mask:Ae}){return W({modality_token_id:P,inputs_embeds:z,modality_features:H,input_ids:ye,attention_mask:Ae})}function B({audio_token_id:P,inputs_embeds:z,audio_features:H,input_ids:ye,attention_mask:Ae}){return W({modality_token_id:P,inputs_embeds:z,modality_features:H,input_ids:ye,attention_mask:Ae})}async function Q(P,{encode_function:z,merge_function:H,modality_input_name:ye,modality_output_name:Ae,input_ids:Pe=null,attention_mask:ze=null,position_ids:et=null,inputs_embeds:dt=null,past_key_values:gt=null,generation_config:At=null,logits_processor:Nt=null,...bt}){const Wt=bt[ye];if(!dt){if(dt=await P.encode_text({input_ids:Pe,...bt}),Wt&&Pe.dims[1]!==1){const jt=await z({[ye]:Wt,...bt});({inputs_embeds:dt,attention_mask:ze}=H({[Ae]:jt,inputs_embeds:dt,input_ids:Pe,attention_mask:ze}))}else if(gt&&Wt&&Pe.dims[1]===1){const jt=Pe.dims[1],$t=Object.values(gt)[0].dims.at(-2);ze=(0,y.cat)([(0,y.ones)([Pe.dims[0],$t]),ze.slice(null,[ze.dims[1]-jt,ze.dims[1]])],1)}}if(!et&&P.config.model_type==="qwen2_vl"){const{image_grid_thw:jt,video_grid_thw:$t}=bt;[et]=P.get_rope_index(Pe,jt,$t,ze)}return await ge(P,{inputs_embeds:dt,past_key_values:gt,attention_mask:ze,position_ids:et,generation_config:At,logits_processor:Nt},!0)}async function le(P,z){return await Q(P,{...z,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:P.encode_audio.bind(P),merge_function:P._merge_input_ids_with_audio_features.bind(P)})}async function re(P,z){return await Q(P,{...z,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:P.encode_image.bind(P),merge_function:P._merge_input_ids_with_image_features.bind(P)})}function ve(P,z=0){const[H,ye]=P.dims,Ae=P.data,Pe=new BigInt64Array(Ae.length);for(let ze=0;ze<H;++ze){const et=ze*ye;let dt=BigInt(z);for(let gt=0;gt<ye;++gt){const At=et+gt;Ae[At]===0n?Pe[At]=BigInt(1):(Pe[At]=dt,dt+=Ae[At])}}return{data:Pe,dims:P.dims}}function Se(P,z=null,H=0){const{input_ids:ye,inputs_embeds:Ae,attention_mask:Pe}=P,{data:ze,dims:et}=ve(Pe,H);let dt=new y.Tensor("int64",ze,et);if(z){const gt=-(ye??Ae).dims.at(1);dt=dt.slice(null,[gt,null])}return dt}function Be(P,z,H,ye){if(H.past_key_values){const Ae=Object.values(H.past_key_values)[0].dims.at(-2),{input_ids:Pe,attention_mask:ze}=H;if(!(ze&&ze.dims[1]>Pe.dims[1])){if(Ae<Pe.dims[1])H.input_ids=Pe.slice(null,[Ae,null]);else if(P.config.image_token_index!=null&&Pe.data.some(et=>et==P.config.image_token_index)){const et=P.config.num_image_tokens;if(!et)throw new Error("`num_image_tokens` is missing in the model configuration.");const dt=Pe.dims[1]-(Ae-et);H.input_ids=Pe.slice(null,[-dt,null]),H.attention_mask=(0,y.ones)([1,Ae+dt])}}}return H}function ut(P,z,H,ye){return H.past_key_values&&(z=z.map(Ae=>[Ae.at(-1)])),{...H,decoder_input_ids:ue(z)}}function Oe(P,...z){return P.config.is_encoder_decoder?ut(P,...z):Be(P,...z)}function ae(P,z,H,ye){const Ae=!!H.past_key_values;return ye.guidance_scale!==null&&ye.guidance_scale>1&&(Ae?H.input_ids=(0,y.cat)([H.input_ids,H.input_ids],0):(H.input_ids=(0,y.cat)([H.input_ids,(0,y.full_like)(H.input_ids,BigInt(ye.pad_token_id))],0),H.attention_mask=(0,y.cat)([H.attention_mask,(0,y.full_like)(H.attention_mask,0n)],0))),(Ae||!H.pixel_values)&&(H.pixel_values=(0,y.full)([0,0,3,384,384],1)),Ae&&(H.images_seq_mask=new y.Tensor("bool",new Array(1).fill(!0).fill(!1,0,1),[1,1]),H.images_emb_mask=new y.Tensor("bool",new Array(0).fill(!1),[1,1,0])),H}class Z extends c.Callable{constructor(H,ye,Ae){super();he(this,"main_input_name","input_ids");he(this,"forward_params",["input_ids","attention_mask"]);this.config=H,this.sessions=ye,this.configs=Ae;const Pe=A.get(this.constructor),ze=x.get(Pe);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,ze){case O.DecoderOnly:this.can_generate=!0,this._forward=ge,this._prepare_inputs_for_generation=Be;break;case O.Seq2Seq:case O.Vision2Seq:case O.Musicgen:this.can_generate=!0,this._forward=G,this._prepare_inputs_for_generation=ut;break;case O.EncoderDecoder:this._forward=G;break;case O.ImageTextToText:this.can_generate=!0,this._forward=re,this._prepare_inputs_for_generation=Oe;break;case O.AudioTextToText:this.can_generate=!0,this._forward=le,this._prepare_inputs_for_generation=Oe;break;case O.Phi3V:this.can_generate=!0,this._prepare_inputs_for_generation=Oe;break;case O.MultiModality:this.can_generate=!0,this._prepare_inputs_for_generation=ae;break;case O.AutoEncoder:this._forward=ce;break;default:this._forward=se;break}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){var ye;const H=[];for(const Ae of Object.values(this.sessions))(ye=Ae==null?void 0:Ae.handler)!=null&&ye.dispose&&H.push(Ae.handler.dispose());return await Promise.all(H)}static async from_pretrained(H,{progress_callback:ye=null,config:Ae=null,cache_dir:Pe=null,local_files_only:ze=!1,revision:et="main",model_file_name:dt=null,subfolder:gt="onnx",device:At=null,dtype:Nt=null,use_external_data_format:bt=null,session_options:Wt={}}={}){let wt={progress_callback:ye,config:Ae,cache_dir:Pe,local_files_only:ze,revision:et,model_file_name:dt,subfolder:gt,device:At,dtype:Nt,use_external_data_format:bt,session_options:Wt};const jt=A.get(this),$t=x.get(jt);Ae=wt.config=await i.AutoConfig.from_pretrained(H,wt);let Ht;if($t===O.DecoderOnly)Ht=await Promise.all([K(H,{model:wt.model_file_name??"model"},wt),X(H,{generation_config:"generation_config.json"},wt)]);else if($t===O.Seq2Seq||$t===O.Vision2Seq)Ht=await Promise.all([K(H,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},wt),X(H,{generation_config:"generation_config.json"},wt)]);else if($t===O.MaskGeneration)Ht=await Promise.all([K(H,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},wt)]);else if($t===O.EncoderDecoder)Ht=await Promise.all([K(H,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},wt)]);else if($t===O.ImageTextToText){const rn={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};Ae.is_encoder_decoder&&(rn.model="encoder_model"),Ht=await Promise.all([K(H,rn,wt),X(H,{generation_config:"generation_config.json"},wt)])}else if($t===O.AudioTextToText){const rn={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};Ht=await Promise.all([K(H,rn,wt),X(H,{generation_config:"generation_config.json"},wt)])}else if($t===O.Musicgen)Ht=await Promise.all([K(H,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},wt),X(H,{generation_config:"generation_config.json"},wt)]);else if($t===O.MultiModality)Ht=await Promise.all([K(H,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},wt),X(H,{generation_config:"generation_config.json"},wt)]);else if($t===O.Phi3V)Ht=await Promise.all([K(H,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},wt),X(H,{generation_config:"generation_config.json"},wt)]);else if($t===O.AutoEncoder)Ht=await Promise.all([K(H,{encoder_model:"encoder_model",decoder_model:"decoder_model"},wt)]);else{if($t!==O.EncoderOnly){const rn=jt??(Ae==null?void 0:Ae.model_type);rn!=="custom"&&console.warn(`Model type for '${rn}' not found, assuming encoder-only architecture. Please report this at ${f.GITHUB_ISSUE_URL}.`)}Ht=await Promise.all([K(H,{model:wt.model_file_name??"model"},wt)])}return new this(Ae,...Ht)}async _call(H){return await this.forward(H)}async forward(H){return await this._forward(this,H)}get generation_config(){var H;return((H=this.configs)==null?void 0:H.generation_config)??null}_get_logits_warper(H){const ye=new g.LogitsProcessorList;return H.temperature!==null&&H.temperature!==1&&ye.push(new g.TemperatureLogitsWarper(H.temperature)),H.top_k!==null&&H.top_k!==0&&ye.push(new g.TopKLogitsWarper(H.top_k)),H.top_p!==null&&H.top_p<1&&ye.push(new g.TopPLogitsWarper(H.top_p)),ye}_get_logits_processor(H,ye,Ae=null){const Pe=new g.LogitsProcessorList;if(H.repetition_penalty!==null&&H.repetition_penalty!==1&&Pe.push(new g.RepetitionPenaltyLogitsProcessor(H.repetition_penalty)),H.no_repeat_ngram_size!==null&&H.no_repeat_ngram_size>0&&Pe.push(new g.NoRepeatNGramLogitsProcessor(H.no_repeat_ngram_size)),H.bad_words_ids!==null&&Pe.push(new g.NoBadWordsLogitsProcessor(H.bad_words_ids,H.eos_token_id)),H.min_length!==null&&H.eos_token_id!==null&&H.min_length>0&&Pe.push(new g.MinLengthLogitsProcessor(H.min_length,H.eos_token_id)),H.min_new_tokens!==null&&H.eos_token_id!==null&&H.min_new_tokens>0&&Pe.push(new g.MinNewTokensLengthLogitsProcessor(ye,H.min_new_tokens,H.eos_token_id)),H.forced_bos_token_id!==null&&Pe.push(new g.ForcedBOSTokenLogitsProcessor(H.forced_bos_token_id)),H.forced_eos_token_id!==null&&Pe.push(new g.ForcedEOSTokenLogitsProcessor(H.max_length,H.forced_eos_token_id)),H.begin_suppress_tokens!==null){const ze=ye>1||H.forced_bos_token_id===null?ye:ye+1;Pe.push(new g.SuppressTokensAtBeginLogitsProcessor(H.begin_suppress_tokens,ze))}return H.guidance_scale!==null&&H.guidance_scale>1&&Pe.push(new g.ClassifierFreeGuidanceLogitsProcessor(H.guidance_scale)),Ae!==null&&Pe.extend(Ae),Pe}_prepare_generation_config(H,ye,Ae=_.GenerationConfig){const Pe={...this.config};for(const et of["decoder","generator","text_config"])et in Pe&&Object.assign(Pe,Pe[et]);const ze=new Ae(Pe);return Object.assign(ze,this.generation_config??{}),H&&Object.assign(ze,H),ye&&Object.assign(ze,(0,p.pick)(ye,Object.getOwnPropertyNames(ze))),ze}_get_stopping_criteria(H,ye=null){const Ae=new k.StoppingCriteriaList;return H.max_length!==null&&Ae.push(new k.MaxLengthCriteria(H.max_length,this.config.max_position_embeddings??null)),H.eos_token_id!==null&&Ae.push(new k.EosTokenCriteria(H.eos_token_id)),ye&&Ae.extend(ye),Ae}_validate_model_class(){if(!this.can_generate){const H=[bd,no,Us,za],ye=A.get(this.constructor),Ae=new Set,Pe=this.config.model_type;for(const et of H){const dt=et.get(Pe);dt&&Ae.add(dt[0])}let ze=`The current model class (${ye}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw Ae.size>0&&(ze+=` Please use the following class instead: ${[...Ae].join(", ")}`),Error(ze)}}prepare_inputs_for_generation(...H){return this._prepare_inputs_for_generation(this,...H)}_update_model_kwargs_for_generation({generated_input_ids:H,outputs:ye,model_inputs:Ae,is_encoder_decoder:Pe}){return Ae.past_key_values=this.getPastKeyValues(ye,Ae.past_key_values),Ae.input_ids=new y.Tensor("int64",H.flat(),[H.length,1]),Pe||(Ae.attention_mask=(0,y.cat)([Ae.attention_mask,(0,y.ones)([Ae.attention_mask.dims[0],1])],1)),Ae.position_ids=null,Ae}_prepare_model_inputs({inputs:H,bos_token_id:ye,model_kwargs:Ae}){const Pe=(0,p.pick)(Ae,this.forward_params),ze=this.main_input_name;if(ze in Pe){if(H)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else Pe[ze]=H;return{inputs_tensor:Pe[ze],model_inputs:Pe,model_input_name:ze}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:H,model_inputs:ye,model_input_name:Ae,generation_config:Pe}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!ye.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:et,pixel_values:dt,attention_mask:gt,...At}=ye,Nt=await this._prepare_inputs_embeds(ye);ye={...At,...(0,p.pick)(Nt,["inputs_embeds","attention_mask"])}}let{last_hidden_state:ze}=await se(this,ye);if(Pe.guidance_scale!==null&&Pe.guidance_scale>1)ze=(0,y.cat)([ze,(0,y.full_like)(ze,0)],0),"attention_mask"in ye&&(ye.attention_mask=(0,y.cat)([ye.attention_mask,(0,y.zeros_like)(ye.attention_mask)],0));else if(ye.decoder_input_ids){const et=ue(ye.decoder_input_ids).dims[0];if(et!==ze.dims[0]){if(ze.dims[0]!==1)throw new Error(`The encoder outputs have a different batch size (${ze.dims[0]}) than the decoder inputs (${et}).`);ze=(0,y.cat)(Array.from({length:et},()=>ze),0)}}return ye.encoder_outputs=ze,ye}_prepare_decoder_input_ids_for_generation({batch_size:H,model_input_name:ye,model_kwargs:Ae,decoder_start_token_id:Pe,bos_token_id:ze,generation_config:et}){let{decoder_input_ids:dt,...gt}=Ae;if(!(dt instanceof y.Tensor)){if(dt)Array.isArray(dt[0])||(dt=Array.from({length:H},()=>dt));else if(Pe??(Pe=ze),this.config.model_type==="musicgen")dt=Array.from({length:H*this.config.decoder.num_codebooks},()=>[Pe]);else if(Array.isArray(Pe)){if(Pe.length!==H)throw new Error(`\`decoder_start_token_id\` expcted to have length ${H} but got ${Pe.length}`);dt=Pe}else dt=Array.from({length:H},()=>[Pe]);dt=ue(dt)}return Ae.decoder_attention_mask=(0,y.ones_like)(dt),{input_ids:dt,model_inputs:gt}}async generate({inputs:H=null,generation_config:ye=null,logits_processor:Ae=null,stopping_criteria:Pe=null,streamer:ze=null,...et}){this._validate_model_class(),ye=this._prepare_generation_config(ye,et);let{inputs_tensor:dt,model_inputs:gt,model_input_name:At}=this._prepare_model_inputs({inputs:H,model_kwargs:et});const Nt=this.config.is_encoder_decoder;Nt&&("encoder_outputs"in gt||(gt=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:dt,model_inputs:gt,model_input_name:At,generation_config:ye})));let bt;Nt?{input_ids:bt,model_inputs:gt}=this._prepare_decoder_input_ids_for_generation({batch_size:gt[At].dims.at(0),model_input_name:At,model_kwargs:gt,decoder_start_token_id:ye.decoder_start_token_id,bos_token_id:ye.bos_token_id,generation_config:ye}):bt=gt[At];let Wt=bt.dims.at(-1);ye.max_new_tokens!==null&&(ye.max_length=Wt+ye.max_new_tokens);const wt=this._get_logits_processor(ye,Wt,Ae),jt=this._get_stopping_criteria(ye,Pe),$t=gt[At].dims.at(0),Ht=L.LogitsSampler.getSampler(ye),rn=new Array($t).fill(0),un=bt.tolist();ze&&ze.put(un);let er,Qt={};for(;;){if(gt=this.prepare_inputs_for_generation(un,gt,ye),er=await this.forward(gt),ye.output_attentions&&ye.return_dict_in_generate){const Dr=this.getAttentions(er);for(const pa in Dr)pa in Qt||(Qt[pa]=[]),Qt[pa].push(Dr[pa])}const tr=er.logits.slice(null,-1,null),fs=wt(un,tr),so=[];for(let Dr=0;Dr<fs.dims.at(0);++Dr){const pa=fs[Dr],pp=await Ht(pa);for(const[Wl,Hl]of pp){const Dd=BigInt(Wl);rn[Dr]+=Hl,un[Dr].push(Dd),so.push([Dd]);break}}if(ze&&ze.put(so),jt(un).every(Dr=>Dr))break;gt=this._update_model_kwargs_for_generation({generated_input_ids:so,outputs:er,model_inputs:gt,is_encoder_decoder:Nt})}ze&&ze.end();const Sn=this.getPastKeyValues(er,gt.past_key_values,!0),Vn=new y.Tensor("int64",un.flat(),[un.length,un[0].length]);if(ye.return_dict_in_generate)return{sequences:Vn,past_key_values:Sn,...Qt};for(const tr of Object.values(er))tr.location==="gpu-buffer"&&tr.dispose();return Vn}getPastKeyValues(H,ye,Ae=!1){const Pe=Object.create(null);for(const ze in H)if(ze.startsWith("present")){const et=ze.replace("present","past_key_values"),dt=ze.includes("encoder");if(dt&&ye?Pe[et]=ye[et]:Pe[et]=H[ze],ye&&(!dt||Ae)){const gt=ye[et];gt.location==="gpu-buffer"&&gt.dispose()}}return Pe}getAttentions(H){const ye={};for(const Ae of["cross_attentions","encoder_attentions","decoder_attentions"])for(const Pe in H)Pe.startsWith(Ae)&&(Ae in ye||(ye[Ae]=[]),ye[Ae].push(H[Pe]));return ye}addPastKeyValues(H,ye){var Ae,Pe,ze;if(ye)Object.assign(H,ye);else{const et=this.sessions.decoder_model_merged??this.sessions.model,dt=((Ae=et==null?void 0:et.config)==null?void 0:Ae.kv_cache_dtype)??"float32",gt=dt==="float16"?new y.DataTypeMap.float16:[],At=((ze=(Pe=H[this.main_input_name]??H.attention_mask)==null?void 0:Pe.dims)==null?void 0:ze[0])??1,Nt=(0,i.getKeyValueShapes)(this.config,{batch_size:At});for(const bt in Nt)H[bt]=new y.Tensor(dt,gt,Nt[bt])}}async encode_image({pixel_values:H}){const ye=(await ie(this.sessions.vision_encoder,{pixel_values:H})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${ye.dims[1]}).`),this.config.num_image_tokens=ye.dims[1]),ye}async encode_text({input_ids:H}){return(await ie(this.sessions.embed_tokens,{input_ids:H})).inputs_embeds}async encode_audio({audio_values:H}){return(await ie(this.sessions.audio_encoder,{audio_values:H})).audio_features}}class Ee{}class Ve extends Ee{constructor({last_hidden_state:z,hidden_states:H=null,attentions:ye=null}){super(),this.last_hidden_state=z,this.hidden_states=H,this.attentions=ye}}class Ue extends Z{}class qe extends Ue{}class We extends Ue{async _call(z){return new br(await super._call(z))}}class nt extends Ue{async _call(z){return new Vt(await super._call(z))}}class at extends Ue{async _call(z){return new hr(await super._call(z))}}class ct extends Ue{async _call(z){return new ir(await super._call(z))}}class V extends Z{}class fe extends V{}class q extends V{async _call(z){return new br(await super._call(z))}}class pe extends V{async _call(z){return new Vt(await super._call(z))}}class we extends V{async _call(z){return new hr(await super._call(z))}}class Fe extends Z{}class De extends Fe{}class rt extends Z{}class He extends rt{}class it extends rt{async _call(z){return new br(await super._call(z))}}class mt extends rt{async _call(z){return new Vt(await super._call(z))}}class _t extends rt{async _call(z){return new hr(await super._call(z))}}class Ot extends rt{async _call(z){return new ir(await super._call(z))}}class Ft extends Z{}class Dn extends Ft{}class hn extends Ft{async _call(z){return new br(await super._call(z))}}class Kn extends Ft{async _call(z){return new Vt(await super._call(z))}}class Ws extends Ft{async _call(z){return new hr(await super._call(z))}}class ga extends Ft{async _call(z){return new ir(await super._call(z))}}class Hr extends Z{}class ms extends Hr{}class _s extends Hr{async _call(z){return new br(await super._call(z))}}class gs extends Hr{async _call(z){return new Vt(await super._call(z))}}class Pt extends Hr{async _call(z){return new hr(await super._call(z))}}class ys extends Hr{async _call(z){return new ir(await super._call(z))}}class Kr extends Z{}class Ms extends Kr{}class Hs extends Kr{async _call(z){return new br(await super._call(z))}}class ya extends Kr{async _call(z){return new Vt(await super._call(z))}}class Pr extends Kr{async _call(z){return new hr(await super._call(z))}}class Nn extends Kr{async _call(z){return new ir(await super._call(z))}}class mn extends Z{}class st extends mn{}class yt extends mn{async _call(z){return new br(await super._call(z))}}class Et extends mn{async _call(z){return new Vt(await super._call(z))}}class Qn extends mn{async _call(z){return new hr(await super._call(z))}}class _n extends mn{async _call(z){return new ir(await super._call(z))}}class mr extends Z{}class vs extends mr{}class Fr extends mr{async _call(z){return new br(await super._call(z))}}class rr extends mr{async _call(z){return new Vt(await super._call(z))}}class qr extends mr{async _call(z){return new hr(await super._call(z))}}class Lr extends mr{async _call(z){return new ir(await super._call(z))}}class Pn extends Z{}class Ks extends Pn{}class Ua extends Pn{async _call(z){return new Vt(await super._call(z))}}class as extends Pn{async _call(z){return new hr(await super._call(z))}}class ws extends Pn{async _call(z){return new ir(await super._call(z))}}class Ei extends Pn{async _call(z){return new br(await super._call(z))}}class Ds extends Z{}class Va extends Ds{}class Si extends Ds{async _call(z){return new br(await super._call(z))}}class qs extends Ds{async _call(z){return new Vt(await super._call(z))}}class Ar extends Ds{async _call(z){return new hr(await super._call(z))}}class Tr extends Z{}class _r extends Tr{}class Ma extends Tr{async _call(z){return new br(await super._call(z))}}class is extends Tr{async _call(z){return new Vt(await super._call(z))}}class $r extends Tr{async _call(z){return new ir(await super._call(z))}}class os extends Z{}class uo extends os{}class Qr extends os{async _call(z){return new br(await super._call(z))}}class xr extends os{async _call(z){return new Vt(await super._call(z))}}class va extends os{async _call(z){return new hr(await super._call(z))}}class Xr extends os{async _call(z){return new ir(await super._call(z))}}class Yr extends Z{}class lr extends Yr{}class sr extends Yr{async _call(z){return new br(await super._call(z))}}class Ga extends Yr{async _call(z){return new Vt(await super._call(z))}}class Er extends Yr{async _call(z){return new ir(await super._call(z))}}class Is extends Z{}class Ci extends Is{}class Te extends Is{async _call(z){return new Vt(await super._call(z))}}class N extends Is{async _call(z){return new ir(await super._call(z))}}class ee extends Is{async _call(z){return new br(await super._call(z))}}class de extends Z{constructor(){super(...arguments);he(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class Me extends de{}class xe extends de{}class Ge extends Z{}class lt extends Ge{}class ht extends Ge{}class ft extends Z{}class Mt extends ft{}class kt extends ft{}class Zt extends Z{}class sn extends Zt{}class gn extends Zt{}class en extends Zt{async _call(z){return new Vt(await super._call(z))}}class $n extends Z{}class gr extends $n{}class yr extends $n{}class Br extends $n{async _call(z){return new Vt(await super._call(z))}}class Bn extends $n{}class bs extends Z{}class wn extends bs{}class bn extends bs{}class ur extends Z{}class Zr extends ur{}class zs extends ur{}class On extends Z{}class Xn extends On{}class Tn extends On{async _call(z){return new br(await super._call(z))}}class nn extends On{async _call(z){return new Vt(await super._call(z))}}class yn extends On{async _call(z){return new hr(await super._call(z))}}class In extends On{async _call(z){return new ir(await super._call(z))}}class jn extends Z{}class Pi extends jn{}class wa extends jn{async _call(z){return new br(await super._call(z))}}class Qo extends jn{async _call(z){return new Vt(await super._call(z))}}class Wa extends jn{async _call(z){return new hr(await super._call(z))}}class co extends jn{async _call(z){return new ir(await super._call(z))}}class Fs extends Z{}class Sc extends Fs{}class Cc extends Fs{async _call(z){return new br(await super._call(z))}}class fo extends Fs{async _call(z){return new Vt(await super._call(z))}}class Xo extends Fs{async _call(z){return new hr(await super._call(z))}}class iu extends Fs{async _call(z){return new ir(await super._call(z))}}class ou extends Z{}class Pc extends ou{}class Ac extends ou{}class Yo extends Z{constructor(){super(...arguments);he(this,"requires_attention_mask",!1);he(this,"main_input_name","input_features");he(this,"forward_params",["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"])}}class lu extends Yo{}class uu extends Yo{_prepare_generation_config(z,H){return super._prepare_generation_config(z,H,S.WhisperGenerationConfig)}_retrieve_init_tokens(z){const H=[z.decoder_start_token_id];let ye=z.language;const Ae=z.task;if(z.is_multilingual){ye||(console.warn("No language specified - defaulting to English (en)."),ye="en");const ze=`<|${(0,I.whisper_language_to_code)(ye)}|>`;H.push(z.lang_to_id[ze]),H.push(z.task_to_id[Ae??"transcribe"])}else if(ye||Ae)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!z.return_timestamps&&z.no_timestamps_token_id&&H.at(-1)!==z.no_timestamps_token_id?H.push(z.no_timestamps_token_id):z.return_timestamps&&H.at(-1)===z.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),H.pop()),H.filter(Pe=>Pe!=null)}async generate({inputs:z=null,generation_config:H=null,logits_processor:ye=null,stopping_criteria:Ae=null,...Pe}){H=this._prepare_generation_config(H,Pe);const ze=Pe.decoder_input_ids??this._retrieve_init_tokens(H);if(H.return_timestamps&&(ye??(ye=new g.LogitsProcessorList),ye.push(new g.WhisperTimeStampLogitsProcessor(H,ze))),H.begin_suppress_tokens&&(ye??(ye=new g.LogitsProcessorList),ye.push(new g.SuppressTokensAtBeginLogitsProcessor(H.begin_suppress_tokens,ze.length))),H.return_token_timestamps){if(!H.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");H.task==="translate"&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),H.output_attentions=!0,H.return_dict_in_generate=!0}const et=await super.generate({inputs:z,generation_config:H,logits_processor:ye,decoder_input_ids:ze,...Pe});return H.return_token_timestamps&&(et.token_timestamps=this._extract_token_timestamps(et,H.alignment_heads,H.num_frames)),et}_extract_token_timestamps(z,H,ye=null,Ae=.02){if(!z.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");ye==null&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let Pe=this.config.median_filter_width;Pe===void 0&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),Pe=7);const ze=z.cross_attentions,et=Array.from({length:this.config.decoder_layers},(jt,$t)=>(0,y.cat)(ze.map(Ht=>Ht[$t]),2)),dt=(0,y.stack)(H.map(([jt,$t])=>{if(jt>=et.length)throw new Error(`Layer index ${jt} is out of bounds for cross attentions (length ${et.length}).`);return ye?et[jt].slice(null,$t,null,[0,ye]):et[jt].slice(null,$t)})).transpose(1,0,2,3),[gt,At]=(0,y.std_mean)(dt,-2,0,!0),Nt=dt.clone();for(let jt=0;jt<Nt.dims[0];++jt){const $t=Nt[jt];for(let Ht=0;Ht<$t.dims[0];++Ht){const rn=$t[Ht],un=gt[jt][Ht][0].data,er=At[jt][Ht][0].data;for(let Qt=0;Qt<rn.dims[0];++Qt){let Sn=rn[Qt].data;for(let Vn=0;Vn<Sn.length;++Vn)Sn[Vn]=(Sn[Vn]-er[Vn])/un[Vn];Sn.set((0,b.medianFilter)(Sn,Pe))}}}const bt=[(0,y.mean)(Nt,1)],Wt=z.sequences.dims,wt=new y.Tensor("float32",new Float32Array(Wt[0]*Wt[1]),Wt);for(let jt=0;jt<Wt[0];++jt){const $t=bt[jt].neg().squeeze_(0),[Ht,rn]=(0,b.dynamic_time_warping)($t.tolist()),un=Array.from({length:Ht.length-1},(Sn,Vn)=>Ht[Vn+1]-Ht[Vn]),er=(0,p.mergeArrays)([1],un).map(Sn=>!!Sn),Qt=[];for(let Sn=0;Sn<er.length;++Sn)er[Sn]&&Qt.push(rn[Sn]*Ae);wt[jt].data.set(Qt,1)}return wt}}class $c extends uu{}class cu extends Z{constructor(){super(...arguments);he(this,"requires_attention_mask",!1);he(this,"main_input_name","input_values");he(this,"forward_params",["input_values","decoder_input_ids","past_key_values"])}}class Hd extends cu{}class Zo extends cu{}class du extends Z{constructor(){super(...arguments);he(this,"main_input_name","pixel_values");he(this,"forward_params",["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"])}}class Oc extends Z{constructor(){super(...arguments);he(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class Jo extends Oc{_merge_input_ids_with_image_features({inputs_embeds:z,image_features:H,input_ids:ye,attention_mask:Ae}){const Pe=this.config.image_token_index,et=ye.tolist().map(bt=>bt.findIndex(Wt=>Wt==Pe)),dt=et.every(bt=>bt===-1),gt=et.every(bt=>bt!==-1);if(!dt&&!gt)throw new Error("Every input should contain either 0 or 1 image token.");if(dt)return{inputs_embeds:z,attention_mask:Ae};const At=[],Nt=[];for(let bt=0;bt<et.length;++bt){const Wt=et[bt],wt=z[bt],jt=H[bt],$t=Ae[bt];At.push((0,y.cat)([wt.slice([0,Wt]),jt,wt.slice([Wt+1,wt.dims[0]])],0)),Nt.push((0,y.cat)([$t.slice([0,Wt]),(0,y.ones)([jt.dims[0]]),$t.slice([Wt+1,$t.dims[0]])],0))}return{inputs_embeds:(0,y.stack)(At,0),attention_mask:(0,y.stack)(Nt,0)}}}class fu extends Jo{}class kc extends Jo{}class Dc extends Z{constructor(){super(...arguments);he(this,"forward_params",["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"]);he(this,"main_input_name","inputs_embeds")}}class pu extends Dc{_merge_input_ids_with_image_features({inputs_embeds:z,image_features:H,input_ids:ye,attention_mask:Ae}){return{inputs_embeds:(0,y.cat)([H,z],1),attention_mask:(0,y.cat)([(0,y.ones)(H.dims.slice(0,2)),Ae],1)}}async _prepare_inputs_embeds({input_ids:z,pixel_values:H,inputs_embeds:ye,attention_mask:Ae}){if(!z&&!H)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let Pe,ze;return z&&(Pe=await this.encode_text({input_ids:z})),H&&(ze=await this.encode_image({pixel_values:H})),Pe&&ze?{inputs_embeds:ye,attention_mask:Ae}=this._merge_input_ids_with_image_features({inputs_embeds:Pe,image_features:ze,input_ids:z,attention_mask:Ae}):ye=Pe||ze,{inputs_embeds:ye,attention_mask:Ae}}async forward({input_ids:z,pixel_values:H,attention_mask:ye,decoder_input_ids:Ae,decoder_attention_mask:Pe,encoder_outputs:ze,past_key_values:et,inputs_embeds:dt,decoder_inputs_embeds:gt}){if(dt||({inputs_embeds:dt,attention_mask:ye}=await this._prepare_inputs_embeds({input_ids:z,pixel_values:H,inputs_embeds:dt,attention_mask:ye})),!ze){let{last_hidden_state:bt}=await se(this,{inputs_embeds:dt,attention_mask:ye});ze=bt}if(!gt){if(!Ae)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");gt=await this.encode_text({input_ids:Ae})}return await ge(this,{inputs_embeds:gt,attention_mask:Pe,encoder_attention_mask:ye,encoder_hidden_states:ze,past_key_values:et},!0)}}class hu extends Z{constructor(){super(...arguments);he(this,"forward_params",["input_ids","attention_mask","pixel_values","position_ids","past_key_values"])}}class mu extends hu{_merge_input_ids_with_image_features(z){const H=z.image_features.dims.at(-1),ye=z.image_features.view(-1,H);return U({image_token_id:this.config.image_token_index,...z,image_features:ye})}}class Ic extends Z{constructor(){super(...arguments);he(this,"forward_params",["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"])}}class el extends Ic{async encode_image({pixel_values:z,pixel_attention_mask:H}){return(await ie(this.sessions.vision_encoder,{pixel_values:z,pixel_attention_mask:H})).image_features}_merge_input_ids_with_image_features(z){const H=z.image_features.dims.at(-1),ye=z.image_features.view(-1,H);return U({image_token_id:this.config.image_token_id,...z,image_features:ye})}}class tl extends el{}class _u extends Z{constructor(){super(...arguments);he(this,"forward_params",["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"])}}class Qs extends _u{async forward({input_ids:z=null,attention_mask:H=null,pixel_values:ye=null,image_sizes:Ae=null,position_ids:Pe=null,inputs_embeds:ze=null,past_key_values:et=null,generation_config:dt=null,logits_processor:gt=null,...At}){if(!ze){let bt;if(ye&&z.dims[1]!==1){if(!Ae)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:bt}=await ie(this.sessions.vision_encoder,{pixel_values:ye,image_sizes:Ae}))}else{const Wt=this.config.normalized_config.hidden_size;bt=new y.Tensor("float32",[],[0,Wt])}({inputs_embeds:ze}=await ie(this.sessions.prepare_inputs_embeds,{input_ids:z,image_features:bt}))}return await ge(this,{inputs_embeds:ze,past_key_values:et,attention_mask:H,position_ids:Pe,generation_config:dt,logits_processor:gt},!1)}}class Ts extends Z{}class gu extends Ts{}class zc extends Ts{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"text_model"})}}class yu extends Ts{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"text_model"})}}class Fc extends Ts{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"vision_model"})}}class po extends Ts{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"vision_model"})}}class ho extends Z{}class Ha extends ho{}class Lc extends ho{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"text_model"})}}class Bc extends Ts{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"vision_model"})}}class Rc extends Z{}class Mu extends Rc{}class mo extends Z{}class Ai extends mo{async forward(z){const H=!z.input_ids,ye=!z.pixel_values;if(H&&ye)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(H&&(z.input_ids=(0,y.ones)([z.pixel_values.dims[0],1])),ye){const{image_size:gt}=this.config.vision_config;z.pixel_values=(0,y.full)([0,3,gt,gt],0)}const{text_embeddings:Ae,image_embeddings:Pe,l2norm_text_embeddings:ze,l2norm_image_embeddings:et}=await super.forward(z),dt={};return H||(dt.text_embeddings=Ae,dt.l2norm_text_embeddings=ze),ye||(dt.image_embeddings=Pe,dt.l2norm_image_embeddings=et),dt}}class $i extends mo{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"text_model"})}}class Nc extends mo{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"vision_model"})}}class Xs extends Z{}class Ka extends Xs{}class nl extends Xs{}class _o extends Z{}class rl extends _o{}class go extends _o{}class Oi extends Z{}class sl extends Oi{}class vu extends Oi{}class al extends Z{}class wu extends al{}class bu extends al{}class il extends Z{}class Rr extends il{}class qa extends il{}class ol extends Z{}class ll extends ol{}class ki extends ol{}class Je extends Z{}class ul extends Je{}class Tu extends Je{}class Ys extends Z{}class Qa extends Ys{}class Or extends Ys{}class ba extends Z{}class yo extends ba{}class Zs extends ba{}class Js extends Z{}class Mo extends Js{}class vo extends Js{}class Ls extends Z{}class cl extends Ls{}class Lt extends Ls{}class Ta extends Z{}class xu extends Ta{}class It extends Ta{}class wo extends Z{}class zt extends wo{}class dl extends wo{}class Di extends Z{}class Jr extends Di{}class fl extends Di{}class kr extends Z{}class Nr extends kr{}class ea extends kr{}class Ii extends Z{}class zi extends Ii{}class Fi extends Ii{}class Li extends Z{}class xa extends Li{}class pl extends Li{}class Xa extends Z{}class Ea extends Xa{}class Eu extends Xa{}class Sr extends Z{}class bo extends Sr{}class xs extends Sr{}class To extends Z{}class Bi extends To{}class ta extends To{}class Ri extends Z{}class xo extends Ri{}class Sa extends Ri{}class na extends Z{}class Ni extends na{}class ji extends na{}class jr extends Z{constructor(){super(...arguments);he(this,"forward_params",["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"])}}class Ur extends jr{get_rope_index(z,H,ye,Ae){const{vision_config:Pe,image_token_id:ze,video_token_id:et,vision_start_token_id:dt}=this.config,gt=Pe.spatial_merge_size??2,At=[];if(H||ye){let Nt=z.tolist();Ae||(Ae=(0,y.ones_like)(z));const bt=Ae.tolist(),Wt=Array.from({length:3},rn=>Array.from({length:z.dims[0]},un=>Array.from({length:z.dims[1]},er=>1))),wt=H?H.tolist():[],jt=ye?ye.tolist():[];let $t=0,Ht=0;for(let rn=0;rn<Nt.length;++rn){const un=Nt[rn].filter((Fn,Gn)=>bt[rn][Gn]==1),Qt=un.reduce((Fn,Gn,ao)=>(Gn==dt&&Fn.push(ao),Fn),[]).map(Fn=>un[Fn+1]),Sn=Qt.filter(Fn=>Fn==ze).length,Vn=Qt.filter(Fn=>Fn==et).length;let tr=[],fs=0,so=Sn,Gl=Vn;for(let Fn=0;Fn<Qt.length;++Fn){const Gn=un.findIndex((cn,$s)=>$s>fs&&cn==ze),ao=un.findIndex((cn,$s)=>$s>fs&&cn==et),io=so>0&&Gn!==-1?Gn:un.length+1,Yt=Gl>0&&ao!==-1?ao:un.length+1;let Kl,ql,dc,Id;io<Yt?([ql,dc,Id]=wt[$t],++$t,--so,Kl=io):([ql,dc,Id]=jt[Ht],++Ht,--Gl,Kl=Yt);const[hp,Vo,Go]=[Number(ql),Math.floor(Number(dc)/gt),Math.floor(Number(Id)/gt)],oo=Kl-fs,mp=tr.length>0?(0,b.max)(tr.at(-1))[0]+1:0;tr.push(Array.from({length:3*oo},(cn,$s)=>mp+$s%oo));const _p=oo+mp,zd=hp*Vo*Go,ch=Array.from({length:zd},(cn,$s)=>_p+Math.floor($s/(Vo*Go))),dh=Array.from({length:zd},(cn,$s)=>_p+Math.floor($s/Go)%Vo),Fd=Array.from({length:zd},(cn,$s)=>_p+$s%Go);tr.push([ch,dh,Fd].flat()),fs=Kl+zd}if(fs<un.length){const Fn=tr.length>0?(0,b.max)(tr.at(-1))[0]+1:0,Gn=un.length-fs;tr.push(Array.from({length:3*Gn},(ao,io)=>Fn+io%Gn))}const Dr=tr.reduce((Fn,Gn)=>Fn+Gn.length,0),pa=new Array(Dr);let pp=0;for(let Fn=0;Fn<3;++Fn)for(let Gn=0;Gn<tr.length;++Gn){const ao=tr[Gn],io=ao.length/3;for(let Yt=Fn*io;Yt<(Fn+1)*io;++Yt)pa[pp++]=ao[Yt]}let Wl=0;const Hl=bt[rn];for(let Fn=0;Fn<Hl.length;++Fn)if(Hl[Fn]==1){for(let Gn=0;Gn<3;++Gn)Wt[Gn][rn][Fn]=pa[Gn*Dr/3+Wl];++Wl}const Dd=(0,b.max)(pa)[0];At.push(Dd+1-Nt[rn].length)}return[new y.Tensor("int64",Wt.flat(1/0),[3,z.dims[0],z.dims[1]]),new y.Tensor("int64",At,[At.length,1])]}else if(Ae){const{data:Nt,dims:bt}=ve(Ae),Wt=BigInt64Array.from({length:3*Nt.length},(jt,$t)=>Nt[$t%Nt.length]),wt=Array.from({length:bt[0]},(jt,$t)=>(0,b.max)(Nt.subarray(bt[1]*$t,bt[1]*($t+1)))[0]+1n+BigInt(bt[1]));return[new y.Tensor("int64",Wt,[3,...bt]),new y.Tensor("int64",wt,[wt.length,1])]}else{const[Nt,bt]=z.dims,Wt=BigInt64Array.from({length:3*Nt*bt},(wt,jt)=>BigInt(Math.floor(jt%bt/Nt)));return[new y.Tensor("int64",Wt,[3,...z.dims]),(0,y.zeros)([Nt,1])]}}async encode_image({pixel_values:z,image_grid_thw:H}){return(await ie(this.sessions.vision_encoder,{pixel_values:z,grid_thw:H})).image_features}_merge_input_ids_with_image_features(z){return U({image_token_id:this.config.image_token_id,...z})}prepare_inputs_for_generation(z,H,ye){if(H.attention_mask&&!H.position_ids)if(!H.past_key_values)[H.position_ids,H.rope_deltas]=this.get_rope_index(H.input_ids,H.image_grid_thw,H.video_grid_thw,H.attention_mask);else{H.pixel_values=null;const Ae=BigInt(Object.values(H.past_key_values)[0].dims.at(-2)),Pe=H.rope_deltas.map(ze=>Ae+ze);H.position_ids=(0,y.stack)([Pe,Pe,Pe],0)}return H}}class Bs extends Z{}class Es extends Bs{}class Ss extends Bs{}class Rs extends Z{}class hl extends Rs{}class Eo extends Rs{}class Ui extends Z{}class Mr extends Ui{}class zn extends Ui{}class an extends Z{}class ra extends an{}class ls extends an{}class Vi extends Z{}class sa extends Vi{}class ml extends Vi{}class So extends Z{}class Ya extends So{}class Za extends So{async _call(z){return new Vt(await super._call(z))}}class Co extends Z{}class Ja extends Co{}class Po extends Co{async _call(z){return new Vt(await super._call(z))}}class aa extends Z{}class Cs extends aa{}class Ns extends Z{}class js extends Ns{}class _l extends Ns{async _call(z){return new Vt(await super._call(z))}}class gl extends Z{}class Gi extends gl{}class Wi extends Z{}class Ca extends Wi{}class vr extends Wi{async _call(z){return new Vt(await super._call(z))}}class Ao extends Z{}class Su extends Ao{}class Cu extends Z{}class jc extends Cu{}class Uc extends Cu{async _call(z){return new Vt(await super._call(z))}}class Yn extends Z{}class yl extends Yn{async _call(z){return new dp(await super._call(z))}}class ei extends Z{}class Hi extends ei{}class Ml extends ei{async _call(z){return new Vt(await super._call(z))}}class Pa extends Z{}class ti extends Pa{}class Vc extends Pa{async _call(z){return new Vt(await super._call(z))}}class vl extends Z{}class Gc extends vl{}class Pu extends vl{}class ia extends Z{}class wl extends ia{}class $o extends ia{}class bl extends Z{}class Ki extends bl{}class Au extends bl{async _call(z){return new Vt(await super._call(z))}}class ni extends Z{}class Tl extends ni{}class $u extends ni{async _call(z){return new xl(await super._call(z))}}class qi extends ni{async _call(z){return new Qi(await super._call(z))}}class xl extends Ee{constructor({logits:z,pred_boxes:H}){super(),this.logits=z,this.pred_boxes=H}}class Qi extends Ee{constructor({logits:z,pred_boxes:H,pred_masks:ye}){super(),this.logits=z,this.pred_boxes=H,this.pred_masks=ye}}class El extends Z{}class Ou extends El{}class oa extends El{async _call(z){return new Xi(await super._call(z))}}class Xi extends Ee{constructor({logits:z,pred_boxes:H}){super(),this.logits=z,this.pred_boxes=H}}class Oo extends Z{}class la extends Oo{}class ua extends Oo{async _call(z){return new Yi(await super._call(z))}}class Yi extends Xi{}class ko extends Z{}class Do extends ko{}class h extends ko{async _call(z){return new M(await super._call(z))}}class M extends Xi{}class $ extends Z{}class D extends ${}class R extends ${async _call(z){return new te(await super._call(z))}}class te extends xl{}class me extends Z{}class $e extends me{}class je extends me{async _call(z){return new Vt(await super._call(z))}}class Ye extends Z{}class Xe extends Ye{}class pt extends Ye{async _call(z){return new Vt(await super._call(z))}}class vt extends Z{}class fn extends vt{}class cr extends vt{async _call(z){return new Vt(await super._call(z))}}class Vr extends Z{}class ku extends Vr{}class Sl extends Vr{async _call(z){return new Vt(await super._call(z))}}class Io extends Vr{}class Kd extends Z{}class Zn extends Kd{}class Wc extends Kd{}class Du extends Z{}class qd extends Du{}class Qd extends Du{}class Wp extends Z{}class Hc extends Wp{}class Cl extends Z{}class Kc extends Cl{}class es extends Cl{}class ar extends Cl{}class qc extends Z{}class Pl extends qc{}class Iu extends Z{}class Qc extends Iu{}class Aa extends Z{}class zu extends Aa{}class Fu extends Z{}class Xc extends Fu{}class Xd extends Fu{}class Yc extends Z{}class Yd extends Yc{}class Zd extends Yc{}class Jd extends Z{}class ef extends Jd{}class Lu extends Z{}class tf extends Lu{}class Hp extends Lu{async _call(z){return new Vt(await super._call(z))}}class Zc extends Z{}class nf extends Zc{}class rf extends Zc{async _call(z){return new Vt(await super._call(z))}}class Bu extends Z{}class sf extends Bu{}class af extends Bu{async _call(z){return new Vt(await super._call(z))}}class Jc extends Z{}class of extends Jc{}class lf extends Jc{async _call(z){return new Vt(await super._call(z))}}class Kp extends Z{}class uf extends Kp{}class Zi extends Z{}class Ru extends Zi{}class cf extends Zi{async _call(z){return new Nu(await super._call(z))}}class Nu extends Ee{constructor({logits:z,pred_boxes:H}){super(),this.logits=z,this.pred_boxes=H}}class Al extends Z{}class df extends Al{async get_image_embeddings({pixel_values:z}){return await se(this,{pixel_values:z})}async forward(z){if((!z.image_embeddings||!z.image_positional_embeddings)&&(z={...z,...await this.get_image_embeddings(z)}),!z.input_labels&&z.input_points){const ye=z.input_points.dims.slice(0,-1),Ae=ye.reduce((Pe,ze)=>Pe*ze,1);z.input_labels=new y.Tensor("int64",new BigInt64Array(Ae).fill(1n),ye)}const H={image_embeddings:z.image_embeddings,image_positional_embeddings:z.image_positional_embeddings};return z.input_points&&(H.input_points=z.input_points),z.input_labels&&(H.input_labels=z.input_labels),z.input_boxes&&(H.input_boxes=z.input_boxes),await ie(this.sessions.prompt_encoder_mask_decoder,H)}async _call(z){return new ff(await super._call(z))}}class ff extends Ee{constructor({iou_scores:z,pred_masks:H}){super(),this.iou_scores=z,this.pred_masks=H}}class ed extends Z{}class pf extends ed{}class hf extends ed{}class td extends Z{}class nd extends td{}class mf extends td{}class ri extends Z{}class rd extends ri{}class _f extends ri{async _call(z){return new La(await super._call(z))}}class gf extends ri{async _call(z){return new Vt(await super._call(z))}}class qp extends ri{async _call(z){return new hr(await super._call(z))}}class ju extends Z{}class yf extends ju{}class Mf extends ju{async _call(z){return new hr(await super._call(z))}}class sd extends Z{}class vf extends sd{}class Uu extends Z{}class Qp extends Uu{}class Xp extends Uu{async _call(z){return new La(await super._call(z))}}class wf extends Uu{async _call(z){return new Vt(await super._call(z))}}class si extends Z{}class ad extends si{}class Vu extends si{async _call(z){return new La(await super._call(z))}}class bf extends si{async _call(z){return new Vt(await super._call(z))}}class Tf extends si{async _call(z){return new hr(await super._call(z))}}class zo extends Z{}class xf extends zo{}class Ef extends zo{async _call(z){return new La(await super._call(z))}}class Yp extends zo{async _call(z){return new Vt(await super._call(z))}}class $l extends Z{}class Ol extends ri{}class Gu extends ri{async _call(z){return new La(await super._call(z))}}class kl extends ri{async _call(z){return new Vt(await super._call(z))}}class ai extends Z{}class Sf extends ai{}class Cf extends ai{async _call(z){return new La(await super._call(z))}}class Fo extends ai{async _call(z){return new Vt(await super._call(z))}}class Pf extends ai{async _call(z){return new lh(await super._call(z))}}class Ps extends ai{async _call(z){return new hr(await super._call(z))}}class ca extends Z{}class ii extends ca{}class Wu extends Z{}class Ji extends Wu{}class $a extends Wu{}class dr extends Wu{async generate_speech(z,H,{threshold:ye=.5,minlenratio:Ae=0,maxlenratio:Pe=20,vocoder:ze=null}={}){const et={input_ids:z},{encoder_outputs:dt,encoder_attention_mask:gt}=await se(this,et),At=dt.dims[1]/this.config.reduction_factor,Nt=Math.floor(At*Pe),bt=Math.floor(At*Ae),Wt=this.config.num_mel_bins;let wt=[],jt=null,$t=null,Ht=0;for(;;){++Ht;const er=ne(!!$t);let Qt;$t?Qt=$t.output_sequence_out:Qt=new y.Tensor("float32",new Float32Array(Wt),[1,1,Wt]);let Sn={use_cache_branch:er,output_sequence:Qt,encoder_attention_mask:gt,speaker_embeddings:H,encoder_hidden_states:dt};this.addPastKeyValues(Sn,jt),$t=await ie(this.sessions.decoder_model_merged,Sn),jt=this.getPastKeyValues($t,jt);const{prob:Vn,spectrum:tr}=$t;if(wt.push(tr),Ht>=bt&&(Array.from(Vn.data).filter(fs=>fs>=ye).length>0||Ht>=Nt))break}const rn=(0,y.cat)(wt),{waveform:un}=await ie(ze.sessions.model,{spectrogram:rn});return{spectrogram:rn,waveform:un}}}class Hu extends Z{constructor(){super(...arguments);he(this,"main_input_name","spectrogram")}}class id extends Z{}class od extends id{}class ld extends Z{}class Af extends ld{}class eo extends ld{}class Dl extends Z{}class $f extends Dl{}class Of extends Dl{}class ud extends Z{}class Ku extends ud{}class kf extends ud{}class Il extends Z{}class Df extends Il{}class If extends Il{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"text_model"})}}class Zp extends Il{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"audio_model"})}}class zf extends Z{}class fr extends zf{async _call(z){return new fp(await super._call(z))}}class pr extends Z{}class Jp extends pr{}class Ff extends pr{}class Lf extends pr{}class cd extends Z{}class Bf extends cd{}class qu extends cd{}class Qu extends Z{}class Rf extends Qu{}class Nf extends Qu{async _call(z){return new Vt(await super._call(z))}}class dd extends Z{}class jf extends dd{}class Uf extends dd{}class Xu extends Z{constructor(){super(...arguments);he(this,"forward_params",["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"])}_apply_and_filter_by_delay_pattern_mask(H){const[ye,Ae]=H.dims,Pe=this.config.decoder.num_codebooks,ze=Ae-Pe;let et=0;for(let At=0;At<H.size;++At){if(H.data[At]===this.config.decoder.pad_token_id)continue;const Nt=At%Ae,bt=Math.floor(At/Ae)%Pe,Wt=Nt-bt;Wt>0&&Wt<=ze&&(H.data[et++]=H.data[At])}const dt=Math.floor(ye/Pe),gt=et/(dt*Pe);return new y.Tensor(H.type,H.data.slice(0,et),[dt,Pe,gt])}prepare_inputs_for_generation(H,ye,Ae){let Pe=structuredClone(H);for(let et=0;et<Pe.length;++et)for(let dt=0;dt<Pe[et].length;++dt)et%this.config.decoder.num_codebooks>=dt&&(Pe[et][dt]=BigInt(this.config.decoder.pad_token_id));return Ae.guidance_scale!==null&&Ae.guidance_scale>1&&(Pe=Pe.concat(Pe)),super.prepare_inputs_for_generation(Pe,ye,Ae)}async generate(H){const ye=await super.generate(H),Ae=this._apply_and_filter_by_delay_pattern_mask(ye).unsqueeze_(0),{audio_values:Pe}=await ie(this.sessions.encodec_decode,{audio_codes:Ae});return Pe}}class Yu extends Z{}class fd extends Yu{}class Zu extends Yu{async _call(z){return new Vt(await super._call(z))}}class pd extends Yu{}class Ju extends Z{}class hd extends Ju{}class Vf extends Ju{async _call(z){return new Vt(await super._call(z))}}class Oa extends Ju{}class zl extends Z{}class eh extends zl{}class Gf extends zl{async _call(z){return new Vt(await super._call(z))}}class ka extends zl{}class ec extends Z{}class tc extends ec{}class Fl extends ec{async _call(z){return new Vt(await super._call(z))}}class Un extends ec{}class th extends Z{}class nh extends th{}class Wf extends Z{}class Ll extends Wf{constructor(...H){super(...H);he(this,"forward_params",["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"]);this._generation_mode="text"}async forward(H){const ye=this._generation_mode??"text";let Ae;if(ye==="text"||!H.past_key_values){const gt=this.sessions.prepare_inputs_embeds,At=(0,p.pick)(H,gt.inputNames);Ae=await ie(gt,At)}else{const gt=this.sessions.gen_img_embeds,At=(0,p.pick)({image_ids:H.input_ids},gt.inputNames);Ae=await ie(gt,At)}const Pe={...H,...Ae},ze=await ge(this,Pe),et=this.sessions[ye==="text"?"lm_head":"gen_head"];if(!et)throw new Error(`Unable to find "${et}" generation head`);const dt=await ie(et,(0,p.pick)(ze,et.inputNames));return{...Ae,...ze,...dt}}async generate(H){return this._generation_mode="text",super.generate(H)}async generate_images(H){this._generation_mode="image";const ye=(H.inputs??H[this.main_input_name]).dims[1],Pe=(await super.generate(H)).slice(null,[ye,null]),ze=this.sessions.image_decode,{decoded_image:et}=await ie(ze,{generated_tokens:Pe}),dt=et.add_(1).mul_(255/2).clamp_(0,255).to("uint8"),gt=[];for(const At of dt){const Nt=T.RawImage.fromTensor(At);gt.push(Nt)}return gt}}class oi extends Ee{constructor({char_logits:z,bpe_logits:H,wp_logits:ye}){super(),this.char_logits=z,this.bpe_logits=H,this.wp_logits=ye}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class Hf extends Z{}class Kf extends Hf{async _call(z){return new oi(await super._call(z))}}class Lo extends Z{}class da extends Lo{}class qf extends Lo{}class nc extends Z{}class Qf extends nc{}class md extends nc{}class _d extends Z{constructor(){super(...arguments);he(this,"forward_params",["input_ids","attention_mask","position_ids","audio_values","past_key_values"])}}class rc extends _d{_merge_input_ids_with_audio_features(z){const H=z.audio_features.dims.at(-1),ye=z.audio_features.view(-1,H);return B({audio_token_id:this.config.ignore_index,...z,audio_features:ye})}}class sc extends Z{constructor(){super(...arguments);he(this,"main_input_name","input_values");he(this,"forward_params",["input_values"])}}class Da extends Ee{constructor({audio_codes:z}){super(),this.audio_codes=z}}class Jn extends Ee{constructor({audio_values:z}){super(),this.audio_values=z}}class gd extends sc{async encode(z){return new Da(await ie(this.sessions.encoder_model,z))}async decode(z){return new Jn(await ie(this.sessions.decoder_model,z))}}class Xf extends sc{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"encoder_model"})}}class wr extends sc{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"decoder_model"})}}class yd extends Z{constructor(){super(...arguments);he(this,"main_input_name","input_values");he(this,"forward_params",["input_values"])}}class Yf extends Ee{constructor({audio_codes:z}){super(),this.audio_codes=z}}class Zf extends Ee{constructor({audio_values:z}){super(),this.audio_values=z}}class Rn extends yd{async encode(z){return new Yf(await ie(this.sessions.encoder_model,z))}async decode(z){return new Zf(await ie(this.sessions.decoder_model,z))}}class ts extends yd{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"encoder_model"})}}class Ia extends yd{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"decoder_model"})}}class ac extends Z{constructor(){super(...arguments);he(this,"main_input_name","input_values");he(this,"forward_params",["input_values"])}}class Jf extends ac{async encode(z){return await ie(this.sessions.encoder_model,z)}async decode(z){return await ie(this.sessions.decoder_model,z)}}class rh extends ac{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"encoder_model"})}}class Md extends ac{static async from_pretrained(z,H={}){return super.from_pretrained(z,{...H,model_file_name:H.model_file_name??"decoder_model"})}}class Gt{static async from_pretrained(z,{progress_callback:H=null,config:ye=null,cache_dir:Ae=null,local_files_only:Pe=!1,revision:ze="main",model_file_name:et=null,subfolder:dt="onnx",device:gt=null,dtype:At=null,use_external_data_format:Nt=null,session_options:bt={}}={}){const Wt={progress_callback:H,config:ye,cache_dir:Ae,local_files_only:Pe,revision:ze,model_file_name:et,subfolder:dt,device:gt,dtype:At,use_external_data_format:Nt,session_options:bt};if(Wt.config=await i.AutoConfig.from_pretrained(z,Wt),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const wt=Wt.config.model_type;for(const jt of this.MODEL_CLASS_MAPPINGS){let $t=jt.get(wt);if(!$t){for(const Ht of jt.values())if(Ht[0]===wt){$t=Ht;break}if(!$t)continue}return await $t[1].from_pretrained(z,Wt)}if(this.BASE_IF_FAIL)return Bo.has(wt)||console.warn(`Unknown model class "${wt}", attempting to construct from base class.`),await Z.from_pretrained(z,Wt);throw Error(`Unsupported model type: ${wt}`)}}he(Gt,"MODEL_CLASS_MAPPINGS",null),he(Gt,"BASE_IF_FAIL",!1);const fa=new Map([["bert",["BertModel",qe]],["modernbert",["ModernBertModel",fe]],["nomic_bert",["NomicBertModel",De]],["roformer",["RoFormerModel",He]],["electra",["ElectraModel",ms]],["esm",["EsmModel",Va]],["convbert",["ConvBertModel",Dn]],["camembert",["CamembertModel",Ms]],["deberta",["DebertaModel",st]],["deberta-v2",["DebertaV2Model",vs]],["mpnet",["MPNetModel",uo]],["albert",["AlbertModel",Ci]],["distilbert",["DistilBertModel",Ks]],["roberta",["RobertaModel",Xn]],["xlm",["XLMModel",Pi]],["xlm-roberta",["XLMRobertaModel",Sc]],["clap",["ClapModel",Df]],["clip",["CLIPModel",gu]],["clipseg",["CLIPSegModel",Ka]],["chinese_clip",["ChineseCLIPModel",Mu]],["siglip",["SiglipModel",Ha]],["jina_clip",["JinaCLIPModel",Ai]],["mobilebert",["MobileBertModel",_r]],["squeezebert",["SqueezeBertModel",lr]],["wav2vec2",["Wav2Vec2Model",rd]],["wav2vec2-bert",["Wav2Vec2BertModel",xf]],["unispeech",["UniSpeechModel",Qp]],["unispeech-sat",["UniSpeechSatModel",ad]],["hubert",["HubertModel",Ol]],["wavlm",["WavLMModel",Sf]],["audio-spectrogram-transformer",["ASTModel",Pc]],["vits",["VitsModel",fr]],["pyannote",["PyAnnoteModel",yf]],["wespeaker-resnet",["WeSpeakerResNetModel",vf]],["detr",["DetrModel",Tl]],["rt_detr",["RTDetrModel",Ou]],["rt_detr_v2",["RTDetrV2Model",la]],["rf_detr",["RFDetrModel",Do]],["table-transformer",["TableTransformerModel",D]],["vit",["ViTModel",Ya]],["ijepa",["IJepaModel",Ja]],["pvt",["PvtModel",js]],["vit_msn",["ViTMSNModel",Ca]],["vit_mae",["ViTMAEModel",Gi]],["groupvit",["GroupViTModel",Su]],["fastvit",["FastViTModel",jc]],["mobilevit",["MobileViTModel",Hi]],["mobilevitv2",["MobileViTV2Model",ti]],["owlvit",["OwlViTModel",Gc]],["owlv2",["Owlv2Model",wl]],["beit",["BeitModel",Ki]],["deit",["DeiTModel",$e]],["hiera",["HieraModel",Xe]],["convnext",["ConvNextModel",tf]],["convnextv2",["ConvNextV2Model",nf]],["dinov2",["Dinov2Model",sf]],["dinov2_with_registers",["Dinov2WithRegistersModel",of]],["resnet",["ResNetModel",fn]],["swin",["SwinModel",ku]],["swin2sr",["Swin2SRModel",Zn]],["donut-swin",["DonutSwinModel",ef]],["yolos",["YolosModel",Ru]],["dpt",["DPTModel",qd]],["glpn",["GLPNModel",Yd]],["hifigan",["SpeechT5HifiGan",Hu]],["efficientnet",["EfficientNetModel",Rf]],["decision_transformer",["DecisionTransformerModel",nh]],["patchtst",["PatchTSTForPrediction",da]],["patchtsmixer",["PatchTSMixerForPrediction",Qf]],["mobilenet_v1",["MobileNetV1Model",fd]],["mobilenet_v2",["MobileNetV2Model",hd]],["mobilenet_v3",["MobileNetV3Model",eh]],["mobilenet_v4",["MobileNetV4Model",tc]],["maskformer",["MaskFormerModel",Xc]],["mgp-str",["MgpstrForSceneTextRecognition",Kf]],["style_text_to_speech_2",["StyleTextToSpeech2Model",ii]]]),sh=new Map([["t5",["T5Model",Me]],["longt5",["LongT5Model",lt]],["mt5",["MT5Model",Mt]],["bart",["BartModel",sn]],["mbart",["MBartModel",gr]],["marian",["MarianModel",pf]],["whisper",["WhisperModel",lu]],["m2m_100",["M2M100Model",nd]],["blenderbot",["BlenderbotModel",wn]],["blenderbot-small",["BlenderbotSmallModel",Zr]]]),As=new Map([["mimi",["MimiModel",gd]],["dac",["DacModel",Rn]],["snac",["SnacModel",Jf]]]),ah=new Map([["bloom",["BloomModel",Mr]],["jais",["JAISModel",sl]],["gpt2",["GPT2Model",rl]],["gptj",["GPTJModel",ll]],["gpt_bigcode",["GPTBigCodeModel",ul]],["gpt_neo",["GPTNeoModel",wu]],["gpt_neox",["GPTNeoXModel",Rr]],["codegen",["CodeGenModel",Qa]],["llama",["LlamaModel",yo]],["exaone",["ExaoneModel",xu]],["olmo",["OlmoModel",Jr]],["olmo2",["Olmo2Model",Nr]],["mobilellm",["MobileLLMModel",zt]],["granite",["GraniteModel",zi]],["cohere",["CohereModel",xa]],["gemma",["GemmaModel",Ea]],["gemma2",["Gemma2Model",bo]],["gemma3_text",["Gemma3Model",Bi]],["helium",["HeliumModel",Mo]],["glm",["GlmModel",cl]],["openelm",["OpenELMModel",xo]],["qwen2",["Qwen2Model",Ni]],["phi",["PhiModel",Es]],["phi3",["Phi3Model",hl]],["mpt",["MptModel",ra]],["opt",["OPTModel",sa]],["mistral",["MistralModel",Af]],["starcoder2",["Starcoder2Model",$f]],["falcon",["FalconModel",Ku]],["stablelm",["StableLmModel",Bf]]]),za=new Map([["speecht5",["SpeechT5ForSpeechToText",$a]],["whisper",["WhisperForConditionalGeneration",uu]],["lite-whisper",["LiteWhisperForConditionalGeneration",$c]],["moonshine",["MoonshineForConditionalGeneration",Zo]]]),to=new Map([["speecht5",["SpeechT5ForTextToSpeech",dr]]]),li=new Map([["vits",["VitsModel",fr]],["musicgen",["MusicgenForConditionalGeneration",Xu]]]),vd=new Map([["bert",["BertForSequenceClassification",nt]],["modernbert",["ModernBertForSequenceClassification",pe]],["roformer",["RoFormerForSequenceClassification",mt]],["electra",["ElectraForSequenceClassification",gs]],["esm",["EsmForSequenceClassification",qs]],["convbert",["ConvBertForSequenceClassification",Kn]],["camembert",["CamembertForSequenceClassification",ya]],["deberta",["DebertaForSequenceClassification",Et]],["deberta-v2",["DebertaV2ForSequenceClassification",rr]],["mpnet",["MPNetForSequenceClassification",xr]],["albert",["AlbertForSequenceClassification",Te]],["distilbert",["DistilBertForSequenceClassification",Ua]],["roberta",["RobertaForSequenceClassification",nn]],["xlm",["XLMForSequenceClassification",Qo]],["xlm-roberta",["XLMRobertaForSequenceClassification",fo]],["bart",["BartForSequenceClassification",en]],["mbart",["MBartForSequenceClassification",Br]],["mobilebert",["MobileBertForSequenceClassification",is]],["squeezebert",["SqueezeBertForSequenceClassification",Ga]]]),wd=new Map([["bert",["BertForTokenClassification",at]],["modernbert",["ModernBertForTokenClassification",we]],["roformer",["RoFormerForTokenClassification",_t]],["electra",["ElectraForTokenClassification",Pt]],["esm",["EsmForTokenClassification",Ar]],["convbert",["ConvBertForTokenClassification",Ws]],["camembert",["CamembertForTokenClassification",Pr]],["deberta",["DebertaForTokenClassification",Qn]],["deberta-v2",["DebertaV2ForTokenClassification",qr]],["mpnet",["MPNetForTokenClassification",va]],["distilbert",["DistilBertForTokenClassification",as]],["roberta",["RobertaForTokenClassification",yn]],["xlm",["XLMForTokenClassification",Wa]],["xlm-roberta",["XLMRobertaForTokenClassification",Xo]]]),Us=new Map([["t5",["T5ForConditionalGeneration",xe]],["longt5",["LongT5ForConditionalGeneration",ht]],["mt5",["MT5ForConditionalGeneration",kt]],["bart",["BartForConditionalGeneration",gn]],["mbart",["MBartForConditionalGeneration",yr]],["marian",["MarianMTModel",hf]],["m2m_100",["M2M100ForConditionalGeneration",mf]],["blenderbot",["BlenderbotForConditionalGeneration",bn]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",zs]]]),bd=new Map([["bloom",["BloomForCausalLM",zn]],["gpt2",["GPT2LMHeadModel",go]],["jais",["JAISLMHeadModel",vu]],["gptj",["GPTJForCausalLM",ki]],["gpt_bigcode",["GPTBigCodeForCausalLM",Tu]],["gpt_neo",["GPTNeoForCausalLM",bu]],["gpt_neox",["GPTNeoXForCausalLM",qa]],["codegen",["CodeGenForCausalLM",Or]],["llama",["LlamaForCausalLM",Zs]],["exaone",["ExaoneForCausalLM",It]],["olmo",["OlmoForCausalLM",fl]],["olmo2",["Olmo2ForCausalLM",ea]],["mobilellm",["MobileLLMForCausalLM",dl]],["granite",["GraniteForCausalLM",Fi]],["cohere",["CohereForCausalLM",pl]],["gemma",["GemmaForCausalLM",Eu]],["gemma2",["Gemma2ForCausalLM",xs]],["gemma3_text",["Gemma3ForCausalLM",ta]],["helium",["HeliumForCausalLM",vo]],["glm",["GlmForCausalLM",Lt]],["openelm",["OpenELMForCausalLM",Sa]],["qwen2",["Qwen2ForCausalLM",ji]],["phi",["PhiForCausalLM",Ss]],["phi3",["Phi3ForCausalLM",Eo]],["mpt",["MptForCausalLM",ls]],["opt",["OPTForCausalLM",ml]],["mbart",["MBartForCausalLM",Bn]],["mistral",["MistralForCausalLM",eo]],["starcoder2",["Starcoder2ForCausalLM",Of]],["falcon",["FalconForCausalLM",kf]],["trocr",["TrOCRForCausalLM",od]],["stablelm",["StableLmForCausalLM",qu]],["phi3_v",["Phi3VForCausalLM",Qs]]]),Bl=new Map([["multi_modality",["MultiModalityCausalLM",Ll]]]),Rl=new Map([["bert",["BertForMaskedLM",We]],["modernbert",["ModernBertForMaskedLM",q]],["roformer",["RoFormerForMaskedLM",it]],["electra",["ElectraForMaskedLM",_s]],["esm",["EsmForMaskedLM",Si]],["convbert",["ConvBertForMaskedLM",hn]],["camembert",["CamembertForMaskedLM",Hs]],["deberta",["DebertaForMaskedLM",yt]],["deberta-v2",["DebertaV2ForMaskedLM",Fr]],["mpnet",["MPNetForMaskedLM",Qr]],["albert",["AlbertForMaskedLM",ee]],["distilbert",["DistilBertForMaskedLM",Ei]],["roberta",["RobertaForMaskedLM",Tn]],["xlm",["XLMWithLMHeadModel",wa]],["xlm-roberta",["XLMRobertaForMaskedLM",Cc]],["mobilebert",["MobileBertForMaskedLM",Ma]],["squeezebert",["SqueezeBertForMaskedLM",sr]]]),Nl=new Map([["bert",["BertForQuestionAnswering",ct]],["roformer",["RoFormerForQuestionAnswering",Ot]],["electra",["ElectraForQuestionAnswering",ys]],["convbert",["ConvBertForQuestionAnswering",ga]],["camembert",["CamembertForQuestionAnswering",Nn]],["deberta",["DebertaForQuestionAnswering",_n]],["deberta-v2",["DebertaV2ForQuestionAnswering",Lr]],["mpnet",["MPNetForQuestionAnswering",Xr]],["albert",["AlbertForQuestionAnswering",N]],["distilbert",["DistilBertForQuestionAnswering",ws]],["roberta",["RobertaForQuestionAnswering",In]],["xlm",["XLMForQuestionAnswering",co]],["xlm-roberta",["XLMRobertaForQuestionAnswering",iu]],["mobilebert",["MobileBertForQuestionAnswering",$r]],["squeezebert",["SqueezeBertForQuestionAnswering",Er]]]),no=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",du]],["idefics3",["Idefics3ForConditionalGeneration",el]],["smolvlm",["SmolVLMForConditionalGeneration",tl]]]),ep=new Map([["llava",["LlavaForConditionalGeneration",Jo]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",fu]],["moondream1",["Moondream1ForConditionalGeneration",kc]],["florence2",["Florence2ForConditionalGeneration",pu]],["qwen2-vl",["Qwen2VLForConditionalGeneration",Ur]],["idefics3",["Idefics3ForConditionalGeneration",el]],["smolvlm",["SmolVLMForConditionalGeneration",tl]],["paligemma",["PaliGemmaForConditionalGeneration",mu]]]),tp=new Map([["ultravox",["UltravoxModel",rc]]]),ic=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",du]]]),np=new Map([["vit",["ViTForImageClassification",Za]],["ijepa",["IJepaForImageClassification",Po]],["pvt",["PvtForImageClassification",_l]],["vit_msn",["ViTMSNForImageClassification",vr]],["fastvit",["FastViTForImageClassification",Uc]],["mobilevit",["MobileViTForImageClassification",Ml]],["mobilevitv2",["MobileViTV2ForImageClassification",Vc]],["beit",["BeitForImageClassification",Au]],["deit",["DeiTForImageClassification",je]],["hiera",["HieraForImageClassification",pt]],["convnext",["ConvNextForImageClassification",Hp]],["convnextv2",["ConvNextV2ForImageClassification",rf]],["dinov2",["Dinov2ForImageClassification",af]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",lf]],["resnet",["ResNetForImageClassification",cr]],["swin",["SwinForImageClassification",Sl]],["segformer",["SegformerForImageClassification",Ff]],["efficientnet",["EfficientNetForImageClassification",Nf]],["mobilenet_v1",["MobileNetV1ForImageClassification",Zu]],["mobilenet_v2",["MobileNetV2ForImageClassification",Vf]],["mobilenet_v3",["MobileNetV3ForImageClassification",Gf]],["mobilenet_v4",["MobileNetV4ForImageClassification",Fl]]]),oc=new Map([["detr",["DetrForObjectDetection",$u]],["rt_detr",["RTDetrForObjectDetection",oa]],["rt_detr_v2",["RTDetrV2ForObjectDetection",ua]],["rf_detr",["RFDetrForObjectDetection",h]],["table-transformer",["TableTransformerForObjectDetection",R]],["yolos",["YolosForObjectDetection",cf]]]),rp=new Map([["owlvit",["OwlViTForObjectDetection",Pu]],["owlv2",["Owlv2ForObjectDetection",$o]],["grounding-dino",["GroundingDinoForObjectDetection",uf]]]),jl=new Map([["detr",["DetrForSegmentation",qi]],["clipseg",["CLIPSegForImageSegmentation",nl]]]),ih=new Map([["segformer",["SegformerForSemanticSegmentation",Lf]],["sapiens",["SapiensForSemanticSegmentation",Kc]],["swin",["SwinForSemanticSegmentation",Io]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",pd]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",Oa]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",ka]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",Un]]]),xn=new Map([["detr",["DetrForSegmentation",qi]],["maskformer",["MaskFormerForInstanceSegmentation",Xd]]]),kn=new Map([["sam",["SamModel",df]]]),tn=new Map([["wav2vec2",["Wav2Vec2ForCTC",_f]],["wav2vec2-bert",["Wav2Vec2BertForCTC",Ef]],["unispeech",["UniSpeechForCTC",Xp]],["unispeech-sat",["UniSpeechSatForCTC",Vu]],["wavlm",["WavLMForCTC",Cf]],["hubert",["HubertForCTC",Gu]]]),ln=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",gf]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",Yp]],["unispeech",["UniSpeechForSequenceClassification",wf]],["unispeech-sat",["UniSpeechSatForSequenceClassification",bf]],["wavlm",["WavLMForSequenceClassification",Fo]],["hubert",["HubertForSequenceClassification",kl]],["audio-spectrogram-transformer",["ASTForAudioClassification",Ac]]]),En=new Map([["wavlm",["WavLMForXVector",Pf]]]),us=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",Tf]],["wavlm",["WavLMForAudioFrameClassification",Ps]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",qp]],["pyannote",["PyAnnoteForAudioFrameClassification",Mf]]]),ui=new Map([["vitmatte",["VitMatteForImageMatting",yl]]]),Ul=new Map([["patchtst",["PatchTSTForPrediction",qf]],["patchtsmixer",["PatchTSMixerForPrediction",md]]]),Td=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Wc]]]),Fa=new Map([["dpt",["DPTForDepthEstimation",Qd]],["depth_anything",["DepthAnythingForDepthEstimation",Hc]],["glpn",["GLPNForDepthEstimation",Zd]],["sapiens",["SapiensForDepthEstimation",es]],["depth_pro",["DepthProForDepthEstimation",Pl]],["metric3d",["Metric3DForDepthEstimation",Qc]],["metric3dv2",["Metric3Dv2ForDepthEstimation",zu]]]),qn=new Map([["sapiens",["SapiensForNormalEstimation",ar]]]),ci=new Map([["vitpose",["VitPoseForPoseEstimation",Cs]]]),ro=new Map([["clip",["CLIPVisionModelWithProjection",po]],["siglip",["SiglipVisionModel",Bc]],["jina_clip",["JinaCLIPVisionModel",Nc]]]),xd=[[fa,O.EncoderOnly],[sh,O.EncoderDecoder],[ah,O.DecoderOnly],[As,O.AutoEncoder],[vd,O.EncoderOnly],[wd,O.EncoderOnly],[Us,O.Seq2Seq],[za,O.Seq2Seq],[bd,O.DecoderOnly],[Bl,O.MultiModality],[Rl,O.EncoderOnly],[Nl,O.EncoderOnly],[no,O.Vision2Seq],[ep,O.ImageTextToText],[tp,O.AudioTextToText],[np,O.EncoderOnly],[jl,O.EncoderOnly],[xn,O.EncoderOnly],[ih,O.EncoderOnly],[ui,O.EncoderOnly],[Ul,O.EncoderOnly],[Td,O.EncoderOnly],[Fa,O.EncoderOnly],[qn,O.EncoderOnly],[ci,O.EncoderOnly],[oc,O.EncoderOnly],[rp,O.EncoderOnly],[kn,O.MaskGeneration],[tn,O.EncoderOnly],[ln,O.EncoderOnly],[to,O.Seq2Seq],[li,O.EncoderOnly],[En,O.EncoderOnly],[us,O.EncoderOnly],[ro,O.EncoderOnly]];for(const[P,z]of xd)for(const[H,ye]of P.values())x.set(H,z),A.set(ye,H),E.set(H,ye);const Vs=[["MusicgenForConditionalGeneration",Xu,O.Musicgen],["Phi3VForCausalLM",Qs,O.Phi3V],["CLIPTextModelWithProjection",yu,O.EncoderOnly],["SiglipTextModel",Lc,O.EncoderOnly],["JinaCLIPTextModel",$i,O.EncoderOnly],["ClapTextModelWithProjection",If,O.EncoderOnly],["ClapAudioModelWithProjection",Zp,O.EncoderOnly],["DacEncoderModel",ts,O.EncoderOnly],["DacDecoderModel",Ia,O.EncoderOnly],["MimiEncoderModel",Xf,O.EncoderOnly],["MimiDecoderModel",wr,O.EncoderOnly],["SnacEncoderModel",rh,O.EncoderOnly],["SnacDecoderModel",Md,O.EncoderOnly]];for(const[P,z,H]of Vs)x.set(P,H),A.set(z,P),E.set(P,z);const Bo=new Map([["modnet",jl],["birefnet",jl],["isnet",jl],["ben",jl]]);for(const[P,z]of Bo.entries())z.set(P,["PreTrainedModel",Z]),x.set(P,O.EncoderOnly),A.set(Z,P),E.set(P,Z);class Ro extends Gt{}he(Ro,"MODEL_CLASS_MAPPINGS",xd.map(z=>z[0])),he(Ro,"BASE_IF_FAIL",!0);class ns extends Gt{}he(ns,"MODEL_CLASS_MAPPINGS",[vd]);class Ed extends Gt{}he(Ed,"MODEL_CLASS_MAPPINGS",[wd]);class Sd extends Gt{}he(Sd,"MODEL_CLASS_MAPPINGS",[Us]);class lc extends Gt{}he(lc,"MODEL_CLASS_MAPPINGS",[za]);class uc extends Gt{}he(uc,"MODEL_CLASS_MAPPINGS",[to]);class di extends Gt{}he(di,"MODEL_CLASS_MAPPINGS",[li]);class Cr extends Gt{}he(Cr,"MODEL_CLASS_MAPPINGS",[bd]);class fi extends Gt{}he(fi,"MODEL_CLASS_MAPPINGS",[Rl]);class No extends Gt{}he(No,"MODEL_CLASS_MAPPINGS",[Nl]);class jo extends Gt{}he(jo,"MODEL_CLASS_MAPPINGS",[no]);class Cd extends Gt{}he(Cd,"MODEL_CLASS_MAPPINGS",[np]);class Pd extends Gt{}he(Pd,"MODEL_CLASS_MAPPINGS",[jl]);class sp extends Gt{}he(sp,"MODEL_CLASS_MAPPINGS",[ih]);class Vl extends Gt{}he(Vl,"MODEL_CLASS_MAPPINGS",[xn]);class Ad extends Gt{}he(Ad,"MODEL_CLASS_MAPPINGS",[oc]);class cs extends Gt{}he(cs,"MODEL_CLASS_MAPPINGS",[rp]);class ap extends Gt{}he(ap,"MODEL_CLASS_MAPPINGS",[kn]);class ds extends Gt{}he(ds,"MODEL_CLASS_MAPPINGS",[tn]);class ip extends Gt{}he(ip,"MODEL_CLASS_MAPPINGS",[ln]);class op extends Gt{}he(op,"MODEL_CLASS_MAPPINGS",[En]);class oh extends Gt{}he(oh,"MODEL_CLASS_MAPPINGS",[us]);class pi extends Gt{}he(pi,"MODEL_CLASS_MAPPINGS",[ic]);class cc extends Gt{}he(cc,"MODEL_CLASS_MAPPINGS",[ui]);class $d extends Gt{}he($d,"MODEL_CLASS_MAPPINGS",[Td]);class Uo extends Gt{}he(Uo,"MODEL_CLASS_MAPPINGS",[Fa]);class lp extends Gt{}he(lp,"MODEL_CLASS_MAPPINGS",[qn]);class up extends Gt{}he(up,"MODEL_CLASS_MAPPINGS",[ci]);class cp extends Gt{}he(cp,"MODEL_CLASS_MAPPINGS",[ro]);class Od extends Gt{}he(Od,"MODEL_CLASS_MAPPINGS",[ep]);class kd extends Gt{}he(kd,"MODEL_CLASS_MAPPINGS",[tp]);class Xh extends Ee{constructor({logits:z,past_key_values:H,encoder_outputs:ye,decoder_attentions:Ae=null,cross_attentions:Pe=null}){super(),this.logits=z,this.past_key_values=H,this.encoder_outputs=ye,this.decoder_attentions=Ae,this.cross_attentions=Pe}}class Vt extends Ee{constructor({logits:z,...H}){super(),this.logits=z;const ye=Object.values(H);ye.length>0&&(this.attentions=ye)}}class lh extends Ee{constructor({logits:z,embeddings:H}){super(),this.logits=z,this.embeddings=H}}class hr extends Ee{constructor({logits:z}){super(),this.logits=z}}class br extends Ee{constructor({logits:z}){super(),this.logits=z}}class ir extends Ee{constructor({start_logits:z,end_logits:H}){super(),this.start_logits=z,this.end_logits=H}}class La extends Ee{constructor({logits:z}){super(),this.logits=z}}class uh extends Ee{constructor({logits:z,past_key_values:H}){super(),this.logits=z,this.past_key_values=H}}class dp extends Ee{constructor({alphas:z}){super(),this.alphas=z}}class fp extends Ee{constructor({waveform:z,spectrogram:H}){super(),this.waveform=z,this.spectrogram=H}}},"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":(t,s,n)=>{n.r(s),n.d(s,{ASTFeatureExtractor:()=>o});var i=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var l=n("./src/utils/audio.js");class o extends i.FeatureExtractor{constructor(p){super(p);const d=this.config.sampling_rate,f=(0,l.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(d/2),d,null,"kaldi",!0);for(let g=0;g<f.length;++g)f[g].push(0);this.mel_filters=f,this.window=(0,l.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(p,d){return(0,l.spectrogram)(p,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:d,transpose:!0})}async _call(p){(0,i.validate_audio_inputs)(p,"ASTFeatureExtractor");const d=await this._extract_fbank_features(p,this.config.max_length);if(this.config.do_normalize){const f=this.std*2,g=d.data;for(let _=0;_<g.length;++_)g[_]=(g[_]-this.mean)/f}return{input_values:d.unsqueeze_(0)}}}},"./src/models/auto/feature_extraction_auto.js":(t,s,n)=>{n.r(s),n.d(s,{AutoFeatureExtractor:()=>c});var i=n("./src/utils/constants.js"),l=n("./src/utils/hub.js");n("./src/base/feature_extraction_utils.js");var o=n("./src/models/feature_extractors.js");class c{static async from_pretrained(d,f={}){const g=await(0,l.getModelJSON)(d,i.FEATURE_EXTRACTOR_NAME,!0,f),_=g.feature_extractor_type,y=o[_];if(!y)throw new Error(`Unknown feature_extractor_type: '${_}'. Please report this at ${i.GITHUB_ISSUE_URL}.`);return new y(g)}}},"./src/models/auto/image_processing_auto.js":(t,s,n)=>{n.r(s),n.d(s,{AutoImageProcessor:()=>p});var i=n("./src/utils/constants.js"),l=n("./src/utils/hub.js"),o=n("./src/base/image_processors_utils.js"),c=n("./src/models/image_processors.js");class p{static async from_pretrained(f,g={}){const _=await(0,l.getModelJSON)(f,i.IMAGE_PROCESSOR_NAME,!0,g),y=_.image_processor_type??_.feature_extractor_type;let T=c[y];return T||(y!==void 0&&console.warn(`Image processor type '${y}' not found, assuming base ImageProcessor. Please report this at ${i.GITHUB_ISSUE_URL}.`),T=o.ImageProcessor),new T(_)}}},"./src/models/auto/processing_auto.js":(t,s,n)=>{n.r(s),n.d(s,{AutoProcessor:()=>f});var i=n("./src/utils/constants.js"),l=n("./src/utils/hub.js"),o=n("./src/base/processing_utils.js"),c=n("./src/models/processors.js"),p=n("./src/models/image_processors.js"),d=n("./src/models/feature_extractors.js");class f{static async from_pretrained(_,y={}){const T=await(0,l.getModelJSON)(_,i.IMAGE_PROCESSOR_NAME,!0,y),{image_processor_type:b,feature_extractor_type:k,processor_class:L}=T;if(L&&c[L])return c[L].from_pretrained(_,y);if(!b&&!k)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const C={};if(b){const I=p[b];if(!I)throw new Error(`Unknown image_processor_type: '${b}'.`);C.image_processor=new I(T)}if(k){const I=p[k];if(I)C.image_processor=new I(T);else{const O=d[k];if(!O)throw new Error(`Unknown feature_extractor_type: '${k}'.`);C.feature_extractor=new O(T)}}const S={};return new o.Processor(S,C)}}},"./src/models/beit/image_processing_beit.js":(t,s,n)=>{n.r(s),n.d(s,{BeitFeatureExtractor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}},"./src/models/bit/image_processing_bit.js":(t,s,n)=>{n.r(s),n.d(s,{BitImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}},"./src/models/chinese_clip/image_processing_chinese_clip.js":(t,s,n)=>{n.r(s),n.d(s,{ChineseCLIPFeatureExtractor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}},"./src/models/clap/feature_extraction_clap.js":(t,s,n)=>{n.r(s),n.d(s,{ClapFeatureExtractor:()=>o});var i=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var l=n("./src/utils/audio.js");class o extends i.FeatureExtractor{constructor(p){super(p),this.mel_filters=(0,l.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,l.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,l.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(p,d,f,g){let _;const y=p.length-d;if(y>0)if(f==="rand_trunc"){const T=Math.floor(Math.random()*(y+1));p=p.subarray(T,T+d),_=await this._extract_fbank_features(p,this.mel_filters_slaney,this.config.nb_max_samples)}else throw new Error(`Truncation strategy "${f}" not implemented`);else{if(y<0){let T=new Float64Array(d);if(T.set(p),g==="repeat")for(let b=p.length;b<d;b+=p.length)T.set(p.subarray(0,Math.min(p.length,d-b)),b);else if(g==="repeatpad")for(let b=p.length;b<-y;b+=p.length)T.set(p,b);p=T}if(f==="fusion")throw new Error(`Truncation strategy "${f}" not implemented`);_=await this._extract_fbank_features(p,this.mel_filters_slaney,this.config.nb_max_samples)}return _.unsqueeze_(0)}async _extract_fbank_features(p,d,f=null){return(0,l.spectrogram)(p,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:d,log_mel:"dB",max_num_frames:f,do_pad:!1,transpose:!0})}async _call(p,{max_length:d=null}={}){return(0,i.validate_audio_inputs)(p,"ClapFeatureExtractor"),{input_features:(await this._get_input_mel(p,d??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}},"./src/models/clip/image_processing_clip.js":(t,s,n)=>{n.r(s),n.d(s,{CLIPFeatureExtractor:()=>o,CLIPImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}class o extends l{}},"./src/models/convnext/image_processing_convnext.js":(t,s,n)=>{n.r(s),n.d(s,{ConvNextFeatureExtractor:()=>o,ConvNextImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{constructor(p){super(p),this.crop_pct=this.config.crop_pct??224/256}async resize(p){var f;const d=(f=this.size)==null?void 0:f.shortest_edge;if(d===void 0)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(d<384){const g=Math.floor(d/this.crop_pct),[_,y]=this.get_resize_output_image_size(p,{shortest_edge:g});p=await p.resize(_,y,{resample:this.resample}),p=await p.center_crop(d,d)}else p=await p.resize(d,d,{resample:this.resample});return p}}class o extends l{}},"./src/models/dac/feature_extraction_dac.js":(t,s,n)=>{n.r(s),n.d(s,{DacFeatureExtractor:()=>l});var i=n("./src/models/encodec/feature_extraction_encodec.js");class l extends i.EncodecFeatureExtractor{}},"./src/models/deit/image_processing_deit.js":(t,s,n)=>{n.r(s),n.d(s,{DeiTFeatureExtractor:()=>o,DeiTImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}class o extends l{}},"./src/models/detr/image_processing_detr.js":(t,s,n)=>{n.r(s),n.d(s,{DetrFeatureExtractor:()=>c,DetrImageProcessor:()=>o});var i=n("./src/base/image_processors_utils.js"),l=n("./src/utils/tensor.js");class o extends i.ImageProcessor{async _call(d){const f=await super._call(d),g=[f.pixel_values.dims[0],64,64],_=(0,l.full)(g,1n);return{...f,pixel_mask:_}}post_process_object_detection(...d){return(0,i.post_process_object_detection)(...d)}post_process_panoptic_segmentation(...d){return(0,i.post_process_panoptic_segmentation)(...d)}post_process_instance_segmentation(...d){return(0,i.post_process_instance_segmentation)(...d)}}class c extends o{}},"./src/models/donut/image_processing_donut.js":(t,s,n)=>{n.r(s),n.d(s,{DonutFeatureExtractor:()=>o,DonutImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{pad_image(p,d,f,g={}){const[_,y,T]=d;let b=this.image_mean;Array.isArray(this.image_mean)||(b=new Array(T).fill(b));let k=this.image_std;Array.isArray(k)||(k=new Array(T).fill(b));const L=b.map((C,S)=>-C/k[S]);return super.pad_image(p,d,f,{center:!0,constant_values:L,...g})}}class o extends l{}},"./src/models/dpt/image_processing_dpt.js":(t,s,n)=>{n.r(s),n.d(s,{DPTFeatureExtractor:()=>o,DPTImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}class o extends l{}},"./src/models/efficientnet/image_processing_efficientnet.js":(t,s,n)=>{n.r(s),n.d(s,{EfficientNetImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{constructor(c){super(c),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map(p=>p*p))}}},"./src/models/encodec/feature_extraction_encodec.js":(t,s,n)=>{n.r(s),n.d(s,{EncodecFeatureExtractor:()=>o});var i=n("./src/base/feature_extraction_utils.js"),l=n("./src/utils/tensor.js");class o extends i.FeatureExtractor{async _call(p){(0,i.validate_audio_inputs)(p,"EncodecFeatureExtractor"),p instanceof Float64Array&&(p=new Float32Array(p));const d=this.config.feature_size;if(p.length%d!==0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${d}).`);const f=[1,d,p.length/d];return{input_values:new l.Tensor("float32",p,f)}}}},"./src/models/feature_extractors.js":(t,s,n)=>{n.r(s),n.d(s,{ASTFeatureExtractor:()=>i.ASTFeatureExtractor,ClapFeatureExtractor:()=>o.ClapFeatureExtractor,DacFeatureExtractor:()=>c.DacFeatureExtractor,EncodecFeatureExtractor:()=>l.EncodecFeatureExtractor,ImageFeatureExtractor:()=>k.ImageProcessor,MoonshineFeatureExtractor:()=>p.MoonshineFeatureExtractor,PyAnnoteFeatureExtractor:()=>d.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>f.SeamlessM4TFeatureExtractor,SnacFeatureExtractor:()=>g.SnacFeatureExtractor,SpeechT5FeatureExtractor:()=>_.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>y.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>T.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>b.WhisperFeatureExtractor});var i=n("./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),l=n("./src/models/encodec/feature_extraction_encodec.js"),o=n("./src/models/clap/feature_extraction_clap.js"),c=n("./src/models/dac/feature_extraction_dac.js"),p=n("./src/models/moonshine/feature_extraction_moonshine.js"),d=n("./src/models/pyannote/feature_extraction_pyannote.js"),f=n("./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),g=n("./src/models/snac/feature_extraction_snac.js"),_=n("./src/models/speecht5/feature_extraction_speecht5.js"),y=n("./src/models/wav2vec2/feature_extraction_wav2vec2.js"),T=n("./src/models/wespeaker/feature_extraction_wespeaker.js"),b=n("./src/models/whisper/feature_extraction_whisper.js"),k=n("./src/base/image_processors_utils.js")},"./src/models/florence2/processing_florence2.js":(t,s,n)=>{n.r(s),n.d(s,{Florence2Processor:()=>c});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js");class c extends i.Processor{constructor(d,f){super(d,f);const{tasks_answer_post_processing_type:g,task_prompts_without_inputs:_,task_prompts_with_input:y}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(g??{})),this.task_prompts_without_inputs=new Map(Object.entries(_??{})),this.task_prompts_with_input=new Map(Object.entries(y??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(d){typeof d=="string"&&(d=[d]);const f=[];for(const g of d)if(this.task_prompts_without_inputs.has(g))f.push(this.task_prompts_without_inputs.get(g));else{for(const[_,y]of this.task_prompts_with_input)if(g.includes(_)){f.push(y.replaceAll("{input}",g).replaceAll(_,""));break}f.length!==d.length&&f.push(g)}return f}post_process_generation(d,f,g){const _=this.tasks_answer_post_processing_type.get(f)??"pure_text";d=d.replaceAll("<s>","").replaceAll("</s>","");let y;switch(_){case"pure_text":y=d;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const T=_==="ocr"?"quad_boxes":"bboxes",b=d.matchAll(this.regexes[T]),k=[],L=[];for(const[C,S,...I]of b)k.push(S?S.trim():k.at(-1)??""),L.push(I.map((O,x)=>(Number(O)+.5)/this.size_per_bin*g[x%2]));y={labels:k,[T]:L};break;default:throw new Error(`Task "${f}" (of type "${_}") not yet implemented.`)}return{[f]:y}}async _call(d,f=null,g={}){if(!d&&!f)throw new Error("Either text or images must be provided");const _=await this.image_processor(d,g),y=f?this.tokenizer(f,g):{};return{..._,...y}}}he(c,"tokenizer_class",o.AutoTokenizer),he(c,"image_processor_class",l.AutoImageProcessor)},"./src/models/glpn/image_processing_glpn.js":(t,s,n)=>{n.r(s),n.d(s,{GLPNFeatureExtractor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}},"./src/models/grounding_dino/image_processing_grounding_dino.js":(t,s,n)=>{n.r(s),n.d(s,{GroundingDinoImageProcessor:()=>o});var i=n("./src/base/image_processors_utils.js"),l=n("./src/utils/tensor.js");class o extends i.ImageProcessor{async _call(p){const d=await super._call(p),f=d.pixel_values.dims,g=(0,l.ones)([f[0],f[2],f[3]]);return{...d,pixel_mask:g}}}},"./src/models/grounding_dino/processing_grounding_dino.js":(t,s,n)=>{n.r(s),n.d(s,{GroundingDinoProcessor:()=>d});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js"),c=n("./src/base/image_processors_utils.js");function p(f,g){const y=f.dims.at(-1)-1,T=f.tolist();T.fill(!1,0,1),T.fill(!1,y);const b=g.tolist();return T.map((k,L)=>k?L:null).filter(k=>k!==null).map(k=>b[k])}class d extends i.Processor{async _call(g,_,y={}){const T=g?await this.image_processor(g,y):{};return{..._?this.tokenizer(_,y):{},...T}}post_process_grounded_object_detection(g,_,{box_threshold:y=.25,text_threshold:T=.25,target_sizes:b=null}={}){const{logits:k,pred_boxes:L}=g,C=k.dims[0];if(b!==null&&b.length!==C)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const S=k.dims.at(1),I=k.sigmoid(),O=I.max(-1).tolist(),x=L.tolist().map(A=>A.map(F=>(0,c.center_to_corners_format)(F))),E=[];for(let A=0;A<C;++A){const F=b!==null?b[A]:null;F!==null&&(x[A]=x[A].map(J=>J.map((ue,ne)=>ue*F[(ne+1)%2])));const K=O[A],X=[],oe=[],ie=[];for(let J=0;J<S;++J){const ue=K[J];if(ue<=y)continue;const ne=x[A][J],G=I[A][J];X.push(ue),ie.push(ne);const se=p(G.gt(T),_[A]);oe.push(se)}E.push({scores:X,boxes:ie,labels:this.batch_decode(oe)})}return E}}he(d,"tokenizer_class",o.AutoTokenizer),he(d,"image_processor_class",l.AutoImageProcessor)},"./src/models/idefics3/image_processing_idefics3.js":(t,s,n)=>{n.r(s),n.d(s,{Idefics3ImageProcessor:()=>o});var i=n("./src/base/image_processors_utils.js"),l=n("./src/utils/tensor.js");class o extends i.ImageProcessor{constructor(p){super(p),this.do_image_splitting=p.do_image_splitting??!0,this.max_image_size=p.max_image_size}get_resize_for_vision_encoder(p,d){let[f,g]=p.dims.slice(-2);const _=g/f;return g>=f?(g=Math.ceil(g/d)*d,f=Math.floor(g/_),f=Math.ceil(f/d)*d):(f=Math.ceil(f/d)*d,g=Math.floor(f*_),g=Math.ceil(g/d)*d),{height:f,width:g}}async _call(p,{do_image_splitting:d=null,return_row_col_info:f=!1}={}){let g;if(!Array.isArray(p))g=[[p]];else{if(p.length===0||!p[0])throw new Error("No images provided.");Array.isArray(p[0])?g=p:g=[p]}let _=[],y=[],T=[];const b=[],k=[];for(const A of g){let F=await Promise.all(A.map(oe=>this.preprocess(oe)));b.push(...F.map(oe=>oe.original_size)),k.push(...F.map(oe=>oe.reshaped_input_size)),F.forEach(oe=>oe.pixel_values.unsqueeze_(0));const{longest_edge:K}=this.max_image_size;let X;if(d??this.do_image_splitting){let oe=new Array(F.length),ie=new Array(F.length);X=await Promise.all(F.map(async(J,ue)=>{const ne=this.get_resize_for_vision_encoder(J.pixel_values,K),G=await(0,l.interpolate_4d)(J.pixel_values,{size:[ne.height,ne.width]}),{frames:se,num_splits_h:ce,num_splits_w:ge}=await this.split_image(G,this.max_image_size);return oe[ue]=ce,ie[ue]=ge,(0,l.cat)(se,0)})),y.push(oe),T.push(ie)}else{const oe=[K,K];X=await Promise.all(F.map(ie=>(0,l.interpolate_4d)(ie.pixel_values,{size:oe}))),y.push(new Array(F.length).fill(0)),T.push(new Array(F.length).fill(0))}_.push((0,l.cat)(X,0))}const L=_.length,[C,S,I,O]=_[0].dims;let x,E;if(L===1)x=_[0].unsqueeze_(0),E=(0,l.full)([L,C,I,O],!0);else{const A=Math.max(..._.map(X=>X.dims.at(0)));E=(0,l.full)([L,A,I,O],!0);const F=E.data,K=A*I*O;for(let X=0;X<L;++X){const oe=_[X].dims[0];if(oe<A){_[X]=(0,l.cat)([_[X],(0,l.full)([A-oe,S,I,O],0)],0);const ie=X*K+oe*I*O,J=(X+1)*K;F.fill(!1,ie,J)}}x=(0,l.stack)(_,0)}return{pixel_values:x,pixel_attention_mask:E,original_sizes:b,reshaped_input_sizes:k,...f?{rows:y,cols:T}:{}}}async split_image(p,{longest_edge:d}){const f=d,g=d,_=[],[y,T]=p.dims.slice(-2);let b=0,k=0;if(y>f||T>g){b=Math.ceil(y/f),k=Math.ceil(T/g);const L=Math.ceil(y/b),C=Math.ceil(T/k);for(let O=0;O<b;++O)for(let x=0;x<k;++x){let E,A,F,K;O===b-1?(A=y-L,K=y):(A=O*L,K=(O+1)*L),x===k-1?(E=T-C,F=T):(E=x*C,F=(x+1)*C);const X=[A,E],oe=[K,F],ie=await(0,l.slice)(p,X,oe,[2,3]);_.push(ie)}const S=f,I=g;(y!==S||T!==I)&&(p=await(0,l.interpolate_4d)(p,{size:[S,I]}))}return _.push(p),{frames:_,num_splits_h:b,num_splits_w:k}}}},"./src/models/idefics3/processing_idefics3.js":(t,s,n)=>{n.r(s),n.d(s,{Idefics3Processor:()=>g});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js");n("./src/utils/image.js");var c=n("./src/utils/core.js");function p(_,y,T,b,k,L){let C="";for(let S=0;S<y;++S){for(let I=0;I<T;++I)C+=b+`<row_${S+1}_col_${I+1}>`+k.repeat(_);C+=`
`}return C+=`
${b}${L}`+k.repeat(_)+`${b}`,C}function d(_,y,T,b){return`${y}${b}`+T.repeat(_)+`${y}`}function f(_,y,T,b,k,L){return _===0&&y===0?d(T,b,k,L):p(T,_,y,b,k,L)}class g extends i.Processor{constructor(){super(...arguments);he(this,"fake_image_token","<fake_token_around_image>");he(this,"image_token","<image>");he(this,"global_img_token","<global-img>")}async _call(T,b=null,k={}){k.return_row_col_info??(k.return_row_col_info=!0);let L;b&&(L=await this.image_processor(b,k)),Array.isArray(T)||(T=[T]);const C=L.rows??[new Array(T.length).fill(0)],S=L.cols??[new Array(T.length).fill(0)],I=this.config.image_seq_len,O=[],x=[];for(let A=0;A<T.length;++A){const F=T[A],K=C[A],X=S[A];O.push((0,c.count)(F,this.image_token));const oe=K.map((ue,ne)=>f(ue,X[ne],I,this.fake_image_token,this.image_token,this.global_img_token)),ie=F.split(this.image_token);if(ie.length===0)throw new Error("The image token should be present in the text.");let J=ie[0];for(let ue=0;ue<oe.length;++ue)J+=oe[ue]+ie[ue+1];x.push(J)}return{...this.tokenizer(x),...L}}}he(g,"image_processor_class",l.AutoImageProcessor),he(g,"tokenizer_class",o.AutoTokenizer),he(g,"uses_processor_config",!0)},"./src/models/image_processors.js":(t,s,n)=>{n.r(s),n.d(s,{BeitFeatureExtractor:()=>i.BeitFeatureExtractor,BitImageProcessor:()=>l.BitImageProcessor,CLIPFeatureExtractor:()=>c.CLIPFeatureExtractor,CLIPImageProcessor:()=>c.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>o.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>p.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>p.ConvNextImageProcessor,DPTFeatureExtractor:()=>_.DPTFeatureExtractor,DPTImageProcessor:()=>_.DPTImageProcessor,DeiTFeatureExtractor:()=>d.DeiTFeatureExtractor,DeiTImageProcessor:()=>d.DeiTImageProcessor,DetrFeatureExtractor:()=>f.DetrFeatureExtractor,DetrImageProcessor:()=>f.DetrImageProcessor,DonutFeatureExtractor:()=>g.DonutFeatureExtractor,DonutImageProcessor:()=>g.DonutImageProcessor,EfficientNetImageProcessor:()=>y.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>T.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>b.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>k.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>C.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>S.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>I.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>O.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>O.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>x.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>x.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>E.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>E.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>A.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>A.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>F.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>F.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>K.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>K.MobileViTImageProcessor,NougatImageProcessor:()=>X.NougatImageProcessor,OwlViTFeatureExtractor:()=>ie.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>ie.OwlViTImageProcessor,Owlv2ImageProcessor:()=>oe.Owlv2ImageProcessor,Phi3VImageProcessor:()=>J.Phi3VImageProcessor,PvtImageProcessor:()=>ue.PvtImageProcessor,Qwen2VLImageProcessor:()=>ne.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>G.RTDetrImageProcessor,SamImageProcessor:()=>se.SamImageProcessor,SegformerFeatureExtractor:()=>ce.SegformerFeatureExtractor,SegformerImageProcessor:()=>ce.SegformerImageProcessor,SiglipImageProcessor:()=>ge.SiglipImageProcessor,SmolVLMImageProcessor:()=>W.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>U.Swin2SRImageProcessor,VLMImageProcessor:()=>L.VLMImageProcessor,ViTFeatureExtractor:()=>B.ViTFeatureExtractor,ViTImageProcessor:()=>B.ViTImageProcessor,VitMatteImageProcessor:()=>Q.VitMatteImageProcessor,VitPoseImageProcessor:()=>le.VitPoseImageProcessor,YolosFeatureExtractor:()=>re.YolosFeatureExtractor,YolosImageProcessor:()=>re.YolosImageProcessor});var i=n("./src/models/beit/image_processing_beit.js"),l=n("./src/models/bit/image_processing_bit.js"),o=n("./src/models/chinese_clip/image_processing_chinese_clip.js"),c=n("./src/models/clip/image_processing_clip.js"),p=n("./src/models/convnext/image_processing_convnext.js"),d=n("./src/models/deit/image_processing_deit.js"),f=n("./src/models/detr/image_processing_detr.js"),g=n("./src/models/donut/image_processing_donut.js"),_=n("./src/models/dpt/image_processing_dpt.js"),y=n("./src/models/efficientnet/image_processing_efficientnet.js"),T=n("./src/models/glpn/image_processing_glpn.js"),b=n("./src/models/grounding_dino/image_processing_grounding_dino.js"),k=n("./src/models/idefics3/image_processing_idefics3.js"),L=n("./src/models/janus/image_processing_janus.js"),C=n("./src/models/jina_clip/image_processing_jina_clip.js"),S=n("./src/models/llava_onevision/image_processing_llava_onevision.js"),I=n("./src/models/mask2former/image_processing_mask2former.js"),O=n("./src/models/maskformer/image_processing_maskformer.js"),x=n("./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),E=n("./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),A=n("./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),F=n("./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),K=n("./src/models/mobilevit/image_processing_mobilevit.js"),X=n("./src/models/nougat/image_processing_nougat.js"),oe=n("./src/models/owlv2/image_processing_owlv2.js"),ie=n("./src/models/owlvit/image_processing_owlvit.js"),J=n("./src/models/phi3_v/image_processing_phi3_v.js"),ue=n("./src/models/pvt/image_processing_pvt.js"),ne=n("./src/models/qwen2_vl/image_processing_qwen2_vl.js"),G=n("./src/models/rt_detr/image_processing_rt_detr.js"),se=n("./src/models/sam/image_processing_sam.js"),ce=n("./src/models/segformer/image_processing_segformer.js"),ge=n("./src/models/siglip/image_processing_siglip.js"),W=n("./src/models/smolvlm/image_processing_smolvlm.js"),U=n("./src/models/swin2sr/image_processing_swin2sr.js"),B=n("./src/models/vit/image_processing_vit.js"),Q=n("./src/models/vitmatte/image_processing_vitmatte.js"),le=n("./src/models/vitpose/image_processing_vitpose.js"),re=n("./src/models/yolos/image_processing_yolos.js")},"./src/models/janus/image_processing_janus.js":(t,s,n)=>{n.r(s),n.d(s,{VLMImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{constructor(c){super({do_pad:!0,pad_size:{width:c.image_size,height:c.image_size},...c}),this.constant_values=this.config.background_color.map(p=>p*this.rescale_factor)}pad_image(c,p,d,f){return super.pad_image(c,p,d,{constant_values:this.constant_values,center:!0,...f})}}},"./src/models/janus/processing_janus.js":(t,s,n)=>{n.r(s),n.d(s,{VLChatProcessor:()=>f});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js"),c=n("./src/utils/core.js"),p=n("./src/utils/tensor.js"),d=n("./src/utils/image.js");class f extends i.Processor{constructor(_,y){super(_,y),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(_,{images:y=null,chat_template:T="default"}={}){y?Array.isArray(y)||(y=[y]):y=await Promise.all(_.filter(X=>X.images).flatMap(X=>X.images).map(X=>d.RawImage.read(X)));const b=this.tokenizer,k=b.apply_chat_template(_,{tokenize:!1,add_generation_prompt:!0,chat_template:T}),L=X=>b.encode(X,{add_special_tokens:!1}),C=k.split(this.image_tag),S=C.length-1;if(y.length!==S)throw new Error(`Number of images provided (${y.length}) does not match number of "${this.image_tag}" image tags (${S})`);const[I,O,x]=b.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let E=L(C[0]),A=new Array(E.length).fill(!1);for(let X=1;X<C.length;++X){const oe=new Array(this.num_image_tokens).fill(I),ie=L(C[X]);E=(0,c.mergeArrays)(E,[O],oe,[x],ie);const J=new Array(this.num_image_tokens).fill(!0);A=(0,c.mergeArrays)(A,[!1],J,[!1],new Array(ie.length).fill(!1))}const F=[1,E.length],K={input_ids:new p.Tensor("int64",E,F),attention_mask:new p.Tensor("int64",new Array(E.length).fill(1),F),images_seq_mask:new p.Tensor("bool",A,F),images_emb_mask:new p.Tensor("bool",new Array(S*this.num_image_tokens).fill(!0),[1,S,this.num_image_tokens])};if(y&&y.length>0){const X=await this.image_processor(y);return X.pixel_values.unsqueeze_(0),{...K,...X}}return K}}he(f,"image_processor_class",l.AutoImageProcessor),he(f,"tokenizer_class",o.AutoTokenizer),he(f,"uses_processor_config",!0)},"./src/models/jina_clip/image_processing_jina_clip.js":(t,s,n)=>{n.r(s),n.d(s,{JinaCLIPImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{constructor(c){const{resize_mode:p,fill_color:d,interpolation:f,size:g,..._}=c,y=p==="squash"?{width:g,height:g}:p==="shortest"?{shortest_edge:g}:{longest_edge:g},T=f==="bicubic"?3:2;super({..._,size:y,resample:T,do_center_crop:!0,crop_size:g,do_normalize:!0})}}},"./src/models/jina_clip/processing_jina_clip.js":(t,s,n)=>{n.r(s),n.d(s,{JinaCLIPProcessor:()=>c});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js");class c extends i.Processor{async _call(d=null,f=null,g={}){if(!d&&!f)throw new Error("Either text or images must be provided");const _=d?this.tokenizer(d,g):{},y=f?await this.image_processor(f,g):{};return{..._,...y}}}he(c,"tokenizer_class",o.AutoTokenizer),he(c,"image_processor_class",l.AutoImageProcessor)},"./src/models/llava_onevision/image_processing_llava_onevision.js":(t,s,n)=>{n.r(s),n.d(s,{LlavaOnevisionImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}},"./src/models/mask2former/image_processing_mask2former.js":(t,s,n)=>{n.r(s),n.d(s,{Mask2FormerImageProcessor:()=>l});var i=n("./src/models/maskformer/image_processing_maskformer.js");class l extends i.MaskFormerImageProcessor{}},"./src/models/maskformer/image_processing_maskformer.js":(t,s,n)=>{n.r(s),n.d(s,{MaskFormerFeatureExtractor:()=>o,MaskFormerImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{post_process_panoptic_segmentation(...p){return(0,i.post_process_panoptic_segmentation)(...p)}post_process_instance_segmentation(...p){return(0,i.post_process_instance_segmentation)(...p)}}class o extends l{}},"./src/models/mgp_str/processing_mgp_str.js":(t,s,n)=>{n.r(s),n.d(s,{MgpstrProcessor:()=>d});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js"),c=n("./src/utils/maths.js");const p={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class d extends i.Processor{get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(g,_){if(!p.hasOwnProperty(_))throw new Error(`Format ${_} is not supported.`);const[y,T]=p[_],b=this[y].bind(this),[k,L]=g.dims,C=[],S=[],I=g.tolist();for(let x=0;x<k;++x){const E=I[x],A=[],F=[];for(let X=1;X<L;++X){const[oe,ie]=(0,c.max)((0,c.softmax)(E[X]));if(F.push(oe),ie==T)break;A.push(ie)}const K=F.length>0?F.reduce((X,oe)=>X*oe,1):0;S.push(A),C.push(K)}return[b(S),C]}char_decode(g){return this.char_tokenizer.batch_decode(g).map(_=>_.replaceAll(" ",""))}bpe_decode(g){return this.bpe_tokenizer.batch_decode(g)}wp_decode(g){return this.wp_tokenizer.batch_decode(g).map(_=>_.replaceAll(" ",""))}batch_decode([g,_,y]){const[T,b]=this._decode_helper(g,"char"),[k,L]=this._decode_helper(_,"bpe"),[C,S]=this._decode_helper(y,"wp"),I=[],O=[];for(let x=0;x<T.length;++x){const[E,A]=(0,c.max)([b[x],L[x],S[x]]);I.push([T[x],k[x],C[x]][A]),O.push(E)}return{generated_text:I,scores:O,char_preds:T,bpe_preds:k,wp_preds:C}}static async from_pretrained(...g){const _=await super.from_pretrained(...g),y=await o.AutoTokenizer.from_pretrained("Xenova/gpt2"),T=await o.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return _.components={image_processor:_.image_processor,char_tokenizer:_.tokenizer,bpe_tokenizer:y,wp_tokenizer:T},_}async _call(g,_=null){const y=await this.image_processor(g);return _&&(y.labels=this.tokenizer(_).input_ids),y}}he(d,"tokenizer_class",o.AutoTokenizer),he(d,"image_processor_class",l.AutoImageProcessor)},"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":(t,s,n)=>{n.r(s),n.d(s,{MobileNetV1FeatureExtractor:()=>o,MobileNetV1ImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}class o extends l{}},"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":(t,s,n)=>{n.r(s),n.d(s,{MobileNetV2FeatureExtractor:()=>o,MobileNetV2ImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}class o extends l{}},"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":(t,s,n)=>{n.r(s),n.d(s,{MobileNetV3FeatureExtractor:()=>o,MobileNetV3ImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}class o extends l{}},"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":(t,s,n)=>{n.r(s),n.d(s,{MobileNetV4FeatureExtractor:()=>o,MobileNetV4ImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}class o extends l{}},"./src/models/mobilevit/image_processing_mobilevit.js":(t,s,n)=>{n.r(s),n.d(s,{MobileViTFeatureExtractor:()=>o,MobileViTImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}class o extends l{}},"./src/models/moonshine/feature_extraction_moonshine.js":(t,s,n)=>{n.r(s),n.d(s,{MoonshineFeatureExtractor:()=>o});var i=n("./src/base/feature_extraction_utils.js"),l=n("./src/utils/tensor.js");class o extends i.FeatureExtractor{async _call(p){(0,i.validate_audio_inputs)(p,"MoonshineFeatureExtractor"),p instanceof Float64Array&&(p=new Float32Array(p));const d=[1,p.length];return{input_values:new l.Tensor("float32",p,d)}}}},"./src/models/moonshine/processing_moonshine.js":(t,s,n)=>{n.r(s),n.d(s,{MoonshineProcessor:()=>c});var i=n("./src/models/auto/feature_extraction_auto.js"),l=n("./src/tokenizers.js"),o=n("./src/base/processing_utils.js");class c extends o.Processor{async _call(d){return await this.feature_extractor(d)}}he(c,"tokenizer_class",l.AutoTokenizer),he(c,"feature_extractor_class",i.AutoFeatureExtractor)},"./src/models/nougat/image_processing_nougat.js":(t,s,n)=>{n.r(s),n.d(s,{NougatImageProcessor:()=>l});var i=n("./src/models/donut/image_processing_donut.js");class l extends i.DonutImageProcessor{}},"./src/models/owlv2/image_processing_owlv2.js":(t,s,n)=>{n.r(s),n.d(s,{Owlv2ImageProcessor:()=>l});var i=n("./src/models/owlvit/image_processing_owlvit.js");class l extends i.OwlViTImageProcessor{}},"./src/models/owlvit/image_processing_owlvit.js":(t,s,n)=>{n.r(s),n.d(s,{OwlViTFeatureExtractor:()=>o,OwlViTImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{post_process_object_detection(...p){return(0,i.post_process_object_detection)(...p)}}class o extends l{}},"./src/models/owlvit/processing_owlvit.js":(t,s,n)=>{n.r(s),n.d(s,{OwlViTProcessor:()=>c});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js");class c extends i.Processor{}he(c,"tokenizer_class",o.AutoTokenizer),he(c,"image_processor_class",l.AutoImageProcessor)},"./src/models/paligemma/processing_paligemma.js":(t,s,n)=>{n.r(s),n.d(s,{PaliGemmaProcessor:()=>d});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js");const c="<image>";function p(f,g,_,y,T){return`${y.repeat(_*T)}${g}${f}
`}class d extends i.Processor{async _call(g,_=null,y={}){_||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),_=""),Array.isArray(g)||(g=[g]),Array.isArray(_)||(_=[_]);const T=this.tokenizer.bos_token,b=this.image_processor.config.image_seq_length;let k;_.some(S=>S.includes(c))?k=_.map(S=>{const I=S.replaceAll(c,c.repeat(b)),O=I.lastIndexOf(c),x=O===-1?0:O+c.length;return I.slice(0,x)+T+I.slice(x)+`
`}):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),k=_.map(S=>p(S,T,b,c,g.length)));const L=this.tokenizer(k,y);return{...await this.image_processor(g,y),...L}}}he(d,"tokenizer_class",o.AutoTokenizer),he(d,"image_processor_class",l.AutoImageProcessor),he(d,"uses_processor_config",!1)},"./src/models/phi3_v/image_processing_phi3_v.js":(t,s,n)=>{n.r(s),n.d(s,{Phi3VImageProcessor:()=>g});var i=n("./src/base/image_processors_utils.js"),l=n("./src/utils/tensor.js");const o=336,c=[2,3],{ceil:p,floor:d,sqrt:f}=Math;class g extends i.ImageProcessor{constructor(y){super({...y,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=y.num_crops}calc_num_image_tokens_from_image_size(y,T){const{num_img_tokens:b}=this.config;return d((d(T/o)*d(y/o)+1)*b+1+(d(T/o)+1)*f(b))}get_resize_output_image_size(y,T){const b=this._num_crops,[k,L]=y.size;let C=k/L,S=1;for(;S*Math.ceil(S/C)<=b;)S+=1;S-=1;const I=Math.floor(S*336),O=Math.floor(I/C);return[I,O]}pad_image(y,T,b,k={}){const[L,C]=T,S=o*p(L/o),I=o*p(C/o),O=[1,1,1].map((x,E)=>(x-this.image_mean[E])/this.image_std[E]);return super.pad_image(y,T,{width:I,height:S},{center:!0,constant_values:O,...k})}async _call(y,{num_crops:T=null}={}){if(this._num_crops=T??(T=this.config.num_crops),T<4||f(T)%1!==0)throw new Error("num_crops must be a square number >= 4");Array.isArray(y)||(y=[y]);const b=y.length,k=await Promise.all(y.map(A=>this.preprocess(A))),L=k.map(A=>A.original_size),C=k.map(A=>A.reshaped_input_size),S=[];for(const{pixel_values:A}of k){A.unsqueeze_(0);const[F,K]=A.dims.slice(-2),X=await(0,l.interpolate_4d)(A,{size:[o,o],mode:"bicubic"});if(T>0){const oe=[],ie=f(T),J=d(K/ie),ue=d(F/ie);for(let G=0;G<ie;++G)for(let se=0;se<ie;++se){let ce,ge,W,U;G===ie-1?(ge=F-ue,U=F):(ge=G*ue,U=(G+1)*ue),se===ie-1?(ce=K-J,W=K):(ce=se*J,W=(se+1)*J);const B=[ge,ce],Q=[U,W],le=await(0,l.slice)(A,B,Q,c);oe.push(le)}const ne=await(0,l.interpolate_4d)((0,l.cat)(oe,0),{size:[o,o],mode:"bicubic"});S.push((0,l.cat)([X,ne],0))}else S.push(X)}const I=(0,l.stack)(S,0),O=C.map(A=>A.map(F=>o*p(F/o))),x=new l.Tensor("int64",O.flat(),[b,2]),E=O.map(([A,F])=>this.calc_num_image_tokens_from_image_size(F,A));return{pixel_values:I,original_sizes:L,reshaped_input_sizes:C,image_sizes:x,num_img_tokens:E}}}},"./src/models/phi3_v/processing_phi3_v.js":(t,s,n)=>{n.r(s),n.d(s,{Phi3VProcessor:()=>d});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js");n("./src/utils/image.js");const c="<|image|>",p=/<\|image_\d+\|>/g;class d extends i.Processor{async _call(g,_=null,{padding:y=!0,truncation:T=!0,num_crops:b=null}={}){Array.isArray(g)||(g=[g]);let k,L;if(_){L=await this.image_processor(_,{num_crops:b});const{num_img_tokens:C}=L,S=g.map((O,x)=>O.split(p).join(c.repeat(C[x])));k=this.tokenizer(S,{padding:y,truncation:T});const I=this.tokenizer.model.convert_tokens_to_ids([c])[0];k.input_ids.map_(O=>O==I?-O:O)}else k=this.tokenizer(g);return{...k,...L}}}he(d,"image_processor_class",l.AutoImageProcessor),he(d,"tokenizer_class",o.AutoTokenizer)},"./src/models/processors.js":(t,s,n)=>{n.r(s),n.d(s,{Florence2Processor:()=>i.Florence2Processor,GroundingDinoProcessor:()=>l.GroundingDinoProcessor,Idefics3Processor:()=>o.Idefics3Processor,JinaCLIPProcessor:()=>p.JinaCLIPProcessor,MgpstrProcessor:()=>d.MgpstrProcessor,MoonshineProcessor:()=>f.MoonshineProcessor,OwlViTProcessor:()=>g.OwlViTProcessor,PaliGemmaProcessor:()=>y.PaliGemmaProcessor,Phi3VProcessor:()=>_.Phi3VProcessor,PyAnnoteProcessor:()=>T.PyAnnoteProcessor,Qwen2VLProcessor:()=>b.Qwen2VLProcessor,SamProcessor:()=>k.SamProcessor,SmolVLMProcessor:()=>L.SmolVLMProcessor,SpeechT5Processor:()=>C.SpeechT5Processor,UltravoxProcessor:()=>S.UltravoxProcessor,VLChatProcessor:()=>c.VLChatProcessor,Wav2Vec2Processor:()=>I.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>O.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>x.WhisperProcessor});var i=n("./src/models/florence2/processing_florence2.js"),l=n("./src/models/grounding_dino/processing_grounding_dino.js"),o=n("./src/models/idefics3/processing_idefics3.js"),c=n("./src/models/janus/processing_janus.js"),p=n("./src/models/jina_clip/processing_jina_clip.js"),d=n("./src/models/mgp_str/processing_mgp_str.js"),f=n("./src/models/moonshine/processing_moonshine.js"),g=n("./src/models/owlvit/processing_owlvit.js"),_=n("./src/models/phi3_v/processing_phi3_v.js"),y=n("./src/models/paligemma/processing_paligemma.js"),T=n("./src/models/pyannote/processing_pyannote.js"),b=n("./src/models/qwen2_vl/processing_qwen2_vl.js"),k=n("./src/models/sam/processing_sam.js"),L=n("./src/models/smolvlm/processing_smolvlm.js"),C=n("./src/models/speecht5/processing_speecht5.js"),S=n("./src/models/ultravox/processing_ultravox.js"),I=n("./src/models/wav2vec2/processing_wav2vec2.js"),O=n("./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),x=n("./src/models/whisper/processing_whisper.js")},"./src/models/pvt/image_processing_pvt.js":(t,s,n)=>{n.r(s),n.d(s,{PvtImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}},"./src/models/pyannote/feature_extraction_pyannote.js":(t,s,n)=>{n.r(s),n.d(s,{PyAnnoteFeatureExtractor:()=>c});var i=n("./src/base/feature_extraction_utils.js"),l=n("./src/utils/tensor.js"),o=n("./src/utils/maths.js");class c extends i.FeatureExtractor{async _call(d){(0,i.validate_audio_inputs)(d,"PyAnnoteFeatureExtractor"),d instanceof Float64Array&&(d=new Float32Array(d));const f=[1,1,d.length];return{input_values:new l.Tensor("float32",d,f)}}samples_to_frames(d){return(d-this.config.offset)/this.config.step}post_process_speaker_diarization(d,f){const g=f/this.samples_to_frames(f)/this.config.sampling_rate,_=[];for(const y of d.tolist()){const T=[];let b=-1;for(let k=0;k<y.length;++k){const L=(0,o.softmax)(y[k]),[C,S]=(0,o.max)(L),[I,O]=[k,k+1];S!==b?(b=S,T.push({id:S,start:I,end:O,score:C})):(T.at(-1).end=O,T.at(-1).score+=C)}_.push(T.map(({id:k,start:L,end:C,score:S})=>({id:k,start:L*g,end:C*g,confidence:S/(C-L)})))}return _}}},"./src/models/pyannote/processing_pyannote.js":(t,s,n)=>{n.r(s),n.d(s,{PyAnnoteProcessor:()=>o});var i=n("./src/base/processing_utils.js"),l=n("./src/models/pyannote/feature_extraction_pyannote.js");class o extends i.Processor{async _call(p){return await this.feature_extractor(p)}post_process_speaker_diarization(...p){return this.feature_extractor.post_process_speaker_diarization(...p)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}he(o,"feature_extractor_class",l.PyAnnoteFeatureExtractor)},"./src/models/qwen2_vl/image_processing_qwen2_vl.js":(t,s,n)=>{n.r(s),n.d(s,{Qwen2VLImageProcessor:()=>o});var i=n("./src/base/image_processors_utils.js"),l=n("./src/utils/tensor.js");class o extends i.ImageProcessor{async _call(p,...d){const{pixel_values:f,original_sizes:g,reshaped_input_sizes:_}=await super._call(p,...d);let y=f;const{temporal_patch_size:T,merge_size:b,patch_size:k}=this.config;y.dims[0]===1&&(y=(0,l.cat)(Array.from({length:T},()=>y),0));const L=y.dims[0]/T,C=y.dims[1],S=Math.floor(y.dims[2]/k),I=Math.floor(y.dims[3]/k),O=y.view(L,T,C,Math.floor(S/b),b,k,Math.floor(I/b),b,k).permute(0,3,6,4,7,2,1,5,8).view(L*S*I,C*T*k*k),x=new l.Tensor("int64",[L,S,I],[1,3]);return{pixel_values:O,image_grid_thw:x,original_sizes:g,reshaped_input_sizes:_}}}},"./src/models/qwen2_vl/processing_qwen2_vl.js":(t,s,n)=>{n.r(s),n.d(s,{Qwen2VLProcessor:()=>c});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js"),o=n("./src/tokenizers.js");n("./src/utils/image.js");class c extends i.Processor{async _call(d,f=null,...g){Array.isArray(d)||(d=[d]);let _,y;if(f&&(_=await this.image_processor(f),y=_.image_grid_thw),y){let b=this.image_processor.config.merge_size**2,k=0;const L=y.tolist();d=d.map(C=>{for(;C.includes("<|image_pad|>");){const S=Number(L[k++].reduce((I,O)=>I*O,1n));C=C.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(S/b)))}return C.replaceAll("<|placeholder|>","<|image_pad|>")})}return{...this.tokenizer(d),..._}}}he(c,"image_processor_class",l.AutoImageProcessor),he(c,"tokenizer_class",o.AutoTokenizer)},"./src/models/rt_detr/image_processing_rt_detr.js":(t,s,n)=>{n.r(s),n.d(s,{RTDetrImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{post_process_object_detection(...c){return(0,i.post_process_object_detection)(...c)}}},"./src/models/sam/image_processing_sam.js":(t,s,n)=>{n.r(s),n.d(s,{SamImageProcessor:()=>c});var i=n("./src/base/image_processors_utils.js"),l=n("./src/utils/core.js"),o=n("./src/utils/tensor.js");class c extends i.ImageProcessor{reshape_input_points(d,f,g,_=!1){d=structuredClone(d);let y=(0,l.calculateDimensions)(d);if(y.length===3)_||(y=[1,...y]),d=[d];else if(y.length!==4)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let T=0;T<d.length;++T){let b=f[T],k=g[T],L=[k[0]/b[0],k[1]/b[1]];for(let C=0;C<d[T].length;++C)for(let S=0;S<d[T][C].length;++S)for(let I=0;I<d[T][C][S].length;++I)d[T][C][S][I]*=L[I%2]}return new o.Tensor("float32",Float32Array.from(d.flat(1/0)),y)}add_input_labels(d,f){let g=(0,l.calculateDimensions)(d);if(g.length===2)g=[1,...g],d=[d];else if(g.length!==3)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(g.some((_,y)=>_!==f.dims[y]))throw Error(`The first ${g.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new o.Tensor("int64",d.flat(1/0).map(BigInt),g)}async _call(d,{input_points:f=null,input_labels:g=null,input_boxes:_=null}={}){const y=await super._call(d);if(f&&(y.input_points=this.reshape_input_points(f,y.original_sizes,y.reshaped_input_sizes)),g){if(!y.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");y.input_labels=this.add_input_labels(g,y.input_points)}return _&&(y.input_boxes=this.reshape_input_points(_,y.original_sizes,y.reshaped_input_sizes,!0)),y}async post_process_masks(d,f,g,{mask_threshold:_=0,binarize:y=!0,pad_size:T=null}={}){const b=[];T=T??this.pad_size;const k=[T.height,T.width];for(let L=0;L<f.length;++L){const C=f[L],S=g[L];let I=await(0,o.interpolate_4d)(d[L],{mode:"bilinear",size:k});if(I=I.slice(null,null,[0,S[0]],[0,S[1]]),I=await(0,o.interpolate_4d)(I,{mode:"bilinear",size:C}),y){const O=I.data,x=new Uint8Array(O.length);for(let E=0;E<O.length;++E)O[E]>_&&(x[E]=1);I=new o.Tensor("bool",x,I.dims)}b.push(I)}return b}generate_crop_boxes(d,f,{crop_n_layers:g=0,overlap_ratio:_=512/1500,points_per_crop:y=32,crop_n_points_downscale_factor:T=1}={}){}}},"./src/models/sam/processing_sam.js":(t,s,n)=>{n.r(s),n.d(s,{SamProcessor:()=>o});var i=n("./src/base/processing_utils.js"),l=n("./src/models/auto/image_processing_auto.js");class o extends i.Processor{async _call(...p){return await this.image_processor(...p)}post_process_masks(...p){return this.image_processor.post_process_masks(...p)}reshape_input_points(...p){return this.image_processor.reshape_input_points(...p)}}he(o,"image_processor_class",l.AutoImageProcessor)},"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":(t,s,n)=>{n.r(s),n.d(s,{SeamlessM4TFeatureExtractor:()=>c});var i=n("./src/base/feature_extraction_utils.js"),l=n("./src/utils/tensor.js"),o=n("./src/utils/audio.js");class c extends i.FeatureExtractor{constructor(d){super(d);const f=this.config.sampling_rate,g=(0,o.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(f/2),f,null,"kaldi",!0);for(let _=0;_<g.length;++_)g[_].push(0);this.mel_filters=g,this.window=(0,o.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(d,f){return d=d.map(g=>g*32768),(0,o.spectrogram)(d,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,max_num_frames:f,transpose:!0})}async _call(d,{padding:f=!0,pad_to_multiple_of:g=2,do_normalize_per_mel_bins:_=!0,return_attention_mask:y=!0}={}){(0,i.validate_audio_inputs)(d,"SeamlessM4TFeatureExtractor");let T=await this._extract_fbank_features(d,this.config.max_length);if(_){const[x,E]=T.dims,A=T.data;for(let F=0;F<E;++F){let K=0;for(let J=0;J<x;++J)K+=A[J*E+F];const X=K/x;let oe=0;for(let J=0;J<x;++J)oe+=(A[J*E+F]-X)**2;oe/=x-1;const ie=Math.sqrt(oe+1e-7);for(let J=0;J<x;++J){const ue=J*E+F;A[ue]=(A[ue]-X)/ie}}}let b;if(f){const[x,E]=T.dims,A=T.data,F=x%g;if(F>0){const K=new Float32Array(E*(x+F));K.set(A),K.fill(this.config.padding_value,A.length);const X=x+F;T=new l.Tensor(T.type,K,[X,E]),y&&(b=new l.Tensor("int64",new BigInt64Array(X),[1,X]),b.data.fill(1n,0,x))}}const[k,L]=T.dims,C=this.config.stride;if(k%C!==0)throw new Error(`The number of frames (${k}) must be a multiple of the stride (${C}).`);const I=T.view(1,Math.floor(k/C),L*C),O={input_features:I};if(y){const x=I.dims[1],E=new BigInt64Array(x);if(b){const A=b.data;for(let F=1,K=0;F<k;F+=C,++K)E[K]=A[F]}else E.fill(1n);O.attention_mask=new l.Tensor("int64",E,[1,x])}return O}}},"./src/models/segformer/image_processing_segformer.js":(t,s,n)=>{n.r(s),n.d(s,{SegformerFeatureExtractor:()=>o,SegformerImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{post_process_semantic_segmentation(...p){return(0,i.post_process_semantic_segmentation)(...p)}}class o extends l{}},"./src/models/siglip/image_processing_siglip.js":(t,s,n)=>{n.r(s),n.d(s,{SiglipImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}},"./src/models/smolvlm/image_processing_smolvlm.js":(t,s,n)=>{n.r(s),n.d(s,{SmolVLMImageProcessor:()=>i.Idefics3ImageProcessor});var i=n("./src/models/idefics3/image_processing_idefics3.js")},"./src/models/smolvlm/processing_smolvlm.js":(t,s,n)=>{n.r(s),n.d(s,{SmolVLMProcessor:()=>i.Idefics3Processor});var i=n("./src/models/idefics3/processing_idefics3.js")},"./src/models/snac/feature_extraction_snac.js":(t,s,n)=>{n.r(s),n.d(s,{SnacFeatureExtractor:()=>l});var i=n("./src/models/dac/feature_extraction_dac.js");class l extends i.DacFeatureExtractor{}},"./src/models/speecht5/feature_extraction_speecht5.js":(t,s,n)=>{n.r(s),n.d(s,{SpeechT5FeatureExtractor:()=>l});var i=n("./src/base/feature_extraction_utils.js");class l extends i.FeatureExtractor{}},"./src/models/speecht5/processing_speecht5.js":(t,s,n)=>{n.r(s),n.d(s,{SpeechT5Processor:()=>c});var i=n("./src/base/processing_utils.js"),l=n("./src/tokenizers.js"),o=n("./src/models/auto/feature_extraction_auto.js");class c extends i.Processor{async _call(d){return await this.feature_extractor(d)}}he(c,"tokenizer_class",l.AutoTokenizer),he(c,"feature_extractor_class",o.AutoFeatureExtractor)},"./src/models/swin2sr/image_processing_swin2sr.js":(t,s,n)=>{n.r(s),n.d(s,{Swin2SRImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{pad_image(c,p,d,f={}){const[g,_,y]=p;return super.pad_image(c,p,{width:_+(d-_%d)%d,height:g+(d-g%d)%d},{mode:"symmetric",center:!1,constant_values:-1,...f})}}},"./src/models/ultravox/processing_ultravox.js":(t,s,n)=>{n.r(s),n.d(s,{UltravoxProcessor:()=>c});var i=n("./src/models/auto/feature_extraction_auto.js"),l=n("./src/tokenizers.js"),o=n("./src/base/processing_utils.js");class c extends o.Processor{async _call(d,f=null,g={}){if(Array.isArray(d))throw new Error("Batched inputs are not supported yet.");let _={};if(f){const T=f.length,{input_features:b}=await this.feature_extractor(f,{...g,max_length:T}),k=Math.round(T/this.config.encoder_ds_factor+1e-4),L=1+Math.ceil(k/this.config.stack_factor);_.audio_token_len=[L],_.audio_values=b;const C=this.config.audio_placeholder;if(!d.includes(C))throw new Error(`The input text does not contain the image token ${C}.`);d=d.replaceAll(C,C.repeat(L))}return{...this.tokenizer(d,{add_special_tokens:!1,...g}),..._}}}he(c,"tokenizer_class",l.AutoTokenizer),he(c,"feature_extractor_class",i.AutoFeatureExtractor),he(c,"uses_processor_config",!0)},"./src/models/vit/image_processing_vit.js":(t,s,n)=>{n.r(s),n.d(s,{ViTFeatureExtractor:()=>o,ViTImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{}class o extends l{}},"./src/models/vitmatte/image_processing_vitmatte.js":(t,s,n)=>{n.r(s),n.d(s,{VitMatteImageProcessor:()=>o});var i=n("./src/base/image_processors_utils.js"),l=n("./src/utils/tensor.js");class o extends i.ImageProcessor{async _call(p,d){Array.isArray(p)||(p=[p]),Array.isArray(d)||(d=[d]);const f=await Promise.all(p.map(y=>this.preprocess(y))),g=await Promise.all(d.map(y=>this.preprocess(y,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0})));return{pixel_values:(0,l.stack)(f.map((y,T)=>(0,l.cat)([y.pixel_values,g[T].pixel_values],0)),0),original_sizes:f.map(y=>y.original_size),reshaped_input_sizes:f.map(y=>y.reshaped_input_size)}}}},"./src/models/vitpose/image_processing_vitpose.js":(t,s,n)=>{n.r(s),n.d(s,{VitPoseImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{post_process_pose_estimation(c,p,{threshold:d=null}={}){const f=c.tolist(),[g,_,y,T]=c.dims,b=[];for(let k=0;k<g;++k){const L=f[k],C=p[k],S=[];for(let I=0;I<C.length;++I){const O=C[I],x=[],E=[],A=[],F=O.at(-2)/T,K=O.at(-1)/y;for(let X=0;X<L.length;++X){let[oe,ie]=[0,0],J=0,ue=-1/0;const ne=L[X];for(let se=0;se<ne.length;++se){const ce=ne[se];for(let ge=0;ge<ce.length;++ge){const W=ce[ge];J+=W,ue=Math.max(ue,W),oe+=(ge+.5)*W,ie+=se*W}}if(d!=null&&ue<d)continue;const G=[F*oe/J,K*ie/J];x.push(G),A.push(X),E.push(ue)}S.push({bbox:O,scores:E,labels:A,keypoints:x})}b.push(S)}return b}}},"./src/models/wav2vec2/feature_extraction_wav2vec2.js":(t,s,n)=>{n.r(s),n.d(s,{Wav2Vec2FeatureExtractor:()=>o});var i=n("./src/base/feature_extraction_utils.js"),l=n("./src/utils/tensor.js");class o extends i.FeatureExtractor{_zero_mean_unit_var_norm(p){const f=p.reduce((_,y)=>_+y,0)/p.length,g=p.reduce((_,y)=>_+(y-f)**2,0)/p.length;return p.map(_=>(_-f)/Math.sqrt(g+1e-7))}async _call(p){(0,i.validate_audio_inputs)(p,"Wav2Vec2FeatureExtractor"),p instanceof Float64Array&&(p=new Float32Array(p));let d=p;this.config.do_normalize&&(d=this._zero_mean_unit_var_norm(d));const f=[1,d.length];return{input_values:new l.Tensor("float32",d,f),attention_mask:new l.Tensor("int64",new BigInt64Array(d.length).fill(1n),f)}}}},"./src/models/wav2vec2/processing_wav2vec2.js":(t,s,n)=>{n.r(s),n.d(s,{Wav2Vec2Processor:()=>c});var i=n("./src/tokenizers.js"),l=n("./src/models/auto/feature_extraction_auto.js"),o=n("./src/base/processing_utils.js");class c extends o.Processor{async _call(d){return await this.feature_extractor(d)}}he(c,"tokenizer_class",i.AutoTokenizer),he(c,"feature_extractor_class",l.AutoFeatureExtractor)},"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":(t,s,n)=>{n.r(s),n.d(s,{Wav2Vec2ProcessorWithLM:()=>c});var i=n("./src/tokenizers.js"),l=n("./src/models/auto/feature_extraction_auto.js"),o=n("./src/base/processing_utils.js");class c extends o.Processor{async _call(d){return await this.feature_extractor(d)}}he(c,"tokenizer_class",i.AutoTokenizer),he(c,"feature_extractor_class",l.AutoFeatureExtractor)},"./src/models/wespeaker/feature_extraction_wespeaker.js":(t,s,n)=>{n.r(s),n.d(s,{WeSpeakerFeatureExtractor:()=>o});var i=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var l=n("./src/utils/audio.js");class o extends i.FeatureExtractor{constructor(p){super(p);const d=this.config.sampling_rate,f=(0,l.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(d/2),d,null,"kaldi",!0);for(let g=0;g<f.length;++g)f[g].push(0);this.mel_filters=f,this.window=(0,l.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(p){return p=p.map(d=>d*32768),(0,l.spectrogram)(p,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1192092955078125e-22,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(p){(0,i.validate_audio_inputs)(p,"WeSpeakerFeatureExtractor");const d=(await this._extract_fbank_features(p)).unsqueeze_(0);if(this.config.fbank_centering_span===null){const f=d.mean(1).data,g=d.data,[_,y,T]=d.dims;for(let b=0;b<_;++b){const k=b*y*T,L=b*T;for(let C=0;C<y;++C){const S=k+C*T;for(let I=0;I<T;++I)g[S+I]-=f[L+I]}}}return{input_features:d}}}},"./src/models/whisper/common_whisper.js":(t,s,n)=>{n.r(s),n.d(s,{WHISPER_LANGUAGE_MAPPING:()=>l,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>o,whisper_language_to_code:()=>c});const i=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],l=new Map(i),o=new Map([...i.map(([p,d])=>[d,p]),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function c(p){p=p.toLowerCase();let d=o.get(p);if(d===void 0){const f=p.match(/^<\|([a-z]{2})\|>$/);if(f&&(p=f[1]),l.has(p))d=p;else{const _=p.length===2?l.keys():l.values();throw new Error(`Language "${p}" is not supported. Must be one of: ${JSON.stringify(Array.from(_))}`)}}return d}},"./src/models/whisper/feature_extraction_whisper.js":(t,s,n)=>{n.r(s),n.d(s,{WhisperFeatureExtractor:()=>c});var i=n("./src/base/feature_extraction_utils.js");n("./src/utils/tensor.js");var l=n("./src/utils/audio.js"),o=n("./src/utils/maths.js");class c extends i.FeatureExtractor{constructor(d){var f;super(d),(f=this.config).mel_filters??(f.mel_filters=(0,l.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney")),this.window=(0,l.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(d){const f=await(0,l.spectrogram)(d,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(d.length/this.config.hop_length),this.config.nb_max_frames)}),g=f.data,_=(0,o.max)(g)[0];for(let y=0;y<g.length;++y)g[y]=(Math.max(g[y],_-8)+4)/4;return f}async _call(d,{max_length:f=null}={}){(0,i.validate_audio_inputs)(d,"WhisperFeatureExtractor");let g;const _=f??this.config.n_samples;return d.length>_?(d.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),g=d.slice(0,_)):(g=new Float32Array(_),g.set(d)),{input_features:(await this._extract_fbank_features(g)).unsqueeze_(0)}}}},"./src/models/whisper/generation_whisper.js":(t,s,n)=>{n.r(s),n.d(s,{WhisperGenerationConfig:()=>l});var i=n("./src/generation/configuration_utils.js");class l extends i.GenerationConfig{constructor(){super(...arguments);he(this,"return_timestamps",null);he(this,"return_token_timestamps",null);he(this,"num_frames",null);he(this,"alignment_heads",null);he(this,"task",null);he(this,"language",null);he(this,"no_timestamps_token_id",null);he(this,"prompt_ids",null);he(this,"is_multilingual",null);he(this,"lang_to_id",null);he(this,"task_to_id",null);he(this,"max_initial_timestamp_index",1)}}},"./src/models/whisper/processing_whisper.js":(t,s,n)=>{n.r(s),n.d(s,{WhisperProcessor:()=>c});var i=n("./src/models/auto/feature_extraction_auto.js"),l=n("./src/tokenizers.js"),o=n("./src/base/processing_utils.js");class c extends o.Processor{async _call(d){return await this.feature_extractor(d)}}he(c,"tokenizer_class",l.AutoTokenizer),he(c,"feature_extractor_class",i.AutoFeatureExtractor)},"./src/models/yolos/image_processing_yolos.js":(t,s,n)=>{n.r(s),n.d(s,{YolosFeatureExtractor:()=>o,YolosImageProcessor:()=>l});var i=n("./src/base/image_processors_utils.js");class l extends i.ImageProcessor{post_process_object_detection(...p){return(0,i.post_process_object_detection)(...p)}}class o extends l{}},"./src/ops/registry.js":(t,s,n)=>{n.r(s),n.d(s,{TensorOpRegistry:()=>d});var i=n("./src/backends/onnx.js"),l=n("./src/utils/tensor.js"),o=n("./src/env.js");const c=o.apis.IS_BROWSER_ENV||o.apis.IS_WEBWORKER_ENV,p=async(f,g,_)=>{const y=await(0,i.createInferenceSession)(new Uint8Array(f),g);let T=Promise.resolve();return async b=>{const k=(0,i.isONNXProxy)(),L=Object.fromEntries(Object.entries(b).map(([S,I])=>[S,(k?I.clone():I).ort_tensor])),C=await(T=c?T.then(()=>y.run(L)):y.run(L));return Array.isArray(_)?_.map(S=>new l.Tensor(C[S])):new l.Tensor(C[_])}};class d{static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=p([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=p([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=p([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=p([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=p([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=p([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=p([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=p([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}he(d,"session_options",{})},"./src/pipelines.js":(t,s,n)=>{n.r(s),n.d(s,{AudioClassificationPipeline:()=>ie,AutomaticSpeechRecognitionPipeline:()=>ue,BackgroundRemovalPipeline:()=>ce,DepthEstimationPipeline:()=>re,DocumentQuestionAnsweringPipeline:()=>B,FeatureExtractionPipeline:()=>X,FillMaskPipeline:()=>I,ImageClassificationPipeline:()=>G,ImageFeatureExtractionPipeline:()=>oe,ImageSegmentationPipeline:()=>se,ImageToImagePipeline:()=>le,ImageToTextPipeline:()=>ne,ObjectDetectionPipeline:()=>W,Pipeline:()=>k,QuestionAnsweringPipeline:()=>S,SummarizationPipeline:()=>x,Text2TextGenerationPipeline:()=>O,TextClassificationPipeline:()=>L,TextGenerationPipeline:()=>F,TextToAudioPipeline:()=>Q,TokenClassificationPipeline:()=>C,TranslationPipeline:()=>E,ZeroShotAudioClassificationPipeline:()=>J,ZeroShotClassificationPipeline:()=>K,ZeroShotImageClassificationPipeline:()=>ge,ZeroShotObjectDetectionPipeline:()=>U,pipeline:()=>Be});var i=n("./src/tokenizers.js"),l=n("./src/models.js"),o=n("./src/models/auto/processing_auto.js");n("./src/base/processing_utils.js");var c=n("./src/utils/generic.js"),p=n("./src/utils/core.js"),d=n("./src/utils/maths.js"),f=n("./src/utils/audio.js"),g=n("./src/utils/tensor.js"),_=n("./src/utils/image.js");async function y(Oe){return Array.isArray(Oe)||(Oe=[Oe]),await Promise.all(Oe.map(ae=>_.RawImage.read(ae)))}async function T(Oe,ae){return Array.isArray(Oe)||(Oe=[Oe]),await Promise.all(Oe.map(Z=>typeof Z=="string"||Z instanceof URL?(0,f.read_audio)(Z,ae):Z instanceof Float64Array?new Float32Array(Z):Z))}function b(Oe,ae){ae&&(Oe=Oe.map(qe=>qe|0));const[Z,Ee,Ve,Ue]=Oe;return{xmin:Z,ymin:Ee,xmax:Ve,ymax:Ue}}class k extends c.Callable{constructor({task:ae,model:Z,tokenizer:Ee=null,processor:Ve=null}){super(),this.task=ae,this.model=Z,this.tokenizer=Ee,this.processor=Ve}async dispose(){await this.model.dispose()}}class L extends k{constructor(ae){super(ae)}async _call(ae,{top_k:Z=1}={}){const Ee=this.tokenizer(ae,{padding:!0,truncation:!0}),Ve=await this.model(Ee),Ue=this.model.config.problem_type==="multi_label_classification"?nt=>nt.sigmoid():nt=>new g.Tensor("float32",(0,d.softmax)(nt.data),nt.dims),qe=this.model.config.id2label,We=[];for(const nt of Ve.logits){const at=Ue(nt),ct=await(0,g.topk)(at,Z),V=ct[0].tolist(),q=ct[1].tolist().map((pe,we)=>({label:qe?qe[pe]:`LABEL_${pe}`,score:V[we]}));Z===1?We.push(...q):We.push(q)}return Array.isArray(ae)||Z===1?We:We[0]}}class C extends k{constructor(ae){super(ae)}async _call(ae,{ignore_labels:Z=["O"]}={}){const Ee=Array.isArray(ae),Ve=this.tokenizer(Ee?ae:[ae],{padding:!0,truncation:!0}),qe=(await this.model(Ve)).logits,We=this.model.config.id2label,nt=[];for(let at=0;at<qe.dims[0];++at){const ct=Ve.input_ids[at],V=qe[at],fe=[];for(let q=0;q<V.dims[0];++q){const pe=V[q],we=(0,d.max)(pe.data)[1],Fe=We?We[we]:`LABEL_${we}`;if(Z.includes(Fe))continue;const De=this.tokenizer.decode([ct[q].item()],{skip_special_tokens:!0});if(De==="")continue;const rt=(0,d.softmax)(pe.data);fe.push({entity:Fe,score:rt[we],index:q,word:De})}nt.push(fe)}return Ee?nt:nt[0]}}class S extends k{constructor(ae){super(ae)}async _call(ae,Z,{top_k:Ee=1}={}){const Ve=this.tokenizer(ae,{text_pair:Z,padding:!0,truncation:!0}),{start_logits:Ue,end_logits:qe}=await this.model(Ve),We=Ve.input_ids.tolist(),nt=Ve.attention_mask.tolist(),at=this.tokenizer.all_special_ids,ct=[];for(let V=0;V<Ue.dims[0];++V){const fe=We[V],q=fe.findIndex(He=>He==this.tokenizer.sep_token_id);nt[V].map((He,it)=>He==1&&(it===0||it>q&&at.findIndex(mt=>mt==fe[it])===-1));const pe=Ue[V].tolist(),we=qe[V].tolist();for(let He=1;He<pe.length;++He)(nt[V]==0||He<=q||at.findIndex(it=>it==fe[He])!==-1)&&(pe[He]=-1/0,we[He]=-1/0);const Fe=(0,d.softmax)(pe).map((He,it)=>[He,it]),De=(0,d.softmax)(we).map((He,it)=>[He,it]);Fe[0][0]=0,De[0][0]=0;const rt=(0,p.product)(Fe,De).filter(He=>He[0][1]<=He[1][1]).map(He=>[He[0][1],He[1][1],He[0][0]*He[1][0]]).sort((He,it)=>it[2]-He[2]);for(let He=0;He<Math.min(rt.length,Ee);++He){const[it,mt,_t]=rt[He],Ot=fe.slice(it,mt+1),Ft=this.tokenizer.decode(Ot,{skip_special_tokens:!0});ct.push({answer:Ft,score:_t})}}return Ee===1?ct[0]:ct}}class I extends k{constructor(ae){super(ae)}async _call(ae,{top_k:Z=5}={}){const Ee=this.tokenizer(ae,{padding:!0,truncation:!0}),{logits:Ve}=await this.model(Ee),Ue=[],qe=Ee.input_ids.tolist();for(let We=0;We<qe.length;++We){const nt=qe[We],at=nt.findIndex(pe=>pe==this.tokenizer.mask_token_id);if(at===-1)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const ct=Ve[We][at],V=await(0,g.topk)(new g.Tensor("float32",(0,d.softmax)(ct.data),ct.dims),Z),fe=V[0].tolist(),q=V[1].tolist();Ue.push(q.map((pe,we)=>{const Fe=nt.slice();return Fe[at]=pe,{score:fe[we],token:Number(pe),token_str:this.tokenizer.decode([pe]),sequence:this.tokenizer.decode(Fe,{skip_special_tokens:!0})}}))}return Array.isArray(ae)?Ue:Ue[0]}}class O extends k{constructor(Z){super(Z);he(this,"_key","generated_text")}async _call(Z,Ee={}){Array.isArray(Z)||(Z=[Z]),this.model.config.prefix&&(Z=Z.map(at=>this.model.config.prefix+at));const Ve=this.model.config.task_specific_params;Ve&&Ve[this.task]&&Ve[this.task].prefix&&(Z=Z.map(at=>Ve[this.task].prefix+at));const Ue=this.tokenizer,qe={padding:!0,truncation:!0};let We;this instanceof E&&"_build_translation_inputs"in Ue?We=Ue._build_translation_inputs(Z,qe,Ee):We=Ue(Z,qe);const nt=await this.model.generate({...We,...Ee});return Ue.batch_decode(nt,{skip_special_tokens:!0}).map(at=>({[this._key]:at}))}}class x extends O{constructor(Z){super(Z);he(this,"_key","summary_text")}}class E extends O{constructor(Z){super(Z);he(this,"_key","translation_text")}}function A(Oe){return Array.isArray(Oe)&&Oe.every(ae=>"role"in ae&&"content"in ae)}class F extends k{constructor(ae){super(ae)}async _call(ae,Z={}){let Ee=!1,Ve=!1,Ue;if(typeof ae=="string")Ue=ae=[ae];else if(Array.isArray(ae)&&ae.every(q=>typeof q=="string"))Ee=!0,Ue=ae;else{if(A(ae))ae=[ae];else if(Array.isArray(ae)&&ae.every(A))Ee=!0;else throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");Ve=!0,Ue=ae.map(q=>this.tokenizer.apply_chat_template(q,{tokenize:!1,add_generation_prompt:!0}))}const qe=Z.add_special_tokens??!1,We=Ve?!1:Z.return_full_text??!0;this.tokenizer.padding_side="left";const nt=this.tokenizer(Ue,{add_special_tokens:qe,padding:!0,truncation:!0}),at=await this.model.generate({...nt,...Z}),ct=this.tokenizer.batch_decode(at,{skip_special_tokens:!0});let V;!We&&nt.input_ids.dims.at(-1)>0&&(V=this.tokenizer.batch_decode(nt.input_ids,{skip_special_tokens:!0}).map(q=>q.length));const fe=Array.from({length:ae.length},q=>[]);for(let q=0;q<ct.length;++q){const pe=Math.floor(q/at.dims[0]*ae.length);V&&(ct[q]=ct[q].slice(V[pe])),fe[pe].push({generated_text:Ve?[...ae[pe],{role:"assistant",content:ct[q]}]:ct[q]})}return!Ee&&fe.length===1?fe[0]:fe}}class K extends k{constructor(ae){super(ae),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map(([Z,Ee])=>[Z.toLowerCase(),Ee])),this.entailment_id=this.label2id.entailment,this.entailment_id===void 0&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,this.contradiction_id===void 0&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(ae,Z,{hypothesis_template:Ee="This example is {}.",multi_label:Ve=!1}={}){const Ue=Array.isArray(ae);Ue||(ae=[ae]),Array.isArray(Z)||(Z=[Z]);const qe=Z.map(at=>Ee.replace("{}",at)),We=Ve||Z.length===1,nt=[];for(const at of ae){const ct=[];for(const q of qe){const pe=this.tokenizer(at,{text_pair:q,padding:!0,truncation:!0}),we=await this.model(pe);We?ct.push([we.logits.data[this.contradiction_id],we.logits.data[this.entailment_id]]):ct.push(we.logits.data[this.entailment_id])}const fe=(We?ct.map(q=>(0,d.softmax)(q)[1]):(0,d.softmax)(ct)).map((q,pe)=>[q,pe]).sort((q,pe)=>pe[0]-q[0]);nt.push({sequence:at,labels:fe.map(q=>Z[q[1]]),scores:fe.map(q=>q[0])})}return Ue?nt:nt[0]}}class X extends k{constructor(ae){super(ae)}async _call(ae,{pooling:Z="none",normalize:Ee=!1,quantize:Ve=!1,precision:Ue="binary"}={}){const qe=this.tokenizer(ae,{padding:!0,truncation:!0}),We=await this.model(qe);let nt=We.last_hidden_state??We.logits??We.token_embeddings;if(Z!=="none")if(Z==="mean")nt=(0,g.mean_pooling)(nt,qe.attention_mask);else if(Z==="cls")nt=nt.slice(null,0);else throw Error(`Pooling method '${Z}' not supported.`);return Ee&&(nt=nt.normalize(2,-1)),Ve&&(nt=(0,g.quantize_embeddings)(nt,Ue)),nt}}class oe extends k{constructor(ae){super(ae)}async _call(ae,{pool:Z=null}={}){const Ee=await y(ae),{pixel_values:Ve}=await this.processor(Ee),Ue=await this.model({pixel_values:Ve});let qe;if(Z){if(!("pooler_output"in Ue))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");qe=Ue.pooler_output}else qe=Ue.last_hidden_state??Ue.logits??Ue.image_embeds;return qe}}class ie extends k{constructor(ae){super(ae)}async _call(ae,{top_k:Z=5}={}){const Ee=this.processor.feature_extractor.config.sampling_rate,Ve=await T(ae,Ee),Ue=this.model.config.id2label,qe=[];for(const We of Ve){const nt=await this.processor(We),ct=(await this.model(nt)).logits[0],V=await(0,g.topk)(new g.Tensor("float32",(0,d.softmax)(ct.data),ct.dims),Z),fe=V[0].tolist(),pe=V[1].tolist().map((we,Fe)=>({label:Ue?Ue[we]:`LABEL_${we}`,score:fe[Fe]}));qe.push(pe)}return Array.isArray(ae)?qe:qe[0]}}class J extends k{constructor(ae){super(ae)}async _call(ae,Z,{hypothesis_template:Ee="This is a sound of {}."}={}){const Ve=!Array.isArray(ae);Ve&&(ae=[ae]);const Ue=Z.map(ct=>Ee.replace("{}",ct)),qe=this.tokenizer(Ue,{padding:!0,truncation:!0}),We=this.processor.feature_extractor.config.sampling_rate,nt=await T(ae,We),at=[];for(const ct of nt){const V=await this.processor(ct),fe=await this.model({...qe,...V}),q=(0,d.softmax)(fe.logits_per_audio.data);at.push([...q].map((pe,we)=>({score:pe,label:Z[we]})))}return Ve?at[0]:at}}class ue extends k{constructor(ae){super(ae)}async _call(ae,Z={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(ae,Z);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(ae,Z);case"moonshine":return this._call_moonshine(ae,Z);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(ae,Z){Z.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),Z.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const Ee=!Array.isArray(ae);Ee&&(ae=[ae]);const Ve=this.processor.feature_extractor.config.sampling_rate,Ue=await T(ae,Ve),qe=[];for(const We of Ue){const nt=await this.processor(We),ct=(await this.model(nt)).logits[0],V=[];for(const q of ct)V.push((0,d.max)(q.data)[1]);const fe=this.tokenizer.decode(V);qe.push({text:fe})}return Ee?qe[0]:qe}async _call_whisper(ae,Z){const Ee=Z.return_timestamps??!1,Ve=Z.chunk_length_s??0,Ue=Z.force_full_sequences??!1;let qe=Z.stride_length_s??null;const We={...Z};Ee==="word"&&(We.return_token_timestamps=!0,We.return_timestamps=!1);const nt=!Array.isArray(ae);nt&&(ae=[ae]);const at=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,ct=this.processor.feature_extractor.config.hop_length,V=this.processor.feature_extractor.config.sampling_rate,fe=await T(ae,V),q=[];for(const pe of fe){let we=[];if(Ve>0){if(qe===null)qe=Ve/6;else if(Ve<=qe)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const rt=V*Ve,He=V*qe,it=rt-2*He;let mt=0;for(;;){const _t=mt+rt,Ot=pe.subarray(mt,_t),Ft=await this.processor(Ot),Dn=mt===0,hn=_t>=pe.length;if(we.push({stride:[Ot.length,Dn?0:He,hn?0:He],input_features:Ft.input_features,is_last:hn}),hn)break;mt+=it}}else we=[{stride:[pe.length,0,0],input_features:(await this.processor(pe)).input_features,is_last:!0}];for(const rt of we){We.num_frames=Math.floor(rt.stride[0]/ct);const He=await this.model.generate({inputs:rt.input_features,...We});Ee==="word"?(rt.tokens=He.sequences.tolist()[0],rt.token_timestamps=He.token_timestamps.tolist()[0].map(it=>(0,d.round)(it,2))):rt.tokens=He[0].tolist(),rt.stride=rt.stride.map(it=>it/V)}const[Fe,De]=this.tokenizer._decode_asr(we,{time_precision:at,return_timestamps:Ee,force_full_sequences:Ue});q.push({text:Fe,...De})}return nt?q[0]:q}async _call_moonshine(ae,Z){const Ee=!Array.isArray(ae);Ee&&(ae=[ae]);const Ve=this.processor.feature_extractor.config.sampling_rate,Ue=await T(ae,Ve),qe=[];for(const We of Ue){const nt=await this.processor(We),at=Math.floor(We.length/Ve)*6,ct=await this.model.generate({max_new_tokens:at,...Z,...nt}),V=this.processor.batch_decode(ct,{skip_special_tokens:!0})[0];qe.push({text:V})}return Ee?qe[0]:qe}}class ne extends k{constructor(ae){super(ae)}async _call(ae,Z={}){const Ee=Array.isArray(ae),Ve=await y(ae),{pixel_values:Ue}=await this.processor(Ve),qe=[];for(const We of Ue){We.dims=[1,...We.dims];const nt=await this.model.generate({inputs:We,...Z}),at=this.tokenizer.batch_decode(nt,{skip_special_tokens:!0}).map(ct=>({generated_text:ct.trim()}));qe.push(at)}return Ee?qe:qe[0]}}class G extends k{constructor(ae){super(ae)}async _call(ae,{top_k:Z=5}={}){const Ee=await y(ae),{pixel_values:Ve}=await this.processor(Ee),Ue=await this.model({pixel_values:Ve}),qe=this.model.config.id2label,We=[];for(const nt of Ue.logits){const at=await(0,g.topk)(new g.Tensor("float32",(0,d.softmax)(nt.data),nt.dims),Z),ct=at[0].tolist(),fe=at[1].tolist().map((q,pe)=>({label:qe?qe[q]:`LABEL_${q}`,score:ct[pe]}));We.push(fe)}return Array.isArray(ae)?We:We[0]}}class se extends k{constructor(ae){super(ae),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(ae,{threshold:Z=.5,mask_threshold:Ee=.5,overlap_mask_area_threshold:Ve=.8,label_ids_to_fuse:Ue=null,target_sizes:qe=null,subtask:We=null}={}){if(Array.isArray(ae)&&ae.length!==1)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const at=await y(ae),ct=at.map(rt=>[rt.height,rt.width]),V=await this.processor(at),{inputNames:fe,outputNames:q}=this.model.sessions.model;if(!fe.includes("pixel_values")){if(fe.length!==1)throw Error(`Expected a single input name, but got ${fe.length} inputs: ${fe}.`);const rt=fe[0];if(rt in V)throw Error(`Input name ${rt} already exists in the inputs.`);V[rt]=V.pixel_values}const pe=await this.model(V);let we=null;if(We!==null)we=this.subtasks_mapping[We];else if(this.processor.image_processor){for(const[rt,He]of Object.entries(this.subtasks_mapping))if(He in this.processor.image_processor){we=this.processor.image_processor[He].bind(this.processor.image_processor),We=rt;break}}const Fe=this.model.config.id2label,De=[];if(We)if(We==="panoptic"||We==="instance"){const rt=we(pe,Z,Ee,Ve,Ue,qe??ct)[0],He=rt.segmentation;for(const it of rt.segments_info){const mt=new Uint8ClampedArray(He.data.length);for(let Ot=0;Ot<He.data.length;++Ot)He.data[Ot]===it.id&&(mt[Ot]=255);const _t=new _.RawImage(mt,He.dims[1],He.dims[0],1);De.push({score:it.score,label:Fe[it.label_id],mask:_t})}}else if(We==="semantic"){const{segmentation:rt,labels:He}=we(pe,qe??ct)[0];for(const it of He){const mt=new Uint8ClampedArray(rt.data.length);for(let Ot=0;Ot<rt.data.length;++Ot)rt.data[Ot]===it&&(mt[Ot]=255);const _t=new _.RawImage(mt,rt.dims[1],rt.dims[0],1);De.push({score:null,label:Fe[it],mask:_t})}}else throw Error(`Subtask ${We} not supported.`);else{const He=pe[q[0]];for(let it=0;it<ct.length;++it){const mt=ct[it],_t=He[it];_t.data.some(Ft=>Ft<-1e-5||Ft>1+1e-5)&&_t.sigmoid_();const Ot=await _.RawImage.fromTensor(_t.mul_(255).to("uint8")).resize(mt[1],mt[0]);De.push({label:null,score:null,mask:Ot})}}return De}}class ce extends se{constructor(ae){super(ae)}async _call(ae,Z={}){if(Array.isArray(ae)&&ae.length!==1)throw Error("Background removal pipeline currently only supports a batch size of 1.");const Ve=await y(ae),Ue=await super._call(ae,Z);return Ve.map((We,nt)=>{const at=We.clone();return at.putAlpha(Ue[nt].mask),at})}}class ge extends k{constructor(ae){super(ae)}async _call(ae,Z,{hypothesis_template:Ee="This is a photo of {}"}={}){const Ve=Array.isArray(ae),Ue=await y(ae),qe=Z.map(fe=>Ee.replace("{}",fe)),We=this.tokenizer(qe,{padding:this.model.config.model_type==="siglip"?"max_length":!0,truncation:!0}),{pixel_values:nt}=await this.processor(Ue),at=await this.model({...We,pixel_values:nt}),ct=this.model.config.model_type==="siglip"?fe=>fe.sigmoid().data:fe=>(0,d.softmax)(fe.data),V=[];for(const fe of at.logits_per_image){const pe=[...ct(fe)].map((we,Fe)=>({score:we,label:Z[Fe]}));pe.sort((we,Fe)=>Fe.score-we.score),V.push(pe)}return Ve?V:V[0]}}class W extends k{constructor(ae){super(ae)}async _call(ae,{threshold:Z=.9,percentage:Ee=!1}={}){const Ve=Array.isArray(ae);if(Ve&&ae.length!==1)throw Error("Object detection pipeline currently only supports a batch size of 1.");const Ue=await y(ae),qe=Ee?null:Ue.map(q=>[q.height,q.width]),{pixel_values:We,pixel_mask:nt}=await this.processor(Ue),at=await this.model({pixel_values:We,pixel_mask:nt}),ct=this.processor.image_processor.post_process_object_detection(at,Z,qe),V=this.model.config.id2label,fe=ct.map(q=>q.boxes.map((pe,we)=>({score:q.scores[we],label:V[q.classes[we]],box:b(pe,!Ee)})));return Ve?fe:fe[0]}}class U extends k{constructor(ae){super(ae)}async _call(ae,Z,{threshold:Ee=.1,top_k:Ve=null,percentage:Ue=!1}={}){const qe=Array.isArray(ae),We=await y(ae),nt=this.tokenizer(Z,{padding:!0,truncation:!0}),at=await this.processor(We),ct=[];for(let V=0;V<We.length;++V){const fe=We[V],q=Ue?null:[[fe.height,fe.width]],pe=at.pixel_values[V].unsqueeze_(0),we=await this.model({...nt,pixel_values:pe});let Fe;if("post_process_grounded_object_detection"in this.processor){const De=this.processor.post_process_grounded_object_detection(we,nt.input_ids,{box_threshold:Ee,text_threshold:Ee,target_sizes:q})[0];Fe=De.boxes.map((rt,He)=>({score:De.scores[He],label:De.labels[He],box:b(rt,!Ue)}))}else{const De=this.processor.image_processor.post_process_object_detection(we,Ee,q,!0)[0];Fe=De.boxes.map((rt,He)=>({score:De.scores[He],label:Z[De.classes[He]],box:b(rt,!Ue)}))}Fe.sort((De,rt)=>rt.score-De.score),Ve!==null&&(Fe=Fe.slice(0,Ve)),ct.push(Fe)}return qe?ct:ct[0]}}class B extends k{constructor(ae){super(ae)}async _call(ae,Z,Ee={}){const Ve=(await y(ae))[0],{pixel_values:Ue}=await this.processor(Ve),qe=`<s_docvqa><s_question>${Z}</s_question><s_answer>`,We=this.tokenizer(qe,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,nt=await this.model.generate({inputs:Ue,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:We,...Ee}),ct=this.tokenizer.batch_decode(nt)[0].match(/<s_answer>(.*?)<\/s_answer>/);let V=null;return ct&&ct.length>=2&&(V=ct[1].trim()),[{answer:V}]}}class Q extends k{constructor(Z){super(Z);he(this,"DEFAULT_VOCODER_ID","Xenova/speecht5_hifigan");this.vocoder=Z.vocoder??null}async _call(Z,{speaker_embeddings:Ee=null}={}){return this.processor?this._call_text_to_spectrogram(Z,{speaker_embeddings:Ee}):this._call_text_to_waveform(Z)}async _call_text_to_waveform(Z){const Ee=this.tokenizer(Z,{padding:!0,truncation:!0}),{waveform:Ve}=await this.model(Ee),Ue=this.model.config.sampling_rate;return new f.RawAudio(Ve.data,Ue)}async _call_text_to_spectrogram(Z,{speaker_embeddings:Ee}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await l.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),(typeof Ee=="string"||Ee instanceof URL)&&(Ee=new Float32Array(await(await fetch(Ee)).arrayBuffer())),Ee instanceof Float32Array)Ee=new g.Tensor("float32",Ee,[1,Ee.length]);else if(!(Ee instanceof g.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:Ve}=this.tokenizer(Z,{padding:!0,truncation:!0}),{waveform:Ue}=await this.model.generate_speech(Ve,Ee,{vocoder:this.vocoder}),qe=this.processor.feature_extractor.config.sampling_rate;return new f.RawAudio(Ue.data,qe)}}class le extends k{constructor(ae){super(ae)}async _call(ae){const Z=await y(ae),Ee=await this.processor(Z),Ve=await this.model(Ee),Ue=[];for(const qe of Ve.reconstruction){const We=qe.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");Ue.push(_.RawImage.fromTensor(We))}return Ue.length>1?Ue:Ue[0]}}class re extends k{constructor(ae){super(ae)}async _call(ae){const Z=await y(ae),Ee=await this.processor(Z),{predicted_depth:Ve}=await this.model(Ee),Ue=[];for(let qe=0;qe<Z.length;++qe){const We=Ve[qe],[nt,at]=We.dims.slice(-2),[ct,V]=Z[qe].size,fe=(await(0,g.interpolate_4d)(We.view(1,1,nt,at),{size:[V,ct],mode:"bilinear"})).view(V,ct),q=fe.min().item(),pe=fe.max().item(),we=fe.sub(q).div_(pe-q).mul_(255).to("uint8").unsqueeze(0),Fe=_.RawImage.fromTensor(we);Ue.push({predicted_depth:fe,depth:Fe})}return Ue.length>1?Ue:Ue[0]}}const ve=Object.freeze({"text-classification":{tokenizer:i.AutoTokenizer,pipeline:L,model:l.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:i.AutoTokenizer,pipeline:C,model:l.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:i.AutoTokenizer,pipeline:S,model:l.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:i.AutoTokenizer,pipeline:I,model:l.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:i.AutoTokenizer,pipeline:x,model:l.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:i.AutoTokenizer,pipeline:E,model:l.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:i.AutoTokenizer,pipeline:O,model:l.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:i.AutoTokenizer,pipeline:F,model:l.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:i.AutoTokenizer,pipeline:K,model:l.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:ie,model:l.AutoModelForAudioClassification,processor:o.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:i.AutoTokenizer,pipeline:J,model:l.AutoModel,processor:o.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:i.AutoTokenizer,pipeline:ue,model:[l.AutoModelForSpeechSeq2Seq,l.AutoModelForCTC],processor:o.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:i.AutoTokenizer,pipeline:Q,model:[l.AutoModelForTextToWaveform,l.AutoModelForTextToSpectrogram],processor:[o.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:i.AutoTokenizer,pipeline:ne,model:l.AutoModelForVision2Seq,processor:o.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:G,model:l.AutoModelForImageClassification,processor:o.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:se,model:[l.AutoModelForImageSegmentation,l.AutoModelForSemanticSegmentation,l.AutoModelForUniversalSegmentation],processor:o.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:ce,model:[l.AutoModelForImageSegmentation,l.AutoModelForSemanticSegmentation,l.AutoModelForUniversalSegmentation],processor:o.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:i.AutoTokenizer,pipeline:ge,model:l.AutoModel,processor:o.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:W,model:l.AutoModelForObjectDetection,processor:o.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:i.AutoTokenizer,pipeline:U,model:l.AutoModelForZeroShotObjectDetection,processor:o.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:i.AutoTokenizer,pipeline:B,model:l.AutoModelForDocumentQuestionAnswering,processor:o.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:le,model:l.AutoModelForImageToImage,processor:o.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:re,model:l.AutoModelForDepthEstimation,processor:o.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:i.AutoTokenizer,pipeline:X,model:l.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:o.AutoProcessor,pipeline:oe,model:[l.AutoModelForImageFeatureExtraction,l.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),Se=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function Be(Oe,ae=null,{progress_callback:Z=null,config:Ee=null,cache_dir:Ve=null,local_files_only:Ue=!1,revision:qe="main",device:We=null,dtype:nt=null,subfolder:at="onnx",use_external_data_format:ct=null,model_file_name:V=null,session_options:fe={}}={}){Oe=Se[Oe]??Oe;const q=ve[Oe.split("_",1)[0]];if(!q)throw Error(`Unsupported pipeline: ${Oe}. Must be one of [${Object.keys(ve)}]`);ae||(ae=q.default.model,console.log(`No model specified. Using default model: "${ae}".`));const pe={progress_callback:Z,config:Ee,cache_dir:Ve,local_files_only:Ue,revision:qe,device:We,dtype:nt,subfolder:at,use_external_data_format:ct,model_file_name:V,session_options:fe},we=new Map([["tokenizer",q.tokenizer],["model",q.model],["processor",q.processor]]),Fe=await ut(we,ae,pe);Fe.task=Oe,(0,p.dispatchCallback)(Z,{status:"ready",task:Oe,model:ae});const De=q.pipeline;return new De(Fe)}async function ut(Oe,ae,Z){const Ee=Object.create(null),Ve=[];for(const[Ue,qe]of Oe.entries()){if(!qe)continue;let We;Array.isArray(qe)?We=new Promise(async(nt,at)=>{var V,fe;let ct;for(const q of qe){if(q===null){nt(null);return}try{nt(await q.from_pretrained(ae,Z));return}catch(pe){if((V=pe.message)!=null&&V.includes("Unsupported model type"))ct=pe;else if((fe=pe.message)!=null&&fe.includes("Could not locate file"))ct=pe;else{at(pe);return}}}at(ct)}):We=qe.from_pretrained(ae,Z),Ee[Ue]=We,Ve.push(We)}await Promise.all(Ve);for(const[Ue,qe]of Object.entries(Ee))Ee[Ue]=await qe;return Ee}},"./src/tokenizers.js":(t,s,n)=>{n.r(s),n.d(s,{AlbertTokenizer:()=>Kr,AutoTokenizer:()=>Ci,BartTokenizer:()=>Fr,BertTokenizer:()=>ys,BlenderbotSmallTokenizer:()=>Yr,BlenderbotTokenizer:()=>Xr,BloomTokenizer:()=>Pn,CLIPTokenizer:()=>uo,CamembertTokenizer:()=>Et,CodeGenTokenizer:()=>os,CodeLlamaTokenizer:()=>as,CohereTokenizer:()=>Er,ConvBertTokenizer:()=>mn,DebertaTokenizer:()=>ya,DebertaV2Tokenizer:()=>Pr,DistilBertTokenizer:()=>yt,ElectraTokenizer:()=>_n,EsmTokenizer:()=>Si,FalconTokenizer:()=>Ds,GPT2Tokenizer:()=>vs,GPTNeoXTokenizer:()=>Va,GemmaTokenizer:()=>Ar,Grok1Tokenizer:()=>Tr,HerbertTokenizer:()=>Nn,LlamaTokenizer:()=>Ua,M2M100Tokenizer:()=>is,MBart50Tokenizer:()=>qr,MBartTokenizer:()=>rr,MPNetTokenizer:()=>Ei,MarianTokenizer:()=>xr,MgpstrTokenizer:()=>Is,MobileBertTokenizer:()=>Ms,NllbTokenizer:()=>Ma,NougatTokenizer:()=>sr,PreTrainedTokenizer:()=>Pt,Qwen2Tokenizer:()=>qs,RoFormerTokenizer:()=>st,RobertaTokenizer:()=>Lr,SiglipTokenizer:()=>Qr,SpeechT5Tokenizer:()=>lr,SqueezeBertTokenizer:()=>Hs,T5Tokenizer:()=>mr,TokenizerModel:()=>oe,VitsTokenizer:()=>Ga,Wav2Vec2CTCTokenizer:()=>va,WhisperTokenizer:()=>$r,XLMRobertaTokenizer:()=>ws,XLMTokenizer:()=>Qn,is_chinese_char:()=>I});var i=n("./src/utils/generic.js"),l=n("./src/utils/core.js"),o=n("./src/utils/hub.js"),c=n("./src/utils/maths.js"),p=n("./src/utils/tensor.js"),d=n("./src/utils/data-structures.js"),f=n("./node_modules/@huggingface/jinja/dist/index.js"),g=n("./src/models/whisper/common_whisper.js");async function _(Te,N){const ee=await Promise.all([(0,o.getModelJSON)(Te,"tokenizer.json",!0,N),(0,o.getModelJSON)(Te,"tokenizer_config.json",!0,N)]);return N.legacy!==null&&(ee[1].legacy=N.legacy),ee}function y(Te,N){const ee=[];let de=0;for(const Me of Te.matchAll(N)){const xe=Me[0];de<Me.index&&ee.push(Te.slice(de,Me.index)),xe.length>0&&ee.push(xe),de=Me.index+xe.length}return de<Te.length&&ee.push(Te.slice(de)),ee}function T(Te,N=!0){if(Te.Regex!==void 0){let ee=Te.Regex.replace(/\\([#&~])/g,"$1");for(const[de,Me]of K)ee=ee.replaceAll(de,Me);return new RegExp(ee,"gu")}else if(Te.String!==void 0){const ee=(0,l.escapeRegExp)(Te.String);return new RegExp(N?ee:`(${ee})`,"gu")}else return console.warn("Unknown pattern type:",Te),null}function b(Te){return new Map(Object.entries(Te))}function k(Te){const N=Te.dims;switch(N.length){case 1:return Te.tolist();case 2:if(N[0]!==1)throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return Te.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${N.length}.`)}}function L(Te){return Te.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function C(Te){return Te.replace(new RegExp("\\p{M}","gu"),"")}function S(Te){return C(Te.toLowerCase())}function I(Te){return Te>=19968&&Te<=40959||Te>=13312&&Te<=19903||Te>=131072&&Te<=173791||Te>=173824&&Te<=177983||Te>=177984&&Te<=178207||Te>=178208&&Te<=183983||Te>=63744&&Te<=64255||Te>=194560&&Te<=195103}function O(Te,N,ee){const de=[];let Me=0;for(;Me<Te.length;){if(de.push(Te[Me]),(N.get(Te[Me])??ee)!==ee){++Me;continue}for(;++Me<Te.length&&(N.get(Te[Me])??ee)===ee;)N.get(de.at(-1))!==ee&&(de[de.length-1]+=Te[Me])}return de}function x(Te){return Te.match(/\S+/g)||[]}const E="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",A=new RegExp(`^[${E}]+$`,"gu"),F=".,!?…。，、।۔،",K=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${F}])]+`,` ?[^\\s${F}]+`]]);class X{constructor(N){this.content=N.content,this.id=N.id,this.single_word=N.single_word??!1,this.lstrip=N.lstrip??!1,this.rstrip=N.rstrip??!1,this.special=N.special??!1,this.normalized=N.normalized??null}}class oe extends i.Callable{constructor(N){super(),this.config=N,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(N,...ee){switch(N.type){case"WordPiece":return new ie(N);case"Unigram":return new J(N,...ee);case"BPE":return new G(N);default:if(N.vocab)return Array.isArray(N.vocab)?new J(N,...ee):typeof N.vocab=="object"&&N.continuing_subword_prefix&&N.unk_token?new ie(N):new se(N,...ee);throw new Error(`Unknown TokenizerModel type: ${N.type}`)}}_call(N){return N=this.encode(N),this.fuse_unk&&(N=O(N,this.tokens_to_ids,this.unk_token_id)),N}encode(N){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(N){return N.map(ee=>this.tokens_to_ids.get(ee)??this.unk_token_id)}convert_ids_to_tokens(N){return N.map(ee=>this.vocab[ee]??this.unk_token)}}class ie extends oe{constructor(N){super(N),this.tokens_to_ids=b(N.vocab),this.unk_token_id=this.tokens_to_ids.get(N.unk_token),this.unk_token=N.unk_token,this.max_input_chars_per_word=N.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[ee,de]of this.tokens_to_ids)this.vocab[de]=ee}encode(N){const ee=[];for(const de of N){const Me=[...de];if(Me.length>this.max_input_chars_per_word){ee.push(this.unk_token);continue}let xe=!1,Ge=0;const lt=[];for(;Ge<Me.length;){let ht=Me.length,ft=null;for(;Ge<ht;){let Mt=Me.slice(Ge,ht).join("");if(Ge>0&&(Mt=this.config.continuing_subword_prefix+Mt),this.tokens_to_ids.has(Mt)){ft=Mt;break}--ht}if(ft===null){xe=!0;break}lt.push(ft),Ge=ht}xe?ee.push(this.unk_token):ee.push(...lt)}return ee}}class J extends oe{constructor(N,ee){super(N);const de=N.vocab.length;this.vocab=new Array(de),this.scores=new Array(de);for(let Me=0;Me<de;++Me)[this.vocab[Me],this.scores[Me]]=N.vocab[Me];this.unk_token_id=N.unk_id,this.unk_token=this.vocab[N.unk_id],this.tokens_to_ids=new Map(this.vocab.map((Me,xe)=>[Me,xe])),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=ee.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,c.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new d.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(N){const ee=N.chars,de=1;let Me=0;for(;Me<ee.length;){let xe=!1;const Ge=ee.slice(Me).join(""),lt=this.trie.commonPrefixSearch(Ge);for(const ht of lt){const ft=this.tokens_to_ids.get(ht),Mt=this.scores[ft],kt=(0,l.len)(ht);N.insert(Me,kt,Mt,ft),!xe&&kt===de&&(xe=!0)}xe||N.insert(Me,de,this.unk_score,this.unk_token_id),Me+=de}}tokenize(N){const ee=new d.TokenLattice(N,this.bos_token_id,this.eos_token_id);return this.populateNodes(ee),ee.tokens()}encode(N){const ee=[];for(const de of N){const Me=this.tokenize(de);ee.push(...Me)}return ee}}const ue=(()=>{const Te=[...Array.from({length:94},(Me,xe)=>xe+33),...Array.from({length:12},(Me,xe)=>xe+161),...Array.from({length:82},(Me,xe)=>xe+174)],N=Te.slice();let ee=0;for(let Me=0;Me<256;++Me)Te.includes(Me)||(Te.push(Me),N.push(256+ee),ee+=1);const de=N.map(Me=>String.fromCharCode(Me));return Object.fromEntries(Te.map((Me,xe)=>[Me,de[xe]]))})(),ne=(0,l.reverseDictionary)(ue);class G extends oe{constructor(N){super(N),this.tokens_to_ids=b(N.vocab),this.unk_token_id=this.tokens_to_ids.get(N.unk_token),this.unk_token=N.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[de,Me]of this.tokens_to_ids)this.vocab[Me]=de;const ee=Array.isArray(N.merges[0]);this.merges=ee?N.merges:N.merges.map(de=>de.split(" ",2)),this.bpe_ranks=new Map(this.merges.map((de,Me)=>[JSON.stringify(de),Me])),this.end_of_word_suffix=N.end_of_word_suffix,this.continuing_subword_suffix=N.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(N){if(N.length===0)return[];const ee=this.cache.get(N);if(ee!==void 0)return ee;const de=Array.from(N);this.end_of_word_suffix&&(de[de.length-1]+=this.end_of_word_suffix);let Me=[];if(de.length>1){const xe=new d.PriorityQueue((ht,ft)=>ht.score<ft.score);let Ge={token:de[0],bias:0,prev:null,next:null},lt=Ge;for(let ht=1;ht<de.length;++ht){const ft={bias:ht/de.length,token:de[ht],prev:lt,next:null};lt.next=ft,this._add_node(xe,lt),lt=ft}for(;!xe.isEmpty();){const ht=xe.pop();if(ht.deleted||!ht.next||ht.next.deleted)continue;if(ht.deleted=!0,ht.next.deleted=!0,ht.prev){const Mt={...ht.prev};ht.prev.deleted=!0,ht.prev=Mt,Mt.prev?Mt.prev.next=Mt:Ge=Mt}const ft={token:ht.token+ht.next.token,bias:ht.bias,prev:ht.prev,next:ht.next.next};ft.prev?(ft.prev.next=ft,this._add_node(xe,ft.prev)):Ge=ft,ft.next&&(ft.next.prev=ft,this._add_node(xe,ft))}for(let ht=Ge;ht!==null;ht=ht.next)Me.push(ht.token)}else Me=de;if(this.continuing_subword_suffix)for(let xe=0;xe<Me.length-1;++xe)Me[xe]+=this.continuing_subword_suffix;return this.cache.set(N,Me),Me}_add_node(N,ee){const de=this.bpe_ranks.get(JSON.stringify([ee.token,ee.next.token]));de!==void 0&&(ee.score=de+ee.bias,N.push(ee))}encode(N){const ee=[];for(const de of N){if(this.ignore_merges&&this.tokens_to_ids.has(de)){ee.push(de);continue}const Me=this.bpe(de);for(const xe of Me)if(this.tokens_to_ids.has(xe))ee.push(xe);else if(this.byte_fallback){const Ge=Array.from(this.text_encoder.encode(xe)).map(lt=>`<0x${lt.toString(16).toUpperCase().padStart(2,"0")}>`);Ge.every(lt=>this.tokens_to_ids.has(lt))?ee.push(...Ge):ee.push(this.unk_token)}else ee.push(this.unk_token)}return ee}}class se extends oe{constructor(N,ee){super(N),this.tokens_to_ids=b(ee.target_lang?N.vocab[ee.target_lang]:N.vocab),this.bos_token=ee.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=ee.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=ee.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=ee.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[de,Me]of this.tokens_to_ids)this.vocab[Me]=de}encode(N){return N}}class ce extends i.Callable{constructor(N){super(),this.config=N}static fromConfig(N){if(N===null)return null;switch(N.type){case"BertNormalizer":return new Oe(N);case"Precompiled":return new hn(N);case"Sequence":return new ut(N);case"Replace":return new ge(N);case"NFC":return new U(N);case"NFD":return new B(N);case"NFKC":return new Q(N);case"NFKD":return new le(N);case"Strip":return new re(N);case"StripAccents":return new ve(N);case"Lowercase":return new Se(N);case"Prepend":return new Be(N);default:throw new Error(`Unknown Normalizer type: ${N.type}`)}}normalize(N){throw Error("normalize should be implemented in subclass.")}_call(N){return this.normalize(N)}}class ge extends ce{normalize(N){const ee=T(this.config.pattern);return ee===null?N:N.replaceAll(ee,this.config.content)}}class W extends ce{constructor(){super(...arguments);he(this,"form")}normalize(ee){return ee=ee.normalize(this.form),ee}}class U extends W{constructor(){super(...arguments);he(this,"form","NFC")}}class B extends W{constructor(){super(...arguments);he(this,"form","NFD")}}class Q extends W{constructor(){super(...arguments);he(this,"form","NFKC")}}class le extends W{constructor(){super(...arguments);he(this,"form","NFKD")}}class re extends ce{normalize(N){return this.config.strip_left&&this.config.strip_right?N=N.trim():(this.config.strip_left&&(N=N.trimStart()),this.config.strip_right&&(N=N.trimEnd())),N}}class ve extends ce{normalize(N){return N=C(N),N}}class Se extends ce{normalize(N){return N=N.toLowerCase(),N}}class Be extends ce{normalize(N){return N=this.config.prepend+N,N}}class ut extends ce{constructor(N){super(N),this.normalizers=N.normalizers.map(ee=>ce.fromConfig(ee))}normalize(N){return this.normalizers.reduce((ee,de)=>de.normalize(ee),N)}}class Oe extends ce{_tokenize_chinese_chars(N){const ee=[];for(let de=0;de<N.length;++de){const Me=N[de],xe=Me.charCodeAt(0);I(xe)?(ee.push(" "),ee.push(Me),ee.push(" ")):ee.push(Me)}return ee.join("")}stripAccents(N){return N.normalize("NFD").replace(new RegExp("\\p{Mn}","gu"),"")}_is_control(N){switch(N){case"	":case`
`:case"\r":return!1;default:return new RegExp("^\\p{Cc}|\\p{Cf}|\\p{Co}|\\p{Cs}$","u").test(N)}}_clean_text(N){const ee=[];for(const de of N){const Me=de.charCodeAt(0);Me===0||Me===65533||this._is_control(de)||(/^\s$/.test(de)?ee.push(" "):ee.push(de))}return ee.join("")}normalize(N){return this.config.clean_text&&(N=this._clean_text(N)),this.config.handle_chinese_chars&&(N=this._tokenize_chinese_chars(N)),this.config.lowercase?(N=N.toLowerCase(),this.config.strip_accents!==!1&&(N=this.stripAccents(N))):this.config.strip_accents&&(N=this.stripAccents(N)),N}}class ae extends i.Callable{static fromConfig(N){if(N===null)return null;switch(N.type){case"BertPreTokenizer":return new Z(N);case"Sequence":return new Kn(N);case"Whitespace":return new Ws(N);case"WhitespaceSplit":return new ga(N);case"Metaspace":return new Ft(N);case"ByteLevel":return new Ee(N);case"Split":return new Ve(N);case"Punctuation":return new Ue(N);case"Digits":return new qe(N);case"Replace":return new Hr(N);default:throw new Error(`Unknown PreTokenizer type: ${N.type}`)}}pre_tokenize_text(N,ee){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(N,ee){return(Array.isArray(N)?N.map(de=>this.pre_tokenize_text(de,ee)):this.pre_tokenize_text(N,ee)).flat()}_call(N,ee){return this.pre_tokenize(N,ee)}}class Z extends ae{constructor(N){super(),this.pattern=new RegExp(`[^\\s${E}]+|[${E}]`,"gu")}pre_tokenize_text(N,ee){return N.trim().match(this.pattern)||[]}}class Ee extends ae{constructor(N){super(),this.config=N,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=new RegExp("'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+","gu"),this.byte_encoder=ue,this.text_encoder=new TextEncoder}pre_tokenize_text(N,ee){return this.add_prefix_space&&!N.startsWith(" ")&&(N=" "+N),(this.use_regex?N.match(this.pattern)||[]:[N]).map(Me=>Array.from(this.text_encoder.encode(Me),xe=>this.byte_encoder[xe]).join(""))}}class Ve extends ae{constructor(N){super(),this.config=N,this.pattern=T(this.config.pattern,this.config.invert)}pre_tokenize_text(N,ee){var de;return this.pattern===null?[]:this.config.invert?N.match(this.pattern)||[]:((de=this.config.behavior)==null?void 0:de.toLowerCase())==="removed"?N.split(this.pattern).filter(Me=>Me):y(N,this.pattern)}}class Ue extends ae{constructor(N){super(),this.config=N,this.pattern=new RegExp(`[^${E}]+|[${E}]+`,"gu")}pre_tokenize_text(N,ee){return N.match(this.pattern)||[]}}class qe extends ae{constructor(N){super(),this.config=N;const ee=`[^\\d]+|\\d${this.config.individual_digits?"":"+"}`;this.pattern=new RegExp(ee,"gu")}pre_tokenize_text(N,ee){return N.match(this.pattern)||[]}}class We extends i.Callable{constructor(N){super(),this.config=N}static fromConfig(N){if(N===null)return null;switch(N.type){case"TemplateProcessing":return new ct(N);case"ByteLevel":return new V(N);case"RobertaProcessing":return new at(N);case"BertProcessing":return new nt(N);case"Sequence":return new fe(N);default:throw new Error(`Unknown PostProcessor type: ${N.type}`)}}post_process(N,...ee){throw Error("post_process should be implemented in subclass.")}_call(N,...ee){return this.post_process(N,...ee)}}class nt extends We{constructor(N){super(N),this.cls=N.cls[0],this.sep=N.sep[0]}post_process(N,ee=null,{add_special_tokens:de=!0}={}){de&&(N=(0,l.mergeArrays)([this.cls],N,[this.sep]));let Me=new Array(N.length).fill(0);if(ee!==null){const xe=de&&this instanceof at?[this.sep]:[],Ge=de?[this.sep]:[];N=(0,l.mergeArrays)(N,xe,ee,Ge),Me=(0,l.mergeArrays)(Me,new Array(ee.length+xe.length+Ge.length).fill(1))}return{tokens:N,token_type_ids:Me}}}class at extends nt{}class ct extends We{constructor(N){super(N),this.single=N.single,this.pair=N.pair}post_process(N,ee=null,{add_special_tokens:de=!0}={}){const Me=ee===null?this.single:this.pair;let xe=[],Ge=[];for(const lt of Me)"SpecialToken"in lt?de&&(xe.push(lt.SpecialToken.id),Ge.push(lt.SpecialToken.type_id)):"Sequence"in lt&&(lt.Sequence.id==="A"?(xe=(0,l.mergeArrays)(xe,N),Ge=(0,l.mergeArrays)(Ge,new Array(N.length).fill(lt.Sequence.type_id))):lt.Sequence.id==="B"&&(xe=(0,l.mergeArrays)(xe,ee),Ge=(0,l.mergeArrays)(Ge,new Array(ee.length).fill(lt.Sequence.type_id))));return{tokens:xe,token_type_ids:Ge}}}class V extends We{post_process(N,ee=null){return ee&&(N=(0,l.mergeArrays)(N,ee)),{tokens:N}}}class fe extends We{constructor(N){super(N),this.processors=N.processors.map(ee=>We.fromConfig(ee))}post_process(N,ee=null,de={}){let Me;for(const xe of this.processors)if(xe instanceof V)N=xe.post_process(N).tokens,ee&&(ee=xe.post_process(ee).tokens);else{const Ge=xe.post_process(N,ee,de);N=Ge.tokens,Me=Ge.token_type_ids}return{tokens:N,token_type_ids:Me}}}class q extends i.Callable{constructor(N){super(),this.config=N,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=N.trim_offsets}static fromConfig(N){if(N===null)return null;switch(N.type){case"WordPiece":return new rt(N);case"Metaspace":return new Dn(N);case"ByteLevel":return new He(N);case"Replace":return new pe(N);case"ByteFallback":return new we(N);case"Fuse":return new Fe(N);case"Strip":return new De(N);case"Sequence":return new mt(N);case"CTC":return new it(N);case"BPEDecoder":return new _t(N);default:throw new Error(`Unknown Decoder type: ${N.type}`)}}_call(N){return this.decode(N)}decode(N){return this.decode_chain(N).join("")}decode_chain(N){throw Error("`decode_chain` should be implemented in subclass.")}}class pe extends q{decode_chain(N){const ee=T(this.config.pattern);return ee===null?N:N.map(de=>de.replaceAll(ee,this.config.content))}}class we extends q{constructor(N){super(N),this.text_decoder=new TextDecoder}decode_chain(N){const ee=[];let de=[];for(const Me of N){let xe=null;if(Me.length===6&&Me.startsWith("<0x")&&Me.endsWith(">")){const Ge=parseInt(Me.slice(3,5),16);isNaN(Ge)||(xe=Ge)}if(xe!==null)de.push(xe);else{if(de.length>0){const Ge=this.text_decoder.decode(Uint8Array.from(de));ee.push(Ge),de=[]}ee.push(Me)}}if(de.length>0){const Me=this.text_decoder.decode(Uint8Array.from(de));ee.push(Me),de=[]}return ee}}class Fe extends q{decode_chain(N){return[N.join("")]}}class De extends q{constructor(N){super(N),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(N){return N.map(ee=>{let de=0;for(let xe=0;xe<this.start&&ee[xe]===this.content;++xe){de=xe+1;continue}let Me=ee.length;for(let xe=0;xe<this.stop;++xe){const Ge=ee.length-xe-1;if(ee[Ge]===this.content){Me=Ge;continue}else break}return ee.slice(de,Me)})}}class rt extends q{constructor(N){super(N),this.cleanup=N.cleanup}decode_chain(N){return N.map((ee,de)=>(de!==0&&(ee.startsWith(this.config.prefix)?ee=ee.replace(this.config.prefix,""):ee=" "+ee),this.cleanup&&(ee=L(ee)),ee))}}class He extends q{constructor(N){super(N),this.byte_decoder=ne,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(N){const ee=N.join(""),de=new Uint8Array([...ee].map(xe=>this.byte_decoder[xe]));return this.text_decoder.decode(de)}decode_chain(N){const ee=[];let de=[];for(const Me of N)this.added_tokens.find(xe=>xe.content===Me)!==void 0?(de.length>0&&(ee.push(this.convert_tokens_to_string(de)),de=[]),ee.push(Me)):de.push(Me);return de.length>0&&ee.push(this.convert_tokens_to_string(de)),ee}}class it extends q{constructor(N){super(N),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(N){if(N.length===0)return"";const ee=[N[0]];for(let xe=1;xe<N.length;++xe)N[xe]!==ee.at(-1)&&ee.push(N[xe]);let Me=ee.filter(xe=>xe!==this.pad_token).join("");return this.cleanup&&(Me=L(Me).replaceAll(this.word_delimiter_token," ").trim()),Me}decode_chain(N){return[this.convert_tokens_to_string(N)]}}class mt extends q{constructor(N){super(N),this.decoders=N.decoders.map(ee=>q.fromConfig(ee))}decode_chain(N){return this.decoders.reduce((ee,de)=>de.decode_chain(ee),N)}}class _t extends q{constructor(N){super(N),this.suffix=this.config.suffix}decode_chain(N){return N.map((ee,de)=>ee.replaceAll(this.suffix,de===N.length-1?"":" "))}}class Ot extends q{decode_chain(N){let ee="";for(let de=1;de<N.length;de+=2)ee+=N[de];return[ee]}}class Ft extends ae{constructor(N){super(),this.addPrefixSpace=N.add_prefix_space,this.replacement=N.replacement,this.strRep=N.str_rep||this.replacement,this.prepend_scheme=N.prepend_scheme??"always"}pre_tokenize_text(N,{section_index:ee=void 0}={}){let de=N.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!de.startsWith(this.replacement)&&(this.prepend_scheme==="always"||this.prepend_scheme==="first"&&ee===0)&&(de=this.strRep+de),[de]}}class Dn extends q{constructor(N){super(N),this.addPrefixSpace=N.add_prefix_space,this.replacement=N.replacement}decode_chain(N){const ee=[];for(let de=0;de<N.length;++de){let Me=N[de].replaceAll(this.replacement," ");this.addPrefixSpace&&de==0&&Me.startsWith(" ")&&(Me=Me.substring(1)),ee.push(Me)}return ee}}class hn extends ce{constructor(N){super(N),this.charsmap=N.precompiled_charsmap}normalize(N){return N=N.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,""),N=N.replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," "),N.includes("～")?N=N.split("～").map(de=>de.normalize("NFKC")).join("～"):N=N.normalize("NFKC"),N}}class Kn extends ae{constructor(N){super(),this.tokenizers=N.pretokenizers.map(ee=>ae.fromConfig(ee))}pre_tokenize_text(N,ee){return this.tokenizers.reduce((de,Me)=>Me.pre_tokenize(de,ee),[N])}}class Ws extends ae{constructor(N){super()}pre_tokenize_text(N,ee){return N.match(/\w+|[^\w\s]+/g)||[]}}class ga extends ae{constructor(N){super()}pre_tokenize_text(N,ee){return x(N)}}class Hr extends ae{constructor(N){super(),this.config=N,this.pattern=T(this.config.pattern),this.content=this.config.content}pre_tokenize_text(N,ee){return this.pattern===null?[N]:[N.replaceAll(this.pattern,this.config.content)]}}const ms=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function _s(Te,N,ee,de){for(const Me of Object.keys(Te)){const xe=N-Te[Me].length,Ge=ee(Me),lt=new Array(xe).fill(Ge);Te[Me]=de==="right"?(0,l.mergeArrays)(Te[Me],lt):(0,l.mergeArrays)(lt,Te[Me])}}function gs(Te,N){for(const ee of Object.keys(Te))Te[ee].length=N}class Pt extends i.Callable{constructor(ee,de){super();he(this,"return_token_type_ids",!1);he(this,"padding_side","right");this._tokenizer_config=de,this.normalizer=ce.fromConfig(ee.normalizer),this.pre_tokenizer=ae.fromConfig(ee.pre_tokenizer),this.model=oe.fromConfig(ee.model,de),this.post_processor=We.fromConfig(ee.post_processor),this.decoder=q.fromConfig(ee.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const Me of ee.added_tokens){const xe=new X(Me);this.added_tokens.push(xe),this.model.tokens_to_ids.set(xe.content,xe.id),this.model.vocab[xe.id]=xe.content,xe.special&&(this.special_tokens.push(xe.content),this.all_special_ids.push(xe.id))}if(this.additional_special_tokens=de.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_splitter=new d.DictionarySplitter(this.added_tokens.map(Me=>Me.content)),this.added_tokens_map=new Map(this.added_tokens.map(Me=>[Me.content,Me])),this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=de.model_max_length,this.remove_space=de.remove_space,this.clean_up_tokenization_spaces=de.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=de.do_lowercase_and_remove_accent??!1,de.padding_side&&(this.padding_side=de.padding_side),this.legacy=!1,this.chat_template=de.chat_template??null,Array.isArray(this.chat_template)){const Me=Object.create(null);for(const{name:xe,template:Ge}of this.chat_template){if(typeof xe!="string"||typeof Ge!="string")throw new Error('Chat template must be a list of objects with "name" and "template" properties');Me[xe]=Ge}this.chat_template=Me}this._compiled_template_cache=new Map}getToken(...ee){for(const de of ee){const Me=this._tokenizer_config[de];if(Me)if(typeof Me=="object"){if(Me.__type==="AddedToken")return Me.content;throw Error(`Unknown token: ${Me}`)}else return Me}return null}static async from_pretrained(ee,{progress_callback:de=null,config:Me=null,cache_dir:xe=null,local_files_only:Ge=!1,revision:lt="main",legacy:ht=null}={}){const ft=await _(ee,{progress_callback:de,config:Me,cache_dir:xe,local_files_only:Ge,revision:lt,legacy:ht});return new this(...ft)}_call(ee,{text_pair:de=null,add_special_tokens:Me=!0,padding:xe=!1,truncation:Ge=null,max_length:lt=null,return_tensor:ht=!0,return_token_type_ids:ft=null}={}){const Mt=Array.isArray(ee);let kt;if(Mt){if(ee.length===0)throw Error("text array must be non-empty");if(de!==null){if(Array.isArray(de)){if(ee.length!==de.length)throw Error("text and text_pair must have the same length")}else throw Error("text_pair must also be an array");kt=ee.map((sn,gn)=>this._encode_plus(sn,{text_pair:de[gn],add_special_tokens:Me,return_token_type_ids:ft}))}else kt=ee.map(sn=>this._encode_plus(sn,{add_special_tokens:Me,return_token_type_ids:ft}))}else{if(ee==null)throw Error("text may not be null or undefined");if(Array.isArray(de))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");kt=[this._encode_plus(ee,{text_pair:de,add_special_tokens:Me,return_token_type_ids:ft})]}if(lt===null?xe==="max_length"?lt=this.model_max_length:lt=(0,c.max)(kt.map(sn=>sn.input_ids.length))[0]:Ge||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),lt=Math.min(lt,this.model_max_length??1/0),xe||Ge)for(let sn=0;sn<kt.length;++sn)kt[sn].input_ids.length!==lt&&(kt[sn].input_ids.length>lt?Ge&&gs(kt[sn],lt):xe&&_s(kt[sn],lt,gn=>gn==="input_ids"?this.pad_token_id:0,this.padding_side));const Zt={};if(ht){if(!(xe&&Ge)&&kt.some(gn=>{var en;for(const $n of Object.keys(gn))if(gn[$n].length!==((en=kt[0][$n])==null?void 0:en.length))return!0;return!1}))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const sn=[kt.length,kt[0].input_ids.length];for(const gn of Object.keys(kt[0]))Zt[gn]=new p.Tensor("int64",BigInt64Array.from(kt.flatMap(en=>en[gn]).map(BigInt)),sn)}else{for(const sn of Object.keys(kt[0]))Zt[sn]=kt.map(gn=>gn[sn]);if(!Mt)for(const sn of Object.keys(Zt))Zt[sn]=Zt[sn][0]}return Zt}_encode_text(ee){if(ee===null)return null;const de=this.added_tokens_splitter.split(ee);for(let xe=0;xe<de.length;++xe){const Ge=this.added_tokens_map.get(de[xe]);Ge&&(Ge.lstrip&&xe>0&&(de[xe-1]=de[xe-1].trimEnd()),Ge.rstrip&&xe<de.length-1&&(de[xe+1]=de[xe+1].trimStart()))}return de.flatMap((xe,Ge)=>{if(xe.length===0)return[];if(this.added_tokens_map.has(xe))return[xe];if(this.remove_space===!0&&(xe=xe.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(xe=S(xe)),this.normalizer!==null&&(xe=this.normalizer(xe)),xe.length===0)return[];const lt=this.pre_tokenizer!==null?this.pre_tokenizer(xe,{section_index:Ge}):[xe];return this.model(lt)})}_encode_plus(ee,{text_pair:de=null,add_special_tokens:Me=!0,return_token_type_ids:xe=null}={}){const{tokens:Ge,token_type_ids:lt}=this._tokenize_helper(ee,{pair:de,add_special_tokens:Me}),ht=this.model.convert_tokens_to_ids(Ge),ft={input_ids:ht,attention_mask:new Array(ht.length).fill(1)};return(xe??this.return_token_type_ids)&&lt&&(ft.token_type_ids=lt),ft}_tokenize_helper(ee,{pair:de=null,add_special_tokens:Me=!1}={}){const xe=this._encode_text(ee),Ge=this._encode_text(de);return this.post_processor?this.post_processor(xe,Ge,{add_special_tokens:Me}):{tokens:(0,l.mergeArrays)(xe??[],Ge??[])}}tokenize(ee,{pair:de=null,add_special_tokens:Me=!1}={}){return this._tokenize_helper(ee,{pair:de,add_special_tokens:Me}).tokens}encode(ee,{text_pair:de=null,add_special_tokens:Me=!0,return_token_type_ids:xe=null}={}){return this._encode_plus(ee,{text_pair:de,add_special_tokens:Me,return_token_type_ids:xe}).input_ids}batch_decode(ee,de={}){return ee instanceof p.Tensor&&(ee=ee.tolist()),ee.map(Me=>this.decode(Me,de))}decode(ee,de={}){if(ee instanceof p.Tensor&&(ee=k(ee)),!Array.isArray(ee)||ee.length===0||!(0,l.isIntegralNumber)(ee[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(ee,de)}decode_single(ee,{skip_special_tokens:de=!1,clean_up_tokenization_spaces:Me=null}){let xe=this.model.convert_ids_to_tokens(ee);de&&(xe=xe.filter(lt=>!this.special_tokens.includes(lt)));let Ge=this.decoder?this.decoder(xe):xe.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(Ge=Ge.replaceAll(this.decoder.end_of_word_suffix," "),de&&(Ge=Ge.trim())),(Me??this.clean_up_tokenization_spaces)&&(Ge=L(Ge)),Ge}get_chat_template({chat_template:ee=null,tools:de=null}={}){if(this.chat_template&&typeof this.chat_template=="object"){const Me=this.chat_template;if(ee!==null&&Object.hasOwn(Me,ee))ee=Me[ee];else if(ee===null)if(de!==null&&"tool_use"in Me)ee=Me.tool_use;else if("default"in Me)ee=Me.default;else throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(Me).sort()}.`)}else if(ee===null)if(this.chat_template)ee=this.chat_template;else throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");return ee}apply_chat_template(ee,{tools:de=null,documents:Me=null,chat_template:xe=null,add_generation_prompt:Ge=!1,tokenize:lt=!0,padding:ht=!1,truncation:ft=!1,max_length:Mt=null,return_tensor:kt=!0,return_dict:Zt=!1,tokenizer_kwargs:sn={},...gn}={}){if(xe=this.get_chat_template({chat_template:xe,tools:de}),typeof xe!="string")throw Error(`chat_template must be a string, but got ${typeof xe}`);let en=this._compiled_template_cache.get(xe);en===void 0&&(en=new f.Template(xe),this._compiled_template_cache.set(xe,en));const $n=Object.create(null);for(const yr of ms){const Br=this.getToken(yr);Br&&($n[yr]=Br)}const gr=en.render({messages:ee,add_generation_prompt:Ge,tools:de,documents:Me,...$n,...gn});if(lt){const yr=this._call(gr,{add_special_tokens:!1,padding:ht,truncation:ft,max_length:Mt,return_tensor:kt,...sn});return Zt?yr:yr.input_ids}return gr}}class ys extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class Kr extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class Ms extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class Hs extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class ya extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class Pr extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class Nn extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class mn extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class st extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class yt extends Pt{}class Et extends Pt{}class Qn extends Pt{constructor(ee,de){super(ee,de);he(this,"return_token_type_ids",!0);console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class _n extends Pt{constructor(){super(...arguments);he(this,"return_token_type_ids",!0)}}class mr extends Pt{}class vs extends Pt{}class Fr extends Pt{}class rr extends Pt{constructor(N,ee){super(N,ee),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter(de=>this.languageRegex.test(de)),this.lang_to_token=de=>de}_build_translation_inputs(N,ee,de){return _r(this,N,ee,de)}}class qr extends rr{}class Lr extends Pt{}class Pn extends Pt{}const Ks="▁";class Ua extends Pt{constructor(ee,de){super(ee,de);he(this,"padding_side","left");this.legacy=de.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new Ft({replacement:Ks,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(ee){if(ee===null)return null;if(this.legacy||ee.length===0)return super._encode_text(ee);let de=super._encode_text(Ks+ee.replaceAll(Ks," "));return de.length>1&&de[0]===Ks&&this.special_tokens.includes(de[1])&&(de=de.slice(1)),de}}class as extends Pt{}class ws extends Pt{}class Ei extends Pt{}class Ds extends Pt{}class Va extends Pt{}class Si extends Pt{}class qs extends Pt{}class Ar extends Pt{}class Tr extends Pt{}function _r(Te,N,ee,de){if(!("language_codes"in Te)||!Array.isArray(Te.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in Te)||!(Te.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in Te)||typeof Te.lang_to_token!="function")throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const Me=de.src_lang,xe=de.tgt_lang;if(!Te.language_codes.includes(xe))throw new Error(`Target language code "${xe}" is not valid. Must be one of: {${Te.language_codes.join(", ")}}`);if(Me!==void 0){if(!Te.language_codes.includes(Me))throw new Error(`Source language code "${Me}" is not valid. Must be one of: {${Te.language_codes.join(", ")}}`);for(const Ge of Te.post_processor.config.single)if("SpecialToken"in Ge&&Te.languageRegex.test(Ge.SpecialToken.id)){Ge.SpecialToken.id=Te.lang_to_token(Me);break}}return de.forced_bos_token_id=Te.model.convert_tokens_to_ids([Te.lang_to_token(xe)])[0],Te._call(N,ee)}class Ma extends Pt{constructor(N,ee){super(N,ee),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter(de=>this.languageRegex.test(de)),this.lang_to_token=de=>de}_build_translation_inputs(N,ee,de){return _r(this,N,ee,de)}}class is extends Pt{constructor(N,ee){super(N,ee),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter(de=>this.languageRegex.test(de)).map(de=>de.slice(2,-2)),this.lang_to_token=de=>`__${de}__`}_build_translation_inputs(N,ee,de){return _r(this,N,ee,de)}}class $r extends Pt{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(N,{return_timestamps:ee=!1,return_language:de=!1,time_precision:Me=null,force_full_sequences:xe=!0}={}){if(Me===null)throw Error("Must specify time_precision");let Ge=null;const lt=ee==="word";function ht(){return{language:Ge,timestamp:[null,null],text:""}}const ft=[];let Mt=ht(),kt=0;const Zt=this.timestamp_begin,gn=Zt+1500;let en=[],$n=[],gr=!1,yr=null;const Br=new Set(this.all_special_ids);for(const wn of N){const bn=wn.tokens,ur=lt?wn.token_timestamps:null;let Zr=null,zs=Zt;if("stride"in wn){const[Tn,nn,yn]=wn.stride;if(kt-=nn,yr=Tn-yn,nn&&(zs=nn/Me+Zt),yn)for(let In=bn.length-1;In>=0;--In){const jn=Number(bn[In]);if(jn>=Zt){if(Zr!==null&&(jn-Zt)*Me<yr)break;Zr=jn}}}let On=[],Xn=[];for(let Tn=0;Tn<bn.length;++Tn){const nn=Number(bn[Tn]);if(Br.has(nn)){const yn=this.decode([nn]),In=g.WHISPER_LANGUAGE_MAPPING.get(yn.slice(2,-2));if(In!==void 0){if(Ge!==null&&In!==Ge&&!ee){en.push(On);const jn=this.findLongestCommonSequence(en)[0],Pi=this.decode(jn);Mt.text=Pi,ft.push(Mt),en=[],On=[],Mt=ht()}Ge=Mt.language=In}}else if(nn>=Zt&&nn<=gn){const yn=(nn-Zt)*Me+kt,In=(0,c.round)(yn,2);if(Zr!==null&&nn>=Zr)gr=!0;else if(gr||en.length>0&&nn<zs)gr=!1;else if(Mt.timestamp[0]===null)Mt.timestamp[0]=In;else if(In!==Mt.timestamp[0]){Mt.timestamp[1]=In,en.push(On),lt&&$n.push(Xn);const[jn,Pi]=this.findLongestCommonSequence(en,$n),wa=this.decode(jn);Mt.text=wa,lt&&(Mt.words=this.collateWordTimestamps(jn,Pi,Ge)),ft.push(Mt),en=[],On=[],$n=[],Xn=[],Mt=ht()}}else if(On.push(nn),lt){let yn=(0,c.round)(ur[Tn]+kt,2),In;if(Tn+1<ur.length){In=(0,c.round)(ur[Tn+1]+kt,2);const jn=this.decode([nn]);A.test(jn)&&(In=(0,c.round)(Math.min(yn+Me,In),2))}else In=null;Xn.push([yn,In])}}if("stride"in wn){const[Tn,nn,yn]=wn.stride;kt+=Tn-yn}On.length>0?(en.push(On),lt&&$n.push(Xn)):en.every(Tn=>Tn.length===0)&&(Mt=ht(),en=[],On=[],$n=[],Xn=[])}if(en.length>0){if(xe&&ee)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[wn,bn]=this.findLongestCommonSequence(en,$n),ur=this.decode(wn);Mt.text=ur,lt&&(Mt.words=this.collateWordTimestamps(wn,bn,Ge)),ft.push(Mt)}let Bn=Object.create(null);const bs=ft.map(wn=>wn.text).join("");if(ee||de){for(let wn=0;wn<ft.length;++wn){const bn=ft[wn];ee||delete bn.timestamp,de||delete bn.language}if(lt){const wn=[];for(const bn of ft)for(const ur of bn.words)wn.push(ur);Bn={chunks:wn}}else Bn={chunks:ft}}return[bs,Bn]}findLongestCommonSequence(N,ee=null){let de=N[0],Me=de.length,xe=[];const Ge=Array.isArray(ee)&&ee.length>0;let lt=Ge?[]:null,ht=Ge?ee[0]:null;for(let ft=1;ft<N.length;++ft){const Mt=N[ft];let kt=0,Zt=[Me,Me,0,0];const sn=Mt.length;for(let Bn=1;Bn<Me+sn;++Bn){const bs=Math.max(0,Me-Bn),wn=Math.min(Me,Me+sn-Bn),bn=de.slice(bs,wn),ur=Math.max(0,Bn-Me),Zr=Math.min(sn,Bn),zs=Mt.slice(ur,Zr);if(bn.length!==zs.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let On;Ge?On=bn.filter((nn,yn)=>nn===zs[yn]&&ht[bs+yn]<=ee[ft][ur+yn]).length:On=bn.filter((nn,yn)=>nn===zs[yn]).length;const Xn=Bn/1e4,Tn=On/Bn+Xn;On>1&&Tn>kt&&(kt=Tn,Zt=[bs,wn,ur,Zr])}const[gn,en,$n,gr]=Zt,yr=Math.floor((en+gn)/2),Br=Math.floor((gr+$n)/2);xe.push(...de.slice(0,yr)),de=Mt.slice(Br),Me=de.length,Ge&&(lt.push(...ht.slice(0,yr)),ht=ee[ft].slice(Br))}return xe.push(...de),Ge?(lt.push(...ht),[xe,lt]):[xe,[]]}collateWordTimestamps(N,ee,de){const[Me,xe,Ge]=this.combineTokensIntoWords(N,de),lt=[];for(let ht=0;ht<Me.length;++ht){const ft=Ge[ht];lt.push({text:Me[ht],timestamp:[ee[ft.at(0)][0],ee[ft.at(-1)][1]]})}return lt}combineTokensIntoWords(N,ee,de=`"'“¡¿([{-`,Me=`"'.。,，!！?？:：”)]}、`){ee=ee??"english";let xe,Ge,lt;return["chinese","japanese","thai","lao","myanmar"].includes(ee)?[xe,Ge,lt]=this.splitTokensOnUnicode(N):[xe,Ge,lt]=this.splitTokensOnSpaces(N),this.mergePunctuations(xe,Ge,lt,de,Me)}decode(N,ee){let de;return ee!=null&&ee.decode_with_timestamps?(N instanceof p.Tensor&&(N=k(N)),de=this.decodeWithTimestamps(N,ee)):de=super.decode(N,ee),de}decodeWithTimestamps(N,ee){const de=(ee==null?void 0:ee.time_precision)??.02,Me=Array.from(this.all_special_ids).at(-1)+1;let xe=[[]];for(let Ge of N)if(Ge=Number(Ge),Ge>=Me){const lt=((Ge-Me)*de).toFixed(2);xe.push(`<|${lt}|>`),xe.push([])}else xe[xe.length-1].push(Ge);return xe=xe.map(Ge=>typeof Ge=="string"?Ge:super.decode(Ge,ee)),xe.join("")}splitTokensOnUnicode(N){const ee=this.decode(N,{decode_with_timestamps:!0}),de="�",Me=[],xe=[],Ge=[];let lt=[],ht=[],ft=0;for(let Mt=0;Mt<N.length;++Mt){const kt=N[Mt];lt.push(kt),ht.push(Mt);const Zt=this.decode(lt,{decode_with_timestamps:!0});(!Zt.includes(de)||ee[ft+Zt.indexOf(de)]===de)&&(Me.push(Zt),xe.push(lt),Ge.push(ht),lt=[],ht=[],ft+=Zt.length)}return[Me,xe,Ge]}splitTokensOnSpaces(N){const[ee,de,Me]=this.splitTokensOnUnicode(N),xe=[],Ge=[],lt=[],ht=new RegExp(`^[${E}]$`,"gu");for(let ft=0;ft<ee.length;++ft){const Mt=ee[ft],kt=de[ft],Zt=Me[ft],sn=kt[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),gn=Mt.startsWith(" "),en=Mt.trim(),$n=ht.test(en);if(sn||gn||$n||xe.length===0)xe.push(Mt),Ge.push(kt),lt.push(Zt);else{const gr=xe.length-1;xe[gr]+=Mt,Ge[gr].push(...kt),lt[gr].push(...Zt)}}return[xe,Ge,lt]}mergePunctuations(N,ee,de,Me,xe){const Ge=structuredClone(N),lt=structuredClone(ee),ht=structuredClone(de);let ft=Ge.length-2,Mt=Ge.length-1;for(;ft>=0;)Ge[ft].startsWith(" ")&&Me.includes(Ge[ft].trim())?(Ge[Mt]=Ge[ft]+Ge[Mt],lt[Mt]=(0,l.mergeArrays)(lt[ft],lt[Mt]),ht[Mt]=(0,l.mergeArrays)(ht[ft],ht[Mt]),Ge[ft]="",lt[ft]=[],ht[ft]=[]):Mt=ft,--ft;for(ft=0,Mt=1;Mt<Ge.length;)!Ge[ft].endsWith(" ")&&xe.includes(Ge[Mt])?(Ge[ft]+=Ge[Mt],lt[ft]=(0,l.mergeArrays)(lt[ft],lt[Mt]),ht[ft]=(0,l.mergeArrays)(ht[ft],ht[Mt]),Ge[Mt]="",lt[Mt]=[],ht[Mt]=[]):ft=Mt,++Mt;return[Ge.filter(kt=>kt),lt.filter(kt=>kt.length>0),ht.filter(kt=>kt.length>0)]}}class os extends Pt{}class uo extends Pt{}class Qr extends Pt{}class xr extends Pt{constructor(N,ee){super(N,ee),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter(de=>this.languageRegex.test(de)),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(N){if(N===null)return null;const[ee,...de]=N.trim().split(this.languageRegex);if(de.length===0)return super._encode_text(ee);if(de.length===2){const[Me,xe]=de;return this.supported_language_codes.includes(Me)||console.warn(`Unsupported language code "${Me}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,l.mergeArrays)([Me],super._encode_text(xe))}}}class va extends Pt{}class Xr extends Pt{}class Yr extends Pt{}class lr extends Pt{}class sr extends Pt{}class Ga extends Pt{constructor(N,ee){super(N,ee),this.decoder=new Ot({})}}class Er extends Pt{}class Is extends Pt{}class Ci{static async from_pretrained(N,{progress_callback:ee=null,config:de=null,cache_dir:Me=null,local_files_only:xe=!1,revision:Ge="main",legacy:lt=null}={}){var Zt;const[ht,ft]=await _(N,{progress_callback:ee,config:de,cache_dir:Me,local_files_only:xe,revision:Ge,legacy:lt}),Mt=((Zt=ft.tokenizer_class)==null?void 0:Zt.replace(/Fast$/,""))??"PreTrainedTokenizer";let kt=this.TOKENIZER_CLASS_MAPPING[Mt];return kt||(console.warn(`Unknown tokenizer class "${Mt}", attempting to construct from base class.`),kt=Pt),new kt(ht,ft)}}he(Ci,"TOKENIZER_CLASS_MAPPING",{T5Tokenizer:mr,DistilBertTokenizer:yt,CamembertTokenizer:Et,DebertaTokenizer:ya,DebertaV2Tokenizer:Pr,BertTokenizer:ys,HerbertTokenizer:Nn,ConvBertTokenizer:mn,RoFormerTokenizer:st,XLMTokenizer:Qn,ElectraTokenizer:_n,MobileBertTokenizer:Ms,SqueezeBertTokenizer:Hs,AlbertTokenizer:Kr,GPT2Tokenizer:vs,BartTokenizer:Fr,MBartTokenizer:rr,MBart50Tokenizer:qr,RobertaTokenizer:Lr,WhisperTokenizer:$r,CodeGenTokenizer:os,CLIPTokenizer:uo,SiglipTokenizer:Qr,MarianTokenizer:xr,BloomTokenizer:Pn,NllbTokenizer:Ma,M2M100Tokenizer:is,LlamaTokenizer:Ua,CodeLlamaTokenizer:as,XLMRobertaTokenizer:ws,MPNetTokenizer:Ei,FalconTokenizer:Ds,GPTNeoXTokenizer:Va,EsmTokenizer:Si,Wav2Vec2CTCTokenizer:va,BlenderbotTokenizer:Xr,BlenderbotSmallTokenizer:Yr,SpeechT5Tokenizer:lr,NougatTokenizer:sr,VitsTokenizer:Ga,Qwen2Tokenizer:qs,GemmaTokenizer:Ar,Grok1Tokenizer:Tr,CohereTokenizer:Er,MgpstrTokenizer:Is,PreTrainedTokenizer:Pt})},"./src/utils/audio.js":(t,s,n)=>{n.r(s),n.d(s,{RawAudio:()=>ie,hamming:()=>y,hanning:()=>_,mel_filter_bank:()=>I,read_audio:()=>f,spectrogram:()=>F,window_function:()=>K});var i=n("./src/utils/hub.js"),l=n("./src/utils/maths.js"),o=n("./src/utils/core.js"),c=n("./src/env.js"),p=n("?7a2c"),d=n("./src/utils/tensor.js");async function f(J,ue){if(typeof AudioContext>"u")throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const ne=await(await(0,i.getFile)(J)).arrayBuffer(),G=new AudioContext({sampleRate:ue});typeof ue>"u"&&console.warn(`No sampling rate provided, using default of ${G.sampleRate}Hz.`);const se=await G.decodeAudioData(ne);let ce;if(se.numberOfChannels===2){const ge=Math.sqrt(2),W=se.getChannelData(0),U=se.getChannelData(1);ce=new Float32Array(W.length);for(let B=0;B<se.length;++B)ce[B]=ge*(W[B]+U[B])/2}else ce=se.getChannelData(0);return ce}function g(J,ue){if(J<1)return new Float64Array;if(J===1)return new Float64Array([1]);const ne=1-ue,G=2*Math.PI/(J-1),se=new Float64Array(J);for(let ce=0;ce<J;++ce)se[ce]=ue-ne*Math.cos(ce*G);return se}function _(J){return g(J,.5)}function y(J){return g(J,.54)}const T={htk:J=>2595*Math.log10(1+J/700),kaldi:J=>1127*Math.log(1+J/700),slaney:(J,ue=1e3,ne=15,G=27/Math.log(6.4))=>J>=ue?ne+Math.log(J/ue)*G:3*J/200};function b(J,ue="htk"){const ne=T[ue];if(!ne)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof J=="number"?ne(J):J.map(G=>ne(G))}const k={htk:J=>700*(10**(J/2595)-1),kaldi:J=>700*(Math.exp(J/1127)-1),slaney:(J,ue=1e3,ne=15,G=Math.log(6.4)/27)=>J>=ne?ue*Math.exp(G*(J-ne)):200*J/3};function L(J,ue="htk"){const ne=k[ue];if(!ne)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return typeof J=="number"?ne(J):J.map(G=>ne(G))}function C(J,ue){const ne=Float64Array.from({length:ue.length-1},(ge,W)=>ue[W+1]-ue[W]),G=Array.from({length:J.length},()=>new Array(ue.length));for(let ge=0;ge<J.length;++ge){const W=G[ge];for(let U=0;U<ue.length;++U)W[U]=ue[U]-J[ge]}const se=ue.length-2,ce=Array.from({length:se},()=>new Array(J.length));for(let ge=0;ge<J.length;++ge){const W=G[ge];for(let U=0;U<se;++U){const B=-W[U]/ne[U],Q=W[U+2]/ne[U+1];ce[U][ge]=Math.max(0,Math.min(B,Q))}}return ce}function S(J,ue,ne){const G=(ue-J)/(ne-1);return Float64Array.from({length:ne},(se,ce)=>J+G*ce)}function I(J,ue,ne,G,se,ce=null,ge="htk",W=!1){if(ce!==null&&ce!=="slaney")throw new Error('norm must be one of null or "slaney"');const U=b(ne,ge),B=b(G,ge),Q=S(U,B,ue+2);let le=L(Q,ge),re;if(W){const Se=se/(J*2);re=b(Float64Array.from({length:J},(Be,ut)=>ut*Se),ge),le=Q}else re=S(0,Math.floor(se/2),J);const ve=C(re,le);if(ce!==null&&ce==="slaney")for(let Se=0;Se<ue;++Se){const Be=ve[Se],ut=2/(le[Se+2]-le[Se]);for(let Oe=0;Oe<J;++Oe)Be[Oe]*=ut}return ve}function O(J,ue,ne){const G=new J.constructor(J.length+ue+ne),se=J.length-1;for(let ce=0;ce<J.length;++ce)G[ue+ce]=J[ce];for(let ce=1;ce<=ue;++ce)G[ue-ce]=J[(0,o.calculateReflectOffset)(ce,se)];for(let ce=1;ce<=ne;++ce)G[se+ue+ce]=J[(0,o.calculateReflectOffset)(se-ce,se)];return G}function x(J,ue,ne,G,se){if(ne<=0)throw new Error("reference must be greater than zero");if(G<=0)throw new Error("min_value must be greater than zero");ne=Math.max(G,ne);const ce=Math.log10(ne);for(let ge=0;ge<J.length;++ge)J[ge]=ue*Math.log10(Math.max(G,J[ge])-ce);if(se!==null){if(se<=0)throw new Error("db_range must be greater than zero");const ge=(0,l.max)(J)[0]-se;for(let W=0;W<J.length;++W)J[W]=Math.max(J[W],ge)}return J}function E(J,ue=1,ne=1e-5,G=null){return x(J,20,ue,ne,G)}function A(J,ue=1,ne=1e-10,G=null){return x(J,10,ue,ne,G)}async function F(J,ue,ne,G,{fft_length:se=null,power:ce=1,center:ge=!0,pad_mode:W="reflect",onesided:U=!0,preemphasis:B=null,mel_filters:Q=null,mel_floor:le=1e-10,log_mel:re=null,reference:ve=1,min_value:Se=1e-10,db_range:Be=null,remove_dc_offset:ut=null,min_num_frames:Oe=null,max_num_frames:ae=null,do_pad:Z=!0,transpose:Ee=!1}={}){const Ve=ue.length;if(se===null&&(se=ne),ne>se)throw Error(`frame_length (${ne}) may not be larger than fft_length (${se})`);if(Ve!==ne)throw new Error(`Length of the window (${Ve}) must equal frame_length (${ne})`);if(G<=0)throw new Error("hop_length must be greater than zero");if(ce===null&&Q!==null)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(ge){if(W!=="reflect")throw new Error(`pad_mode="${W}" not implemented yet.`);const Fe=Math.floor((se-1)/2)+1;J=O(J,Fe,Fe)}let Ue=Math.floor(1+Math.floor((J.length-ne)/G));Oe!==null&&Ue<Oe&&(Ue=Oe);const qe=U?Math.floor(se/2)+1:se;let We=Ue,nt=Ue;ae!==null&&(ae>Ue?Z&&(nt=ae):nt=We=ae);const at=new l.FFT(se),ct=new Float64Array(se),V=new Float64Array(at.outputBufferSize),fe=new Float32Array(qe*nt);for(let Fe=0;Fe<We;++Fe){const De=Fe*G,rt=Math.min(J.length-De,ne);rt!==ne&&ct.fill(0,0,ne);for(let He=0;He<rt;++He)ct[He]=J[De+He];if(ut){let He=0;for(let mt=0;mt<rt;++mt)He+=ct[mt];const it=He/rt;for(let mt=0;mt<rt;++mt)ct[mt]-=it}if(B!==null){for(let He=rt-1;He>=1;--He)ct[He]-=B*ct[He-1];ct[0]*=1-B}for(let He=0;He<ue.length;++He)ct[He]*=ue[He];at.realTransform(V,ct);for(let He=0;He<qe;++He){const it=He<<1;fe[He*nt+Fe]=V[it]**2+V[it+1]**2}}if(ce!==null&&ce!==2){const Fe=2/ce;for(let De=0;De<fe.length;++De)fe[De]**=Fe}const q=Q.length;let pe=await(0,d.matmul)(new d.Tensor("float32",Q.flat(),[q,qe]),new d.Tensor("float32",fe,[qe,nt]));Ee&&(pe=pe.transpose(1,0));const we=pe.data;for(let Fe=0;Fe<we.length;++Fe)we[Fe]=Math.max(le,we[Fe]);if(ce!==null&&re!==null){const Fe=Math.min(we.length,We*q);switch(re){case"log":for(let De=0;De<Fe;++De)we[De]=Math.log(we[De]);break;case"log10":for(let De=0;De<Fe;++De)we[De]=Math.log10(we[De]);break;case"dB":if(ce===1)E(we,ve,Se,Be);else if(ce===2)A(we,ve,Se,Be);else throw new Error(`Cannot use log_mel option '${re}' with power ${ce}`);break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${re}'`)}}return pe}function K(J,ue,{periodic:ne=!0,frame_length:G=null,center:se=!0}={}){const ce=ne?J+1:J;let ge;switch(ue){case"boxcar":ge=new Float64Array(ce).fill(1);break;case"hann":case"hann_window":ge=_(ce);break;case"hamming":ge=y(ce);break;case"povey":ge=_(ce).map(W=>Math.pow(W,.85));break;default:throw new Error(`Unknown window type ${ue}.`)}if(ne&&(ge=ge.subarray(0,J)),G===null)return ge;if(J>G)throw new Error(`Length of the window (${J}) may not be larger than frame_length (${G})`);return ge}function X(J,ue){let ne=44;const G=new ArrayBuffer(ne+J.length*4),se=new DataView(G);oe(se,0,"RIFF"),se.setUint32(4,36+J.length*4,!0),oe(se,8,"WAVE"),oe(se,12,"fmt "),se.setUint32(16,16,!0),se.setUint16(20,3,!0),se.setUint16(22,1,!0),se.setUint32(24,ue,!0),se.setUint32(28,ue*4,!0),se.setUint16(32,4,!0),se.setUint16(34,32,!0),oe(se,36,"data"),se.setUint32(40,J.length*4,!0);for(let ce=0;ce<J.length;++ce,ne+=4)se.setFloat32(ne,J[ce],!0);return G}function oe(J,ue,ne){for(let G=0;G<ne.length;++G)J.setUint8(ue+G,ne.charCodeAt(G))}class ie{constructor(ue,ne){this.audio=ue,this.sampling_rate=ne}toWav(){return X(this.audio,this.sampling_rate)}toBlob(){const ue=this.toWav();return new Blob([ue],{type:"audio/wav"})}async save(ue){let ne;if(c.apis.IS_BROWSER_ENV){if(c.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");ne=o.saveBlob}else if(c.apis.IS_FS_AVAILABLE)ne=async(G,se)=>{let ce=await se.arrayBuffer();p.writeFileSync(G,Buffer.from(ce))};else throw new Error("Unable to save because filesystem is disabled in this environment.");await ne(ue,this.toBlob())}}},"./src/utils/constants.js":(t,s,n)=>{n.r(s),n.d(s,{CHAT_TEMPLATE_NAME:()=>d,CONFIG_NAME:()=>l,FEATURE_EXTRACTOR_NAME:()=>o,GENERATION_CONFIG_NAME:()=>f,GITHUB_ISSUE_URL:()=>i,IMAGE_PROCESSOR_NAME:()=>c,PROCESSOR_NAME:()=>p});const i="https://github.com/huggingface/transformers.js/issues/new/choose",l="config.json",o="preprocessor_config.json",c=o,p="processor_config.json",d="chat_template.json",f="generation_config.json"},"./src/utils/core.js":(t,s,n)=>{n.r(s),n.d(s,{calculateDimensions:()=>f,calculateReflectOffset:()=>T,count:()=>C,dispatchCallback:()=>i,escapeRegExp:()=>o,isIntegralNumber:()=>p,isNullishDimension:()=>d,isTypedArray:()=>c,len:()=>L,mergeArrays:()=>_,pick:()=>k,pop:()=>g,product:()=>y,reverseDictionary:()=>l,saveBlob:()=>b});function i(S,I){S&&S(I)}function l(S){return Object.fromEntries(Object.entries(S).map(([I,O])=>[O,I]))}function o(S){return S.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function c(S){var I,O,x;return((x=(O=(I=S==null?void 0:S.prototype)==null?void 0:I.__proto__)==null?void 0:O.constructor)==null?void 0:x.name)==="TypedArray"}function p(S){return Number.isInteger(S)||typeof S=="bigint"}function d(S){return S==null||S===-1}function f(S){const I=[];let O=S;for(;Array.isArray(O);)I.push(O.length),O=O[0];return I}function g(S,I,O=void 0){const x=S[I];if(x!==void 0)return delete S[I],x;if(O===void 0)throw Error(`Key ${I} does not exist in object.`);return O}function _(...S){return Array.prototype.concat.apply([],S)}function y(...S){return S.reduce((I,O)=>I.flatMap(x=>O.map(E=>[x,E])))}function T(S,I){return Math.abs((S+I)%(2*I)-I)}function b(S,I){const O=URL.createObjectURL(I),x=document.createElement("a");x.href=O,x.download=S,x.click(),x.remove(),URL.revokeObjectURL(O)}function k(S,I){return Object.assign({},...I.map(O=>{if(S[O]!==void 0)return{[O]:S[O]}}))}function L(S){let I=0;for(const O of S)++I;return I}function C(S,I){let O=0;for(const x of S)x===I&&++O;return O}},"./src/utils/data-structures.js":(t,s,n)=>{n.r(s),n.d(s,{CharTrie:()=>l,DictionarySplitter:()=>d,PriorityQueue:()=>i,TokenLattice:()=>c});class i{constructor(g=(y,T)=>y>T,_=1/0){this._heap=[],this._comparator=g,this._maxSize=_}get size(){return this._heap.length}isEmpty(){return this.size===0}peek(){return this._heap[0]}push(...g){return this.extend(g)}extend(g){for(const _ of g)if(this.size<this._maxSize)this._heap.push(_),this._siftUp();else{const y=this._smallest();this._comparator(_,this._heap[y])&&(this._heap[y]=_,this._siftUpFrom(y))}return this.size}pop(){const g=this.peek(),_=this.size-1;return _>0&&this._swap(0,_),this._heap.pop(),this._siftDown(),g}replace(g){const _=this.peek();return this._heap[0]=g,this._siftDown(),_}_parent(g){return(g+1>>>1)-1}_left(g){return(g<<1)+1}_right(g){return g+1<<1}_greater(g,_){return this._comparator(this._heap[g],this._heap[_])}_swap(g,_){const y=this._heap[g];this._heap[g]=this._heap[_],this._heap[_]=y}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(g){for(;g>0&&this._greater(g,this._parent(g));)this._swap(g,this._parent(g)),g=this._parent(g)}_siftDown(){let g=0;for(;this._left(g)<this.size&&this._greater(this._left(g),g)||this._right(g)<this.size&&this._greater(this._right(g),g);){const _=this._right(g)<this.size&&this._greater(this._right(g),this._left(g))?this._right(g):this._left(g);this._swap(g,_),g=_}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class l{constructor(){this.root=o.default()}extend(g){for(const _ of g)this.push(_)}push(g){let _=this.root;for(const y of g){let T=_.children.get(y);T===void 0&&(T=o.default(),_.children.set(y,T)),_=T}_.isLeaf=!0}*commonPrefixSearch(g){let _=this.root;if(_===void 0)return;let y="";for(const T of g){if(y+=T,_=_.children.get(T),_===void 0)return;_.isLeaf&&(yield y)}}}class o{constructor(g,_){this.isLeaf=g,this.children=_}static default(){return new o(!1,new Map)}}class c{constructor(g,_,y){this.chars=Array.from(g),this.len=this.chars.length,this.bosTokenId=_,this.eosTokenId=y,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},()=>[]),this.endNodes=Array.from({length:this.len+1},()=>[]);const T=new p(this.bosTokenId,0,0,0,0),b=new p(this.eosTokenId,1,this.len,0,0);this.nodes.push(T.clone()),this.nodes.push(b.clone()),this.beginNodes[this.len].push(b),this.endNodes[0].push(T)}insert(g,_,y,T){const b=this.nodes.length,k=new p(T,b,g,_,y);this.beginNodes[g].push(k),this.endNodes[g+_].push(k),this.nodes.push(k)}viterbi(){const g=this.len;let _=0;for(;_<=g;){if(this.beginNodes[_].length==0)return[];for(let L of this.beginNodes[_]){L.prev=null;let C=0,S=null;for(let I of this.endNodes[_]){const O=I.backtraceScore+L.score;(S===null||O>C)&&(S=I.clone(),C=O)}if(S!==null)L.prev=S,L.backtraceScore=C;else return[]}++_}const y=[],b=this.beginNodes[g][0].prev;if(b===null)return[];let k=b.clone();for(;k.prev!==null;)y.push(k.clone()),k=k.clone().prev.clone();return y.reverse(),y}piece(g){return this.chars.slice(g.pos,g.pos+g.length).join("")}tokens(){return this.viterbi().map(_=>this.piece(_))}tokenIds(){return this.viterbi().map(_=>_.tokenId)}}class p{constructor(g,_,y,T,b){this.tokenId=g,this.nodeId=_,this.pos=y,this.length=T,this.score=b,this.prev=null,this.backtraceScore=0}clone(){const g=new p(this.tokenId,this.nodeId,this.pos,this.length,this.score);return g.prev=this.prev,g.backtraceScore=this.backtraceScore,g}}class d{constructor(g){this.trie=this._buildTrie(g)}_buildTrie(g){var y;const _=Object.create(null);for(const T of g){let b=_;for(let k=0;k<T.length;++k)b=b[y=T[k]]??(b[y]=Object.create(null));b.end=T}return _}split(g){const _=[],y=g.length;let T=0,b=0;for(;b<y;){let k=this.trie,L=null,C=b;for(;C<y&&(k=k[g[C]]);)k.end&&(L=k.end),++C;L?(b>T&&_.push(g.slice(T,b)),_.push(L),b+=L.length,T=b):++b}return T<y&&_.push(g.slice(T)),_}}},"./src/utils/devices.js":(t,s,n)=>{n.r(s),n.d(s,{DEVICE_TYPES:()=>i});const i=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":(t,s,n)=>{n.r(s),n.d(s,{DATA_TYPES:()=>c,DEFAULT_DEVICE_DTYPE_MAPPING:()=>p,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>d,isWebGpuFp16Supported:()=>o});var i=n("./src/env.js"),l=n("./src/utils/devices.js");const o=function(){let f;return async function(){if(f===void 0)if(!i.apis.IS_WEBGPU_AVAILABLE)f=!1;else try{f=(await navigator.gpu.requestAdapter()).features.has("shader-f16")}catch{f=!1}return f}}(),c=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),p=Object.freeze({[l.DEVICE_TYPES.wasm]:c.q8}),d=Object.freeze({[c.fp32]:"",[c.fp16]:"_fp16",[c.int8]:"_int8",[c.uint8]:"_uint8",[c.q8]:"_quantized",[c.q4]:"_q4",[c.q4f16]:"_q4f16",[c.bnb4]:"_bnb4"})},"./src/utils/generic.js":(t,s,n)=>{n.r(s),n.d(s,{Callable:()=>i});const i=class{constructor(){let l=function(...o){return l._call(...o)};return Object.setPrototypeOf(l,new.target.prototype)}_call(...l){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":(t,s,n)=>{n.r(s),n.d(s,{MAX_EXTERNAL_DATA_CHUNKS:()=>p,getFile:()=>T,getModelFile:()=>S,getModelJSON:()=>I});var i=n("?7a2c"),l=n("?a42a"),o=n("./src/env.js"),c=n("./src/utils/core.js");const p=100,d={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class f{constructor(A){if(this.filePath=A,this.headers=new Headers,this.exists=i.existsSync(A),this.exists){this.status=200,this.statusText="OK";let F=i.statSync(A);this.headers.set("content-length",F.size.toString()),this.updateContentType();const K=i.createReadStream(A);this.body=new ReadableStream({start(X){K.on("data",oe=>X.enqueue(oe)),K.on("end",()=>X.close()),K.on("error",oe=>X.error(oe))},cancel(){K.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const A=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",d[A]??"application/octet-stream")}clone(){let A=new f(this.filePath);return A.exists=this.exists,A.status=this.status,A.statusText=this.statusText,A.headers=new Headers(this.headers),A}async arrayBuffer(){return(await i.promises.readFile(this.filePath)).buffer}async blob(){const A=await i.promises.readFile(this.filePath);return new Blob([A],{type:this.headers.get("content-type")})}async text(){return await i.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function g(E,A=null,F=null){let K;try{K=new URL(E)}catch{return!1}return!(A&&!A.includes(K.protocol)||F&&!F.includes(K.hostname))}const _=/^(\b[\w\-.]+\b\/)?\b[\w\-.]{1,96}\b$/;function y(E){return!(!_.test(E)||E.includes("..")||E.includes("--")||E.endsWith(".git")||E.endsWith(".ipynb"))}async function T(E){var A;if(o.env.useFS&&!g(E,["http:","https:","blob:"]))return new f(E.toString());if(typeof process<"u"&&((A=process==null?void 0:process.release)==null?void 0:A.name)==="node"){const F=!!(Ko!=null&&Ko.TESTING_REMOTELY),K=o.env.version,X=new Headers;if(X.set("User-Agent",`transformers.js/${K}; is_ci/${F};`),g(E,["http:","https:"],["huggingface.co","hf.co"])){const ie=(Ko==null?void 0:Ko.HF_TOKEN)??(Ko==null?void 0:Ko.HF_ACCESS_TOKEN);ie&&X.set("Authorization",`Bearer ${ie}`)}return fetch(E,{headers:X})}else return fetch(E)}const b={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};function k(E,A,F){if(!F)return null;const K=b[E]??`Error (${E}) occurred while trying to load file`;throw Error(`${K}: "${A}".`)}class L{constructor(A){this.path=A}async match(A){let F=l.join(this.path,A),K=new f(F);if(K.exists)return K}async put(A,F,K=void 0){let X=l.join(this.path,A);try{const oe=F.headers.get("Content-Length"),ie=parseInt(oe??"0");let J=0;await i.promises.mkdir(l.dirname(X),{recursive:!0});const ue=i.createWriteStream(X),ne=F.body.getReader();for(;;){const{done:G,value:se}=await ne.read();if(G)break;await new Promise((ge,W)=>{ue.write(se,U=>{if(U){W(U);return}ge()})}),J+=se.length;const ce=ie?J/ie*100:0;K==null||K({progress:ce,loaded:J,total:ie})}ue.close()}catch(oe){try{await i.promises.unlink(X)}catch{}throw oe}}}async function C(E,...A){for(let F of A)try{let K=await E.match(F);if(K)return K}catch{continue}}async function S(E,A,F=!0,K={},X=!1){if(!o.env.allowLocalModels){if(K.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!o.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}(0,c.dispatchCallback)(K.progress_callback,{status:"initiate",name:E,file:A});let oe;if(!oe&&o.env.useBrowserCache){if(typeof caches>"u")throw Error("Browser cache is not available in this environment.");try{oe=await caches.open("transformers-cache")}catch(le){console.warn("An error occurred while opening the browser cache:",le)}}if(!oe&&o.env.useFSCache&&(oe=new L(K.cache_dir??o.env.cacheDir)),!oe&&o.env.useCustomCache){if(!o.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!o.env.customCache.match||!o.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");oe=o.env.customCache}const ie=K.revision??"main",J=x(E,A),ue=y(E),ne=ue?x(o.env.localModelPath,J):J,G=x(o.env.remoteHost,o.env.remotePathTemplate.replaceAll("{model}",E).replaceAll("{revision}",encodeURIComponent(ie)),A);let se;const ce=oe instanceof L?ie==="main"?J:x(E,ie,A):G;let ge=!1,W;oe&&(W=await C(oe,ne,ce));const U=W!==void 0;if(W===void 0){if(o.env.allowLocalModels)if(g(J,["http:","https:"])){if(K.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${J}.`);if(!o.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${J}.`)}else try{W=await T(ne),se=ne}catch(re){console.warn(`Unable to load from local path "${ne}": "${re}"`)}if(W===void 0||W.status===404){if(K.local_files_only||!o.env.allowRemoteModels){if(F)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${ne}".`);return null}if(!ue)throw Error(`Local file missing at "${ne}" and download aborted due to invalid model ID "${E}".`);if(W=await T(G),W.status!==200)return k(W.status,G,F);se=ce}ge=oe&&typeof Response<"u"&&W instanceof Response&&W.status===200}(0,c.dispatchCallback)(K.progress_callback,{status:"download",name:E,file:A});let B;if(!(o.apis.IS_NODE_ENV&&X)){let le;K.progress_callback?U&&typeof navigator<"u"&&/firefox/i.test(navigator.userAgent)?(le=new Uint8Array(await W.arrayBuffer()),(0,c.dispatchCallback)(K.progress_callback,{status:"progress",name:E,file:A,progress:100,loaded:le.length,total:le.length})):le=await O(W,re=>{(0,c.dispatchCallback)(K.progress_callback,{status:"progress",name:E,file:A,...re})}):le=new Uint8Array(await W.arrayBuffer()),B=le}if(ge&&se&&await oe.match(se)===void 0&&(B?await oe.put(se,new Response(B,{headers:W.headers})).catch(le=>{console.warn(`Unable to add response to browser cache: ${le}.`)}):await oe.put(se,W,K.progress_callback)),(0,c.dispatchCallback)(K.progress_callback,{status:"done",name:E,file:A}),B){if(X)throw new Error("Cannot return path in a browser environment.");return B}if(W instanceof f)return W.filePath;const Q=await oe.match(se);if(Q instanceof f)return Q.filePath;throw new Error("Unable to return path for response.")}async function I(E,A,F=!0,K={}){const X=await S(E,A,F,K,!1);if(X===null)return{};const ie=new TextDecoder("utf-8").decode(X);return JSON.parse(ie)}async function O(E,A){const F=E.headers.get("Content-Length");F===null&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let K=parseInt(F??"0"),X=new Uint8Array(K),oe=0;const ie=E.body.getReader();async function J(){const{done:ue,value:ne}=await ie.read();if(ue)return;const G=oe+ne.length;if(G>K){K=G;const ce=new Uint8Array(K);ce.set(X),X=ce}X.set(ne,oe),oe=G;const se=oe/K*100;return A({progress:se,loaded:oe,total:K}),J()}return await J(),X}function x(...E){return E=E.map((A,F)=>(F&&(A=A.replace(new RegExp("^/"),"")),F!==E.length-1&&(A=A.replace(new RegExp("/$"),"")),A)),E.join("/")}},"./src/utils/image.js":(t,s,n)=>{n.r(s),n.d(s,{RawImage:()=>b,load_image:()=>k});var i=n("./src/utils/core.js"),l=n("./src/utils/hub.js"),o=n("./src/env.js"),c=n("./src/utils/tensor.js"),p=n("?2b25");let d,f,g;const _=o.apis.IS_BROWSER_ENV||o.apis.IS_WEBWORKER_ENV;if(_)d=(L,C)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(L,C)},g=self.createImageBitmap,f=self.ImageData;else if(p)g=async L=>{const S=(await L.metadata()).channels,{data:I,info:O}=await L.rotate().raw().toBuffer({resolveWithObject:!0}),x=new b(new Uint8ClampedArray(I),O.width,O.height,O.channels);return S!==void 0&&S!==O.channels&&x.convert(S),x};else throw new Error("Unable to load image processing library.");const y={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},T=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class b{constructor(C,S,I,O){this.data=C,this.width=S,this.height=I,this.channels=O}get size(){return[this.width,this.height]}static async read(C){if(C instanceof b)return C;if(typeof C=="string"||C instanceof URL)return await this.fromURL(C);if(C instanceof Blob)return await this.fromBlob(C);if(typeof HTMLCanvasElement<"u"&&C instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&C instanceof OffscreenCanvas)return this.fromCanvas(C);throw new Error(`Unsupported input type: ${typeof C}`)}static fromCanvas(C){if(!_)throw new Error("fromCanvas() is only supported in browser environments.");const I=C.getContext("2d").getImageData(0,0,C.width,C.height).data;return new b(I,C.width,C.height,4)}static async fromURL(C){const S=await(0,l.getFile)(C);if(S.status!==200)throw new Error(`Unable to read image from "${C}" (${S.status} ${S.statusText})`);const I=await S.blob();return this.fromBlob(I)}static async fromBlob(C){if(_){const S=await g(C),I=d(S.width,S.height).getContext("2d");return I.drawImage(S,0,0),new this(I.getImageData(0,0,S.width,S.height).data,S.width,S.height,4)}else{const S=p(await C.arrayBuffer());return await g(S)}}static fromTensor(C,S="CHW"){if(C.dims.length!==3)throw new Error(`Tensor should have 3 dimensions, but has ${C.dims.length} dimensions.`);if(S==="CHW")C=C.transpose(1,2,0);else if(S!=="HWC")throw new Error(`Unsupported channel format: ${S}`);if(!(C.data instanceof Uint8ClampedArray||C.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${C.type}`);switch(C.dims[2]){case 1:case 2:case 3:case 4:return new b(C.data,C.dims[1],C.dims[0],C.dims[2]);default:throw new Error(`Unsupported number of channels: ${C.dims[2]}`)}}grayscale(){if(this.channels===1)return this;const C=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let S=0,I=0;S<this.data.length;S+=this.channels){const O=this.data[S],x=this.data[S+1],E=this.data[S+2];C[I++]=Math.round(.2989*O+.587*x+.114*E)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(C,this.width,this.height,1)}rgb(){if(this.channels===3)return this;const C=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let S=0,I=0;S<this.data.length;++S)C[I++]=this.data[S],C[I++]=this.data[S],C[I++]=this.data[S];break;case 4:for(let S=0,I=0;S<this.data.length;S+=4)C[I++]=this.data[S],C[I++]=this.data[S+1],C[I++]=this.data[S+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(C,this.width,this.height,3)}rgba(){if(this.channels===4)return this;const C=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let S=0,I=0;S<this.data.length;++S)C[I++]=this.data[S],C[I++]=this.data[S],C[I++]=this.data[S],C[I++]=255;break;case 3:for(let S=0,I=0;S<this.data.length;S+=3)C[I++]=this.data[S],C[I++]=this.data[S+1],C[I++]=this.data[S+2],C[I++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(C,this.width,this.height,4)}putAlpha(C){if(C.width!==this.width||C.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${C.width}x${C.height}`);if(C.channels!==1)throw new Error(`Expected mask to have 1 channel, but got ${C.channels}`);const S=this.data,I=C.data,O=this.width*this.height;if(this.channels===3){const x=new Uint8ClampedArray(O*4);for(let E=0,A=0,F=0;E<O;++E)x[F++]=S[A++],x[F++]=S[A++],x[F++]=S[A++],x[F++]=I[E];return this._update(x,this.width,this.height,4)}else if(this.channels===4){for(let x=0;x<O;++x)S[4*x+3]=I[x];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(C,S,{resample:I=2}={}){if(this.width===C&&this.height===S)return this;let O=y[I]??I;const x=(0,i.isNullishDimension)(C),E=(0,i.isNullishDimension)(S);if(x&&E)return this;if(x?C=S/this.height*this.width:E&&(S=C/this.width*this.height),_){const A=this.channels,F=this.toCanvas(),K=d(C,S).getContext("2d");return K.drawImage(F,0,0,C,S),new b(K.getImageData(0,0,C,S).data,C,S,4).convert(A)}else{let A=this.toSharp();switch(O){case"box":case"hamming":(O==="box"||O==="hamming")&&(console.warn(`Resampling method ${O} is not yet supported. Using bilinear instead.`),O="bilinear");case"nearest":case"bilinear":case"bicubic":A=A.affine([C/this.width,0,0,S/this.height],{interpolator:O});break;case"lanczos":A=A.resize({width:C,height:S,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${O} is not supported.`)}return await g(A)}}async pad([C,S,I,O]){if(C=Math.max(C,0),S=Math.max(S,0),I=Math.max(I,0),O=Math.max(O,0),C===0&&S===0&&I===0&&O===0)return this;if(_){const x=this.channels,E=this.toCanvas(),A=this.width+C+S,F=this.height+I+O,K=d(A,F).getContext("2d");return K.drawImage(E,0,0,this.width,this.height,C,I,this.width,this.height),new b(K.getImageData(0,0,A,F).data,A,F,4).convert(x)}else{const x=this.toSharp().extend({left:C,right:S,top:I,bottom:O});return await g(x)}}async crop([C,S,I,O]){if(C=Math.max(C,0),S=Math.max(S,0),I=Math.min(I,this.width-1),O=Math.min(O,this.height-1),C===0&&S===0&&I===this.width-1&&O===this.height-1)return this;const x=I-C+1,E=O-S+1;if(_){const A=this.channels,F=this.toCanvas(),K=d(x,E).getContext("2d");return K.drawImage(F,C,S,x,E,0,0,x,E),new b(K.getImageData(0,0,x,E).data,x,E,4).convert(A)}else{const A=this.toSharp().extract({left:C,top:S,width:x,height:E});return await g(A)}}async center_crop(C,S){if(this.width===C&&this.height===S)return this;const I=(this.width-C)/2,O=(this.height-S)/2;if(_){const x=this.channels,E=this.toCanvas(),A=d(C,S).getContext("2d");let F=0,K=0,X=0,oe=0;return I>=0?F=I:X=-I,O>=0?K=O:oe=-O,A.drawImage(E,F,K,C,S,X,oe,C,S),new b(A.getImageData(0,0,C,S).data,C,S,4).convert(x)}else{let x=this.toSharp();if(I>=0&&O>=0)x=x.extract({left:Math.floor(I),top:Math.floor(O),width:C,height:S});else if(I<=0&&O<=0){const E=Math.floor(-O),A=Math.floor(-I);x=x.extend({top:E,left:A,right:C-this.width-A,bottom:S-this.height-E})}else{let E=[0,0],A=0;O<0?(E[0]=Math.floor(-O),E[1]=S-this.height-E[0]):A=Math.floor(O);let F=[0,0],K=0;I<0?(F[0]=Math.floor(-I),F[1]=C-this.width-F[0]):K=Math.floor(I),x=x.extend({top:E[0],bottom:E[1],left:F[0],right:F[1]}).extract({left:K,top:A,width:C,height:S})}return await g(x)}}async toBlob(C="image/png",S=1){if(!_)throw new Error("toBlob() is only supported in browser environments.");return await this.toCanvas().convertToBlob({type:C,quality:S})}toTensor(C="CHW"){let S=new c.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if(C!=="HWC")if(C==="CHW")S=S.permute(2,0,1);else throw new Error(`Unsupported channel format: ${C}`);return S}toCanvas(){if(!_)throw new Error("toCanvas() is only supported in browser environments.");const C=this.clone().rgba(),S=d(C.width,C.height),I=new f(C.data,C.width,C.height);return S.getContext("2d").putImageData(I,0,0),S}split(){const{data:C,width:S,height:I,channels:O}=this,x=C.constructor,E=C.length/O,A=Array.from({length:O},()=>new x(E));for(let F=0;F<E;++F){const K=O*F;for(let X=0;X<O;++X)A[X][F]=C[K+X]}return A.map(F=>new b(F,S,I,1))}_update(C,S,I,O=null){return this.data=C,this.width=S,this.height=I,O!==null&&(this.channels=O),this}clone(){return new b(this.data.slice(),this.width,this.height,this.channels)}convert(C){if(this.channels===C)return this;switch(C){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(C){if(_){if(o.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const S=C.split(".").pop().toLowerCase(),I=T.get(S)??"image/png",O=await this.toBlob(I);(0,i.saveBlob)(C,O)}else{if(o.apis.IS_FS_AVAILABLE)return await this.toSharp().toFile(C);throw new Error("Unable to save the image because filesystem is disabled in this environment.")}}toSharp(){if(_)throw new Error("toSharp() is only supported in server-side environments.");return p(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const k=b.read.bind(b)},"./src/utils/maths.js":(t,s,n)=>{n.r(s),n.d(s,{FFT:()=>k,bankers_round:()=>S,cos_sim:()=>d,dot:()=>p,dynamic_time_warping:()=>I,interpolate_data:()=>i,log_softmax:()=>c,magnitude:()=>f,max:()=>_,medianFilter:()=>L,min:()=>g,permute_data:()=>l,round:()=>C,softmax:()=>o});function i(O,[x,E,A],[F,K],X="bilinear",oe=!1){const ie=K/A,J=F/E,ue=new O.constructor(F*K*x),ne=E*A,G=F*K;for(let se=0;se<F;++se)for(let ce=0;ce<K;++ce){const ge=se*K+ce,W=(ce+.5)/ie-.5,U=(se+.5)/J-.5;let B=Math.floor(W),Q=Math.floor(U);const le=Math.min(B+1,A-1),re=Math.min(Q+1,E-1);B=Math.max(B,0),Q=Math.max(Q,0);const ve=W-B,Se=U-Q,Be=(1-ve)*(1-Se),ut=ve*(1-Se),Oe=(1-ve)*Se,ae=ve*Se,Z=Q*A,Ee=re*A,Ve=Z+B,Ue=Z+le,qe=Ee+B,We=Ee+le;for(let nt=0;nt<x;++nt){const at=nt*ne;ue[nt*G+ge]=Be*O[at+Ve]+ut*O[at+Ue]+Oe*O[at+qe]+ae*O[at+We]}}return ue}function l(O,x,E){const A=new Array(E.length),F=new Array(E.length);for(let oe=E.length-1,ie=1;oe>=0;--oe)F[oe]=ie,A[oe]=x[E[oe]],ie*=A[oe];const K=E.map((oe,ie)=>F[E.indexOf(ie)]),X=new O.constructor(O.length);for(let oe=0;oe<O.length;++oe){let ie=0;for(let J=x.length-1,ue=oe;J>=0;--J)ie+=ue%x[J]*K[J],ue=Math.floor(ue/x[J]);X[ie]=O[oe]}return[X,A]}function o(O){const x=_(O)[0],E=O.map(K=>Math.exp(K-x)),A=E.reduce((K,X)=>K+X,0);return E.map(K=>K/A)}function c(O){const x=_(O)[0];let E=0;for(let K=0;K<O.length;++K)E+=Math.exp(O[K]-x);const A=Math.log(E);return O.map(K=>K-x-A)}function p(O,x){let E=0;for(let A=0;A<O.length;++A)E+=O[A]*x[A];return E}function d(O,x){const E=p(O,x),A=f(O),F=f(x);return E/(A*F)}function f(O){return Math.sqrt(O.reduce((x,E)=>x+E*E,0))}function g(O){if(O.length===0)throw Error("Array must not be empty");let x=O[0],E=0;for(let A=1;A<O.length;++A)O[A]<x&&(x=O[A],E=A);return[x,E]}function _(O){if(O.length===0)throw Error("Array must not be empty");let x=O[0],E=0;for(let A=1;A<O.length;++A)O[A]>x&&(x=O[A],E=A);return[x,E]}function y(O){return O>0&&(O&O-1)===0}class T{constructor(x){if(this.size=x|0,this.size<=1||!y(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=x<<1,this.table=new Float64Array(this.size*2);for(let A=0;A<this.table.length;A+=2){const F=Math.PI*A/this.size;this.table[A]=Math.cos(F),this.table[A+1]=-Math.sin(F)}let E=0;for(let A=1;this.size>A;A<<=1)++E;this._width=E%2===0?E-1:E,this._bitrev=new Int32Array(1<<this._width);for(let A=0;A<this._bitrev.length;++A){this._bitrev[A]=0;for(let F=0;F<this._width;F+=2){const K=this._width-F-2;this._bitrev[A]|=(A>>>F&3)<<K}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(x,E){const A=E||new Array(x.length>>>1);for(let F=0;F<x.length;F+=2)A[F>>>1]=x[F];return A}toComplexArray(x,E){const A=E||this.createComplexArray();for(let F=0;F<A.length;F+=2)A[F]=x[F>>>1],A[F+1]=0;return A}transform(x,E){if(x===E)throw new Error("Input and output buffers must be different");this._transform4(x,E,1)}realTransform(x,E){if(x===E)throw new Error("Input and output buffers must be different");this._realTransform4(x,E,1)}inverseTransform(x,E){if(x===E)throw new Error("Input and output buffers must be different");this._transform4(x,E,-1);for(let A=0;A<x.length;++A)x[A]/=this.size}_transform4(x,E,A){const F=this._csize;let X=1<<this._width,oe=F/X<<1,ie,J;const ue=this._bitrev;if(oe===4)for(ie=0,J=0;ie<F;ie+=oe,++J){const G=ue[J];this._singleTransform2(E,x,ie,G,X)}else for(ie=0,J=0;ie<F;ie+=oe,++J){const G=ue[J];this._singleTransform4(E,x,ie,G,X,A)}const ne=this.table;for(X>>=2;X>=2;X>>=2){oe=F/X<<1;const G=oe>>>2;for(ie=0;ie<F;ie+=oe){const se=ie+G-1;for(let ce=ie,ge=0;ce<se;ce+=2,ge+=X){const W=ce,U=W+G,B=U+G,Q=B+G,le=x[W],re=x[W+1],ve=x[U],Se=x[U+1],Be=x[B],ut=x[B+1],Oe=x[Q],ae=x[Q+1],Z=ne[ge],Ee=A*ne[ge+1],Ve=ve*Z-Se*Ee,Ue=ve*Ee+Se*Z,qe=ne[2*ge],We=A*ne[2*ge+1],nt=Be*qe-ut*We,at=Be*We+ut*qe,ct=ne[3*ge],V=A*ne[3*ge+1],fe=Oe*ct-ae*V,q=Oe*V+ae*ct,pe=le+nt,we=re+at,Fe=le-nt,De=re-at,rt=Ve+fe,He=Ue+q,it=A*(Ve-fe),mt=A*(Ue-q);x[W]=pe+rt,x[W+1]=we+He,x[U]=Fe+mt,x[U+1]=De-it,x[B]=pe-rt,x[B+1]=we-He,x[Q]=Fe-mt,x[Q+1]=De+it}}}}_singleTransform2(x,E,A,F,K){const X=x[F],oe=x[F+1],ie=x[F+K],J=x[F+K+1];E[A]=X+ie,E[A+1]=oe+J,E[A+2]=X-ie,E[A+3]=oe-J}_singleTransform4(x,E,A,F,K,X){const oe=K*2,ie=K*3,J=x[F],ue=x[F+1],ne=x[F+K],G=x[F+K+1],se=x[F+oe],ce=x[F+oe+1],ge=x[F+ie],W=x[F+ie+1],U=J+se,B=ue+ce,Q=J-se,le=ue-ce,re=ne+ge,ve=G+W,Se=X*(ne-ge),Be=X*(G-W);E[A]=U+re,E[A+1]=B+ve,E[A+2]=Q+Be,E[A+3]=le-Se,E[A+4]=U-re,E[A+5]=B-ve,E[A+6]=Q-Be,E[A+7]=le+Se}_realTransform4(x,E,A){const F=this._csize;let X=1<<this._width,oe=F/X<<1,ie,J;const ue=this._bitrev;if(oe===4)for(ie=0,J=0;ie<F;ie+=oe,++J){const se=ue[J];this._singleRealTransform2(E,x,ie,se>>>1,X>>>1)}else for(ie=0,J=0;ie<F;ie+=oe,++J){const se=ue[J];this._singleRealTransform4(E,x,ie,se>>>1,X>>>1,A)}const ne=this.table;for(X>>=2;X>=2;X>>=2){oe=F/X<<1;const se=oe>>>1,ce=se>>>1,ge=ce>>>1;for(ie=0;ie<F;ie+=oe)for(let W=0,U=0;W<=ge;W+=2,U+=X){const B=ie+W,Q=B+ce,le=Q+ce,re=le+ce,ve=x[B],Se=x[B+1],Be=x[Q],ut=x[Q+1],Oe=x[le],ae=x[le+1],Z=x[re],Ee=x[re+1],Ve=ve,Ue=Se,qe=ne[U],We=A*ne[U+1],nt=Be*qe-ut*We,at=Be*We+ut*qe,ct=ne[2*U],V=A*ne[2*U+1],fe=Oe*ct-ae*V,q=Oe*V+ae*ct,pe=ne[3*U],we=A*ne[3*U+1],Fe=Z*pe-Ee*we,De=Z*we+Ee*pe,rt=Ve+fe,He=Ue+q,it=Ve-fe,mt=Ue-q,_t=nt+Fe,Ot=at+De,Ft=A*(nt-Fe),Dn=A*(at-De);if(x[B]=rt+_t,x[B+1]=He+Ot,x[Q]=it+Dn,x[Q+1]=mt-Ft,W===0){x[le]=rt-_t,x[le+1]=He-Ot;continue}if(W===ge)continue;const hn=ie+ce-W,Kn=ie+se-W;x[hn]=it-A*Dn,x[hn+1]=-mt-A*Ft,x[Kn]=rt-A*_t,x[Kn+1]=-He+A*Ot}}const G=F>>>1;for(let se=2;se<G;se+=2)x[F-se]=x[se],x[F-se+1]=-x[se+1]}_singleRealTransform2(x,E,A,F,K){const X=x[F],oe=x[F+K];E[A]=X+oe,E[A+1]=0,E[A+2]=X-oe,E[A+3]=0}_singleRealTransform4(x,E,A,F,K,X){const oe=K*2,ie=K*3,J=x[F],ue=x[F+K],ne=x[F+oe],G=x[F+ie],se=J+ne,ce=J-ne,ge=ue+G,W=X*(ue-G);E[A]=se+ge,E[A+1]=0,E[A+2]=ce,E[A+3]=-W,E[A+4]=se-ge,E[A+5]=0,E[A+6]=ce,E[A+7]=W}}class b{constructor(x){const E=2*(x-1),A=2*(2*x-1),F=2**Math.ceil(Math.log2(A));this.bufferSize=F,this._a=E;const K=new Float64Array(A),X=new Float64Array(F);this._chirpBuffer=new Float64Array(F),this._buffer1=new Float64Array(F),this._buffer2=new Float64Array(F),this._outBuffer1=new Float64Array(F),this._outBuffer2=new Float64Array(F);const oe=-2*Math.PI/x,ie=Math.cos(oe),J=Math.sin(oe);for(let ue=0;ue<A>>1;++ue){const ne=(ue+1-x)**2/2,G=Math.sqrt(ie**2+J**2)**ne,se=ne*Math.atan2(J,ie),ce=2*ue;K[ce]=G*Math.cos(se),K[ce+1]=G*Math.sin(se),X[ce]=K[ce],X[ce+1]=-K[ce+1]}this._slicedChirpBuffer=K.subarray(E,A),this._f=new T(F>>1),this._f.transform(this._chirpBuffer,X)}_transform(x,E,A){const F=this._buffer1,K=this._buffer2,X=this._outBuffer1,oe=this._outBuffer2,ie=this._chirpBuffer,J=this._slicedChirpBuffer,ue=this._a;if(A)for(let ne=0;ne<J.length;ne+=2){const G=ne+1,se=ne>>1,ce=E[se];F[ne]=ce*J[ne],F[G]=ce*J[G]}else for(let ne=0;ne<J.length;ne+=2){const G=ne+1;F[ne]=E[ne]*J[ne]-E[G]*J[G],F[G]=E[ne]*J[G]+E[G]*J[ne]}this._f.transform(X,F);for(let ne=0;ne<ie.length;ne+=2){const G=ne+1;K[ne]=X[ne]*ie[ne]-X[G]*ie[G],K[G]=X[ne]*ie[G]+X[G]*ie[ne]}this._f.inverseTransform(oe,K);for(let ne=0;ne<oe.length;ne+=2){const G=oe[ne+ue],se=oe[ne+ue+1],ce=J[ne],ge=J[ne+1];x[ne]=G*ce-se*ge,x[ne+1]=G*ge+se*ce}}transform(x,E){this._transform(x,E,!1)}realTransform(x,E){this._transform(x,E,!0)}}class k{constructor(x){this.fft_length=x,this.isPowerOfTwo=y(x),this.isPowerOfTwo?(this.fft=new T(x),this.outputBufferSize=2*x):(this.fft=new b(x),this.outputBufferSize=this.fft.bufferSize)}realTransform(x,E){this.fft.realTransform(x,E)}transform(x,E){this.fft.transform(x,E)}}function L(O,x){if(x%2===0||x<=0)throw new Error("Window size must be a positive odd number");const E=new O.constructor(O.length),A=new O.constructor(x),F=Math.floor(x/2);for(let K=0;K<O.length;++K){let X=0;for(let oe=-F;oe<=F;++oe){let ie=K+oe;ie<0?ie=Math.abs(ie):ie>=O.length&&(ie=2*(O.length-1)-ie),A[X++]=O[ie]}A.sort(),E[K]=A[F]}return E}function C(O,x){const E=Math.pow(10,x);return Math.round(O*E)/E}function S(O){const x=Math.round(O);return Math.abs(O)%1===.5?x%2===0?x:x-1:x}function I(O){const x=O.length,E=O[0].length,A=[x+1,E+1],F=Array.from({length:A[0]},()=>Array(A[1]).fill(1/0));F[0][0]=0;const K=Array.from({length:A[0]},()=>Array(A[1]).fill(-1));for(let ue=1;ue<A[1];++ue)for(let ne=1;ne<A[0];++ne){const G=F[ne-1][ue-1],se=F[ne-1][ue],ce=F[ne][ue-1];let ge,W;G<se&&G<ce?(ge=G,W=0):se<G&&se<ce?(ge=se,W=1):(ge=ce,W=2),F[ne][ue]=O[ne-1][ue-1]+ge,K[ne][ue]=W}for(let ue=0;ue<A[1];++ue)K[0][ue]=2;for(let ue=0;ue<A[0];++ue)K[ue][0]=1;let X=x,oe=E,ie=[],J=[];for(;X>0||oe>0;)switch(ie.push(X-1),J.push(oe-1),K[X][oe]){case 0:--X,--oe;break;case 1:--X;break;case 2:--oe;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${X}, ${oe}]. Please file a bug report.`)}return ie.reverse(),J.reverse(),[ie,J]}},"./src/utils/tensor.js":(t,s,n)=>{n.r(s),n.d(s,{DataTypeMap:()=>c,Tensor:()=>p,cat:()=>E,full:()=>J,full_like:()=>ue,interpolate:()=>g,interpolate_4d:()=>_,layer_norm:()=>S,matmul:()=>y,mean:()=>X,mean_pooling:()=>C,ones:()=>ne,ones_like:()=>G,permute:()=>f,quantize_embeddings:()=>W,rand:()=>ge,rfft:()=>T,slice:()=>L,stack:()=>A,std_mean:()=>K,topk:()=>b,zeros:()=>se,zeros_like:()=>ce});var i=n("./src/utils/maths.js"),l=n("./src/backends/onnx.js"),o=n("./src/ops/registry.js");const c=Object.freeze({float32:Float32Array,float16:typeof Float16Array<"u"?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class p{constructor(...B){he(this,"ort_tensor");return(0,l.isONNXTensor)(B[0])?this.ort_tensor=B[0]:this.ort_tensor=new l.Tensor(B[0],B[1],B[2]),new Proxy(this,{get:(Q,le)=>{if(typeof le=="string"){let re=Number(le);if(Number.isInteger(re))return Q._getitem(re)}return Q[le]},set:(Q,le,re)=>Q[le]=re})}get dims(){return this.ort_tensor.dims}set dims(B){this.ort_tensor.dims=B}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[B,...Q]=this.dims;if(Q.length>0){const le=Q.reduce((re,ve)=>re*ve);for(let re=0;re<B;++re)yield this._subarray(re,le,Q)}else yield*this.data}_getitem(B){const[Q,...le]=this.dims;if(B=x(B,Q),le.length>0){const re=le.reduce((ve,Se)=>ve*Se);return this._subarray(B,re,le)}else return new p(this.type,[this.data[B]],le)}indexOf(B){const Q=this.data;for(let le=0;le<Q.length;++le)if(Q[le]==B)return le;return-1}_subarray(B,Q,le){const re=B*Q,ve=(B+1)*Q,Se="subarray"in this.data?this.data.subarray(re,ve):this.data.slice(re,ve);return new p(this.type,Se,le)}item(){const B=this.data;if(B.length!==1)throw new Error(`a Tensor with ${B.length} elements cannot be converted to Scalar`);return B[0]}tolist(){return d(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const B=this.data;for(let Q=0;Q<B.length;++Q)B[Q]=1/(1+Math.exp(-B[Q]));return this}map(B){return this.clone().map_(B)}map_(B){const Q=this.data;for(let le=0;le<Q.length;++le)Q[le]=B(Q[le],le,Q);return this}mul(B){return this.clone().mul_(B)}mul_(B){const Q=this.data;for(let le=0;le<Q.length;++le)Q[le]*=B;return this}div(B){return this.clone().div_(B)}div_(B){const Q=this.data;for(let le=0;le<Q.length;++le)Q[le]/=B;return this}add(B){return this.clone().add_(B)}add_(B){const Q=this.data;for(let le=0;le<Q.length;++le)Q[le]+=B;return this}sub(B){return this.clone().sub_(B)}sub_(B){const Q=this.data;for(let le=0;le<Q.length;++le)Q[le]-=B;return this}clone(){return new p(this.type,this.data.slice(),this.dims.slice())}slice(...B){const Q=[],le=[];for(let Oe=0;Oe<this.dims.length;++Oe){let ae=B[Oe];if(ae==null)le.push([0,this.dims[Oe]]),Q.push(this.dims[Oe]);else if(typeof ae=="number")ae=x(ae,this.dims[Oe],Oe),le.push([ae,ae+1]);else if(Array.isArray(ae)&&ae.length===2){let[Z,Ee]=ae;if(Z=Z===null?0:x(Z,this.dims[Oe],Oe,!1),Ee=Ee===null?this.dims[Oe]:x(Ee,this.dims[Oe],Oe,!1),Z>Ee)throw new Error(`Invalid slice: ${ae}`);const Ve=[Math.max(Z,0),Math.min(Ee,this.dims[Oe])];le.push(Ve),Q.push(Ve[1]-Ve[0])}else throw new Error(`Invalid slice: ${ae}`)}const re=le.map(([Oe,ae])=>ae-Oe),ve=re.reduce((Oe,ae)=>Oe*ae),Se=this.data,Be=new Se.constructor(ve),ut=this.stride();for(let Oe=0;Oe<ve;++Oe){let ae=0;for(let Z=re.length-1,Ee=Oe;Z>=0;--Z){const Ve=re[Z];ae+=(Ee%Ve+le[Z][0])*ut[Z],Ee=Math.floor(Ee/Ve)}Be[Oe]=Se[ae]}return new p(this.type,Be,Q)}permute(...B){return f(this,B)}transpose(...B){return this.permute(...B)}sum(B=null,Q=!1){return this.norm(1,B,Q)}norm(B="fro",Q=null,le=!1){if(B==="fro")B=2;else if(typeof B=="string")throw Error(`Unsupported norm: ${B}`);const re=this.data,ve=(Oe,ae)=>Oe+ae**B;if(Q===null){const Oe=re.reduce(ve,0)**(1/B);return new p(this.type,[Oe],[])}const[Se,Be,ut]=F(ve,this,Q,le);if(B!==1)for(let Oe=0;Oe<Be.length;++Oe)Be[Oe]=Be[Oe]**(1/B);return new p(Se,Be,ut)}normalize_(B=2,Q=1){Q=x(Q,this.dims.length);const le=this.norm(B,Q,!0),re=this.data,ve=le.data;for(let Se=0;Se<re.length;++Se){let Be=0;for(let ut=this.dims.length-1,Oe=Se,ae=1;ut>=0;--ut){const Z=this.dims[ut];if(ut!==Q){const Ee=Oe%Z;Be+=Ee*ae,ae*=this.dims[ut]}Oe=Math.floor(Oe/Z)}re[Se]/=ve[Be]}return this}normalize(B=2,Q=1){return this.clone().normalize_(B,Q)}stride(){return oe(this.dims)}squeeze(B=null){return new p(this.type,this.data,I(this.dims,B))}squeeze_(B=null){return this.dims=I(this.dims,B),this}unsqueeze(B=null){return new p(this.type,this.data,O(this.dims,B))}unsqueeze_(B=null){return this.dims=O(this.dims,B),this}flatten_(B=0,Q=-1){Q=(Q+this.dims.length)%this.dims.length;let le=this.dims.slice(0,B),re=this.dims.slice(B,Q+1),ve=this.dims.slice(Q+1);return this.dims=[...le,re.reduce((Se,Be)=>Se*Be,1),...ve],this}flatten(B=0,Q=-1){return this.clone().flatten_(B,Q)}view(...B){let Q=-1;for(let re=0;re<B.length;++re)if(B[re]===-1){if(Q!==-1)throw new Error("Only one dimension can be inferred");Q=re}const le=this.data;if(Q!==-1){const re=B.reduce((ve,Se,Be)=>Be!==Q?ve*Se:ve,1);B[Q]=le.length/re}return new p(this.type,le,B)}neg_(){const B=this.data;for(let Q=0;Q<B.length;++Q)B[Q]=-B[Q];return this}neg(){return this.clone().neg_()}gt(B){const Q=new Uint8Array(this.data.length),le=this.data;for(let re=0;re<le.length;++re)Q[re]=le[re]>B?1:0;return new p("bool",Q,this.dims)}lt(B){const Q=new Uint8Array(this.data.length),le=this.data;for(let re=0;re<le.length;++re)Q[re]=le[re]<B?1:0;return new p("bool",Q,this.dims)}clamp_(B,Q){const le=this.data;for(let re=0;re<le.length;++re)le[re]=Math.min(Math.max(le[re],B),Q);return this}clamp(B,Q){return this.clone().clamp_(B,Q)}round_(){const B=this.data;for(let Q=0;Q<B.length;++Q)B[Q]=Math.round(B[Q]);return this}round(){return this.clone().round_()}mean(B=null,Q=!1){return X(this,B,Q)}min(B=null,Q=!1){if(B===null){const Se=(0,i.min)(this.data)[0];return new p(this.type,[Se],[])}const[le,re,ve]=F((Se,Be)=>Math.min(Se,Be),this,B,Q,1/0);return new p(le,re,ve)}max(B=null,Q=!1){if(B===null){const Se=(0,i.max)(this.data)[0];return new p(this.type,[Se],[])}const[le,re,ve]=F((Se,Be)=>Math.max(Se,Be),this,B,Q,-1/0);return new p(le,re,ve)}argmin(B=null,Q=!1){if(B!==null)throw new Error("`dim !== null` not yet implemented.");const le=(0,i.min)(this.data)[1];return new p("int64",[BigInt(le)],[])}argmax(B=null,Q=!1){if(B!==null)throw new Error("`dim !== null` not yet implemented.");const le=(0,i.max)(this.data)[1];return new p("int64",[BigInt(le)],[])}to(B){if(this.type===B)return this;if(!c.hasOwnProperty(B))throw new Error(`Unsupported type: ${B}`);let Q;const le=["int64","uint64"].includes(this.type),re=["int64","uint64"].includes(B);return le&&!re?Q=Number:!le&&re&&(Q=BigInt),new p(B,c[B].from(this.data,Q),this.dims)}}function d(U,B){const Q=U.length,le=B.reduce((ve,Se)=>ve*Se);if(Q!==le)throw Error(`cannot reshape array of size ${Q} into shape (${B})`);let re=U;for(let ve=B.length-1;ve>=0;ve--)re=re.reduce((Se,Be)=>{let ut=Se[Se.length-1];return ut.length<B[ve]?ut.push(Be):Se.push([Be]),Se},[[]]);return re[0]}function f(U,B){const[Q,le]=(0,i.permute_data)(U.data,U.dims,B);return new p(U.type,Q,le)}function g(U,[B,Q],le="bilinear",re=!1){const ve=U.dims.at(-3)??1,Se=U.dims.at(-2),Be=U.dims.at(-1);let ut=(0,i.interpolate_data)(U.data,[ve,Se,Be],[B,Q],le,re);return new p(U.type,ut,[ve,B,Q])}async function _(U,{size:B=null,mode:Q="bilinear"}={}){if(U.dims.length!==4)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!B)throw new Error("`interpolate_4d` requires a `size` argument.");let le;if(B.length===2)le=[...U.dims.slice(0,2),...B];else if(B.length===3)le=[U.dims[0],...B];else if(B.length===4)le=B;else throw new Error("`size` must be of length 2, 3, or 4.");let re;if(Q==="nearest")re=await o.TensorOpRegistry.nearest_interpolate_4d;else if(Q==="bilinear")re=await o.TensorOpRegistry.bilinear_interpolate_4d;else if(Q==="bicubic")re=await o.TensorOpRegistry.bicubic_interpolate_4d;else throw new Error(`Unsupported mode: ${Q}`);const ve=new p("int64",new BigInt64Array(le.map(BigInt)),[le.length]);return await re({x:U,s:ve})}async function y(U,B){return await(await o.TensorOpRegistry.matmul)({a:U,b:B})}async function T(U,B){return await(await o.TensorOpRegistry.rfft)({x:U,a:B})}async function b(U,B){const Q=await o.TensorOpRegistry.top_k;return B==null?B=U.dims.at(-1):B=Math.min(B,U.dims.at(-1)),await Q({x:U,k:new p("int64",[BigInt(B)],[1])})}const k=U=>new p("int64",U,[U.length]);async function L(U,B,Q,le,re){return await(await o.TensorOpRegistry.slice)({x:U,s:k(B),e:k(Q),a:k(le),t:k(re??new Array(le.length).fill(1))})}function C(U,B){const Q=U.data,le=B.data,re=[U.dims[0],U.dims[2]],ve=new Q.constructor(re[0]*re[1]),[Se,Be,ut]=U.dims;let Oe=0;for(let ae=0;ae<Se;++ae){const Z=ae*ut*Be;for(let Ee=0;Ee<ut;++Ee){let Ve=0,Ue=0;const qe=ae*Be,We=Z+Ee;for(let at=0;at<Be;++at){const ct=Number(le[qe+at]);Ue+=ct,Ve+=Q[We+at*ut]*ct}const nt=Ve/Ue;ve[Oe++]=nt}}return new p(U.type,ve,re)}function S(U,B,{eps:Q=1e-5}={}){if(U.dims.length!==2)throw new Error("`layer_norm` currently only supports 2D input.");const[le,re]=U.dims;if(B.length!==1&&B[0]!==re)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[ve,Se]=K(U,1,0,!0),Be=ve.data,ut=Se.data,Oe=U.data,ae=new Oe.constructor(Oe.length);for(let Z=0;Z<le;++Z){const Ee=Z*re;for(let Ve=0;Ve<re;++Ve){const Ue=Ee+Ve;ae[Ue]=(Oe[Ue]-ut[Z])/(Be[Z]+Q)}}return new p(U.type,ae,U.dims)}function I(U,B){return U=U.slice(),B===null?U=U.filter(Q=>Q!==1):typeof B=="number"?U[B]===1&&U.splice(B,1):Array.isArray(B)&&(U=U.filter((Q,le)=>Q!==1||!B.includes(le))),U}function O(U,B){return B=x(B,U.length+1),U=U.slice(),U.splice(B,0,1),U}function x(U,B,Q=null,le=!0){if(U<-B||U>=B){if(le)throw new Error(`IndexError: index ${U} is out of bounds for dimension${Q===null?"":" "+Q} with size ${B}`);return U<-B?0:B}return U<0&&(U=(U%B+B)%B),U}function E(U,B=0){B=x(B,U[0].dims.length);const Q=U[0].dims.slice();Q[B]=U.reduce((Se,Be)=>Se+Be.dims[B],0);const le=Q.reduce((Se,Be)=>Se*Be,1),re=new U[0].data.constructor(le),ve=U[0].type;if(B===0){let Se=0;for(const Be of U){const ut=Be.data;re.set(ut,Se),Se+=ut.length}}else{let Se=0;for(let Be=0;Be<U.length;++Be){const{data:ut,dims:Oe}=U[Be];for(let ae=0;ae<ut.length;++ae){let Z=0;for(let Ee=Oe.length-1,Ve=ae,Ue=1;Ee>=0;--Ee){const qe=Oe[Ee];let We=Ve%qe;Ee===B&&(We+=Se),Z+=We*Ue,Ue*=Q[Ee],Ve=Math.floor(Ve/qe)}re[Z]=ut[ae]}Se+=Oe[B]}}return new p(ve,re,Q)}function A(U,B=0){return E(U.map(Q=>Q.unsqueeze(B)),B)}function F(U,B,Q=null,le=!1,re=null){const ve=B.data,Se=B.dims;Q=x(Q,Se.length);const Be=Se.slice();Be[Q]=1;const ut=new ve.constructor(ve.length/Se[Q]);re!==null&&ut.fill(re);for(let Oe=0;Oe<ve.length;++Oe){let ae=0;for(let Z=Se.length-1,Ee=Oe,Ve=1;Z>=0;--Z){const Ue=Se[Z];if(Z!==Q){const qe=Ee%Ue;ae+=qe*Ve,Ve*=Be[Z]}Ee=Math.floor(Ee/Ue)}ut[ae]=U(ut[ae],ve[Oe],Oe,ae)}return le||Be.splice(Q,1),[B.type,ut,Be]}function K(U,B=null,Q=1,le=!1){const re=U.data,ve=U.dims;if(B===null){const Ve=re.reduce((nt,at)=>nt+at,0)/re.length,Ue=Math.sqrt(re.reduce((nt,at)=>nt+(at-Ve)**2,0)/(re.length-Q)),qe=new p(U.type,[Ve],[]);return[new p(U.type,[Ue],[]),qe]}B=x(B,ve.length);const Se=X(U,B,le),Be=Se.data,[ut,Oe,ae]=F((Ee,Ve,Ue,qe)=>Ee+(Ve-Be[qe])**2,U,B,le);for(let Ee=0;Ee<Oe.length;++Ee)Oe[Ee]=Math.sqrt(Oe[Ee]/(ve[B]-Q));return[new p(ut,Oe,ae),Se]}function X(U,B=null,Q=!1){const le=U.dims,re=U.data;if(B===null){const ut=re.reduce((Oe,ae)=>Oe+ae,0);return new p(U.type,[ut/re.length],[])}B=x(B,le.length);const[ve,Se,Be]=F((ut,Oe)=>ut+Oe,U,B,Q);if(le[B]!==1)for(let ut=0;ut<Se.length;++ut)Se[ut]/=le[B];return new p(ve,Se,Be)}function oe(U){const B=new Array(U.length);for(let Q=U.length-1,le=1;Q>=0;--Q)B[Q]=le,le*=U[Q];return B}function ie(U,B,Q,le){const re=U.reduce((ve,Se)=>ve*Se,1);return new p(Q,new le(re).fill(B),U)}function J(U,B){let Q,le;if(typeof B=="number")Q="float32",le=Float32Array;else if(typeof B=="bigint")Q="int64",le=BigInt64Array;else if(typeof B=="boolean")Q="bool",le=Uint8Array;else throw new Error(`Unsupported data type: ${typeof B}`);return ie(U,B,Q,le)}function ue(U,B){return J(U.dims,B)}function ne(U){return ie(U,1n,"int64",BigInt64Array)}function G(U){return ne(U.dims)}function se(U){return ie(U,0n,"int64",BigInt64Array)}function ce(U){return se(U.dims)}function ge(U){const B=U.reduce((Q,le)=>Q*le,1);return new p("float32",Float32Array.from({length:B},()=>Math.random()),U)}function W(U,B){if(U.dims.length!==2)throw new Error("The tensor must have 2 dimensions");if(U.dims.at(-1)%8!==0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(B))throw new Error("The precision must be either 'binary' or 'ubinary'");const Q=B==="binary",le=Q?"int8":"uint8",re=Q?Int8Array:Uint8Array,ve=U.data,Se=new re(ve.length/8);for(let Be=0;Be<ve.length;++Be){const ut=ve[Be]>0?1:0,Oe=Math.floor(Be/8),ae=Be%8;Se[Oe]|=ut<<7-ae,Q&&ae===0&&(Se[Oe]-=128)}return new p(le,Se,[U.dims[0],U.dims[1]/8])}},"./src/utils/video.js":(t,s,n)=>{n.r(s),n.d(s,{RawVideo:()=>c,RawVideoFrame:()=>o,load_video:()=>p});var i=n("./src/utils/image.js"),l=n("./src/env.js");class o{constructor(f,g){this.image=f,this.timestamp=g}}class c{constructor(f,g){f.length>0&&f[0]instanceof i.RawImage&&(f=f.map((_,y)=>new o(_,(y+1)/(f.length+1)*g))),this.frames=f,this.duration=g}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function p(d,{num_frames:f=null,fps:g=null}={}){if(!l.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(f==null&&g==null)throw new Error("Either num_frames or fps must be provided.");const _=[],y=document.createElement("video");if(y.crossOrigin="anonymous",y.muted=!0,typeof d=="string")y.src=d;else if(d instanceof Blob)y.src=URL.createObjectURL(d);else if(d instanceof HTMLVideoElement)y.src=d.src;else throw new Error("Invalid URL or video element provided.");if(await new Promise(I=>y.onloadedmetadata=I),y.seekable.start(0)===y.seekable.end(0)){const O=await(await fetch(y.src)).blob();y.src=URL.createObjectURL(O),await new Promise(x=>y.onloadedmetadata=x)}const T=y.duration;let b,k;f!=null?(b=f,k=f===1?0:T/(f-1)):(k=1/g,b=Math.floor(T/k));let L=[];for(let I=0;I<b;++I)L.push(f===1?T/2:I*k);const C=document.createElement("canvas");C.width=y.videoWidth,C.height=y.videoHeight;const S=C.getContext("2d",{willReadFrequently:!0});for(const I of L){y.currentTime=I,await new Promise(A=>{y.onseeked=A}),S.drawImage(y,0,0,C.width,C.height);const O=S.getImageData(0,0,C.width,C.height),x=new i.RawImage(O.data,C.width,C.height,4),E=new o(x,I);_.push(E)}return y.remove(),new c(_,T)}}},xv={};function Mn(t){var s=xv[t];if(s!==void 0)return s.exports;var n=xv[t]={exports:{}};return VE[t](n,n.exports,Mn),n.exports}(()=>{var t=Object.getPrototypeOf?n=>Object.getPrototypeOf(n):n=>n.__proto__,s;Mn.t=function(n,i){if(i&1&&(n=this(n)),i&8||typeof n=="object"&&n&&(i&4&&n.__esModule||i&16&&typeof n.then=="function"))return n;var l=Object.create(null);Mn.r(l);var o={};s=s||[null,t({}),t([]),t(t)];for(var c=i&2&&n;typeof c=="object"&&!~s.indexOf(c);c=t(c))Object.getOwnPropertyNames(c).forEach(p=>o[p]=()=>n[p]);return o.default=()=>n,Mn.d(l,o),l}})();Mn.d=(t,s)=>{for(var n in s)Mn.o(s,n)&&!Mn.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:s[n]})};Mn.o=(t,s)=>Object.prototype.hasOwnProperty.call(t,s);Mn.r=t=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var w={};(()=>{/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/Mn.r(w),Mn.d(w,{ASTFeatureExtractor:()=>_.ASTFeatureExtractor,ASTForAudioClassification:()=>n.ASTForAudioClassification,ASTModel:()=>n.ASTModel,ASTPreTrainedModel:()=>n.ASTPreTrainedModel,AlbertForMaskedLM:()=>n.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>n.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>n.AlbertForSequenceClassification,AlbertModel:()=>n.AlbertModel,AlbertPreTrainedModel:()=>n.AlbertPreTrainedModel,AlbertTokenizer:()=>i.AlbertTokenizer,AudioClassificationPipeline:()=>s.AudioClassificationPipeline,AutoConfig:()=>l.AutoConfig,AutoFeatureExtractor:()=>y.AutoFeatureExtractor,AutoImageProcessor:()=>k.AutoImageProcessor,AutoModel:()=>n.AutoModel,AutoModelForAudioClassification:()=>n.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>n.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>n.AutoModelForAudioTextToText,AutoModelForCTC:()=>n.AutoModelForCTC,AutoModelForCausalLM:()=>n.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>n.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>n.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>n.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>n.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>n.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>n.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>n.AutoModelForImageTextToText,AutoModelForImageToImage:()=>n.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>n.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>n.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>n.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>n.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>n.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>n.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>n.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>n.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>n.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>n.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>n.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>n.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>n.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>n.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>n.AutoModelForVision2Seq,AutoModelForXVector:()=>n.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>n.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>S.AutoProcessor,AutoTokenizer:()=>i.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>s.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>s.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>n.BartForConditionalGeneration,BartForSequenceClassification:()=>n.BartForSequenceClassification,BartModel:()=>n.BartModel,BartPretrainedModel:()=>n.BartPretrainedModel,BartTokenizer:()=>i.BartTokenizer,BaseModelOutput:()=>n.BaseModelOutput,BaseStreamer:()=>I.BaseStreamer,BeitFeatureExtractor:()=>b.BeitFeatureExtractor,BeitForImageClassification:()=>n.BeitForImageClassification,BeitModel:()=>n.BeitModel,BeitPreTrainedModel:()=>n.BeitPreTrainedModel,BertForMaskedLM:()=>n.BertForMaskedLM,BertForQuestionAnswering:()=>n.BertForQuestionAnswering,BertForSequenceClassification:()=>n.BertForSequenceClassification,BertForTokenClassification:()=>n.BertForTokenClassification,BertModel:()=>n.BertModel,BertPreTrainedModel:()=>n.BertPreTrainedModel,BertTokenizer:()=>i.BertTokenizer,BitImageProcessor:()=>b.BitImageProcessor,BlenderbotForConditionalGeneration:()=>n.BlenderbotForConditionalGeneration,BlenderbotModel:()=>n.BlenderbotModel,BlenderbotPreTrainedModel:()=>n.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>n.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>n.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>n.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>i.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>i.BlenderbotTokenizer,BloomForCausalLM:()=>n.BloomForCausalLM,BloomModel:()=>n.BloomModel,BloomPreTrainedModel:()=>n.BloomPreTrainedModel,BloomTokenizer:()=>i.BloomTokenizer,CLIPFeatureExtractor:()=>b.CLIPFeatureExtractor,CLIPImageProcessor:()=>b.CLIPImageProcessor,CLIPModel:()=>n.CLIPModel,CLIPPreTrainedModel:()=>n.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>n.CLIPSegForImageSegmentation,CLIPSegModel:()=>n.CLIPSegModel,CLIPSegPreTrainedModel:()=>n.CLIPSegPreTrainedModel,CLIPTextModel:()=>n.CLIPTextModel,CLIPTextModelWithProjection:()=>n.CLIPTextModelWithProjection,CLIPTokenizer:()=>i.CLIPTokenizer,CLIPVisionModel:()=>n.CLIPVisionModel,CLIPVisionModelWithProjection:()=>n.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>n.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>n.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>n.CamembertForSequenceClassification,CamembertForTokenClassification:()=>n.CamembertForTokenClassification,CamembertModel:()=>n.CamembertModel,CamembertPreTrainedModel:()=>n.CamembertPreTrainedModel,CamembertTokenizer:()=>i.CamembertTokenizer,CausalLMOutput:()=>n.CausalLMOutput,CausalLMOutputWithPast:()=>n.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>b.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>n.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>n.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>n.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>_.ClapFeatureExtractor,ClapModel:()=>n.ClapModel,ClapPreTrainedModel:()=>n.ClapPreTrainedModel,ClapTextModelWithProjection:()=>n.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>x.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>n.CodeGenForCausalLM,CodeGenModel:()=>n.CodeGenModel,CodeGenPreTrainedModel:()=>n.CodeGenPreTrainedModel,CodeGenTokenizer:()=>i.CodeGenTokenizer,CodeLlamaTokenizer:()=>i.CodeLlamaTokenizer,CohereForCausalLM:()=>n.CohereForCausalLM,CohereModel:()=>n.CohereModel,CoherePreTrainedModel:()=>n.CoherePreTrainedModel,CohereTokenizer:()=>i.CohereTokenizer,ConvBertForMaskedLM:()=>n.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>n.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>n.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>n.ConvBertForTokenClassification,ConvBertModel:()=>n.ConvBertModel,ConvBertPreTrainedModel:()=>n.ConvBertPreTrainedModel,ConvBertTokenizer:()=>i.ConvBertTokenizer,ConvNextFeatureExtractor:()=>b.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>n.ConvNextForImageClassification,ConvNextImageProcessor:()=>b.ConvNextImageProcessor,ConvNextModel:()=>n.ConvNextModel,ConvNextPreTrainedModel:()=>n.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>n.ConvNextV2ForImageClassification,ConvNextV2Model:()=>n.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>n.ConvNextV2PreTrainedModel,DPTFeatureExtractor:()=>b.DPTFeatureExtractor,DPTForDepthEstimation:()=>n.DPTForDepthEstimation,DPTImageProcessor:()=>b.DPTImageProcessor,DPTModel:()=>n.DPTModel,DPTPreTrainedModel:()=>n.DPTPreTrainedModel,DacDecoderModel:()=>n.DacDecoderModel,DacDecoderOutput:()=>n.DacDecoderOutput,DacEncoderModel:()=>n.DacEncoderModel,DacEncoderOutput:()=>n.DacEncoderOutput,DacFeatureExtractor:()=>_.DacFeatureExtractor,DacModel:()=>n.DacModel,DacPreTrainedModel:()=>n.DacPreTrainedModel,DataTypeMap:()=>d.DataTypeMap,DebertaForMaskedLM:()=>n.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>n.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>n.DebertaForSequenceClassification,DebertaForTokenClassification:()=>n.DebertaForTokenClassification,DebertaModel:()=>n.DebertaModel,DebertaPreTrainedModel:()=>n.DebertaPreTrainedModel,DebertaTokenizer:()=>i.DebertaTokenizer,DebertaV2ForMaskedLM:()=>n.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>n.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>n.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>n.DebertaV2ForTokenClassification,DebertaV2Model:()=>n.DebertaV2Model,DebertaV2PreTrainedModel:()=>n.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>i.DebertaV2Tokenizer,DecisionTransformerModel:()=>n.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>n.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>b.DeiTFeatureExtractor,DeiTForImageClassification:()=>n.DeiTForImageClassification,DeiTImageProcessor:()=>b.DeiTImageProcessor,DeiTModel:()=>n.DeiTModel,DeiTPreTrainedModel:()=>n.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>n.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>n.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>s.DepthEstimationPipeline,DepthProForDepthEstimation:()=>n.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>n.DepthProPreTrainedModel,DetrFeatureExtractor:()=>b.DetrFeatureExtractor,DetrForObjectDetection:()=>n.DetrForObjectDetection,DetrForSegmentation:()=>n.DetrForSegmentation,DetrImageProcessor:()=>b.DetrImageProcessor,DetrModel:()=>n.DetrModel,DetrObjectDetectionOutput:()=>n.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>n.DetrPreTrainedModel,DetrSegmentationOutput:()=>n.DetrSegmentationOutput,Dinov2ForImageClassification:()=>n.Dinov2ForImageClassification,Dinov2Model:()=>n.Dinov2Model,Dinov2PreTrainedModel:()=>n.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>n.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>n.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>n.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>n.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>n.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>n.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>n.DistilBertForTokenClassification,DistilBertModel:()=>n.DistilBertModel,DistilBertPreTrainedModel:()=>n.DistilBertPreTrainedModel,DistilBertTokenizer:()=>i.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>s.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>b.DonutFeatureExtractor,DonutImageProcessor:()=>b.DonutImageProcessor,DonutSwinModel:()=>n.DonutSwinModel,DonutSwinPreTrainedModel:()=>n.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>n.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>b.EfficientNetImageProcessor,EfficientNetModel:()=>n.EfficientNetModel,EfficientNetPreTrainedModel:()=>n.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>n.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>n.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>n.ElectraForSequenceClassification,ElectraForTokenClassification:()=>n.ElectraForTokenClassification,ElectraModel:()=>n.ElectraModel,ElectraPreTrainedModel:()=>n.ElectraPreTrainedModel,ElectraTokenizer:()=>i.ElectraTokenizer,EncodecFeatureExtractor:()=>_.EncodecFeatureExtractor,EosTokenCriteria:()=>O.EosTokenCriteria,EsmForMaskedLM:()=>n.EsmForMaskedLM,EsmForSequenceClassification:()=>n.EsmForSequenceClassification,EsmForTokenClassification:()=>n.EsmForTokenClassification,EsmModel:()=>n.EsmModel,EsmPreTrainedModel:()=>n.EsmPreTrainedModel,EsmTokenizer:()=>i.EsmTokenizer,ExaoneForCausalLM:()=>n.ExaoneForCausalLM,ExaoneModel:()=>n.ExaoneModel,ExaonePreTrainedModel:()=>n.ExaonePreTrainedModel,FFT:()=>f.FFT,FalconForCausalLM:()=>n.FalconForCausalLM,FalconModel:()=>n.FalconModel,FalconPreTrainedModel:()=>n.FalconPreTrainedModel,FalconTokenizer:()=>i.FalconTokenizer,FastViTForImageClassification:()=>n.FastViTForImageClassification,FastViTModel:()=>n.FastViTModel,FastViTPreTrainedModel:()=>n.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>s.FeatureExtractionPipeline,FeatureExtractor:()=>g.FeatureExtractor,FillMaskPipeline:()=>s.FillMaskPipeline,Florence2ForConditionalGeneration:()=>n.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>n.Florence2PreTrainedModel,Florence2Processor:()=>C.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>x.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>x.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>b.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>n.GLPNForDepthEstimation,GLPNModel:()=>n.GLPNModel,GLPNPreTrainedModel:()=>n.GLPNPreTrainedModel,GPT2LMHeadModel:()=>n.GPT2LMHeadModel,GPT2Model:()=>n.GPT2Model,GPT2PreTrainedModel:()=>n.GPT2PreTrainedModel,GPT2Tokenizer:()=>i.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>n.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>n.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>n.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>n.GPTJForCausalLM,GPTJModel:()=>n.GPTJModel,GPTJPreTrainedModel:()=>n.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>n.GPTNeoForCausalLM,GPTNeoModel:()=>n.GPTNeoModel,GPTNeoPreTrainedModel:()=>n.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>n.GPTNeoXForCausalLM,GPTNeoXModel:()=>n.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>n.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>i.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>n.Gemma2ForCausalLM,Gemma2Model:()=>n.Gemma2Model,Gemma2PreTrainedModel:()=>n.Gemma2PreTrainedModel,Gemma3ForCausalLM:()=>n.Gemma3ForCausalLM,Gemma3Model:()=>n.Gemma3Model,Gemma3PreTrainedModel:()=>n.Gemma3PreTrainedModel,GemmaForCausalLM:()=>n.GemmaForCausalLM,GemmaModel:()=>n.GemmaModel,GemmaPreTrainedModel:()=>n.GemmaPreTrainedModel,GemmaTokenizer:()=>i.GemmaTokenizer,GlmForCausalLM:()=>n.GlmForCausalLM,GlmModel:()=>n.GlmModel,GlmPreTrainedModel:()=>n.GlmPreTrainedModel,GraniteForCausalLM:()=>n.GraniteForCausalLM,GraniteModel:()=>n.GraniteModel,GranitePreTrainedModel:()=>n.GranitePreTrainedModel,Grok1Tokenizer:()=>i.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>n.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>b.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>n.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>C.GroundingDinoProcessor,GroupViTModel:()=>n.GroupViTModel,GroupViTPreTrainedModel:()=>n.GroupViTPreTrainedModel,HeliumForCausalLM:()=>n.HeliumForCausalLM,HeliumModel:()=>n.HeliumModel,HeliumPreTrainedModel:()=>n.HeliumPreTrainedModel,HerbertTokenizer:()=>i.HerbertTokenizer,HieraForImageClassification:()=>n.HieraForImageClassification,HieraModel:()=>n.HieraModel,HieraPreTrainedModel:()=>n.HieraPreTrainedModel,HubertForCTC:()=>n.HubertForCTC,HubertForSequenceClassification:()=>n.HubertForSequenceClassification,HubertModel:()=>n.HubertModel,HubertPreTrainedModel:()=>n.HubertPreTrainedModel,IJepaForImageClassification:()=>n.IJepaForImageClassification,IJepaModel:()=>n.IJepaModel,IJepaPreTrainedModel:()=>n.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>n.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>b.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>n.Idefics3PreTrainedModel,Idefics3Processor:()=>C.Idefics3Processor,ImageClassificationPipeline:()=>s.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>s.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>_.ImageFeatureExtractor,ImageMattingOutput:()=>n.ImageMattingOutput,ImageProcessor:()=>T.ImageProcessor,ImageSegmentationPipeline:()=>s.ImageSegmentationPipeline,ImageToImagePipeline:()=>s.ImageToImagePipeline,ImageToTextPipeline:()=>s.ImageToTextPipeline,InterruptableStoppingCriteria:()=>O.InterruptableStoppingCriteria,JAISLMHeadModel:()=>n.JAISLMHeadModel,JAISModel:()=>n.JAISModel,JAISPreTrainedModel:()=>n.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>b.JinaCLIPImageProcessor,JinaCLIPModel:()=>n.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>n.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>C.JinaCLIPProcessor,JinaCLIPTextModel:()=>n.JinaCLIPTextModel,JinaCLIPVisionModel:()=>n.JinaCLIPVisionModel,LiteWhisperForConditionalGeneration:()=>n.LiteWhisperForConditionalGeneration,LlamaForCausalLM:()=>n.LlamaForCausalLM,LlamaModel:()=>n.LlamaModel,LlamaPreTrainedModel:()=>n.LlamaPreTrainedModel,LlamaTokenizer:()=>i.LlamaTokenizer,LlavaForConditionalGeneration:()=>n.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>n.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>b.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>n.LlavaPreTrainedModel,LogitsProcessor:()=>x.LogitsProcessor,LogitsProcessorList:()=>x.LogitsProcessorList,LogitsWarper:()=>x.LogitsWarper,LongT5ForConditionalGeneration:()=>n.LongT5ForConditionalGeneration,LongT5Model:()=>n.LongT5Model,LongT5PreTrainedModel:()=>n.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>n.M2M100ForConditionalGeneration,M2M100Model:()=>n.M2M100Model,M2M100PreTrainedModel:()=>n.M2M100PreTrainedModel,M2M100Tokenizer:()=>i.M2M100Tokenizer,MBart50Tokenizer:()=>i.MBart50Tokenizer,MBartForCausalLM:()=>n.MBartForCausalLM,MBartForConditionalGeneration:()=>n.MBartForConditionalGeneration,MBartForSequenceClassification:()=>n.MBartForSequenceClassification,MBartModel:()=>n.MBartModel,MBartPreTrainedModel:()=>n.MBartPreTrainedModel,MBartTokenizer:()=>i.MBartTokenizer,MPNetForMaskedLM:()=>n.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>n.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>n.MPNetForSequenceClassification,MPNetForTokenClassification:()=>n.MPNetForTokenClassification,MPNetModel:()=>n.MPNetModel,MPNetPreTrainedModel:()=>n.MPNetPreTrainedModel,MPNetTokenizer:()=>i.MPNetTokenizer,MT5ForConditionalGeneration:()=>n.MT5ForConditionalGeneration,MT5Model:()=>n.MT5Model,MT5PreTrainedModel:()=>n.MT5PreTrainedModel,MarianMTModel:()=>n.MarianMTModel,MarianModel:()=>n.MarianModel,MarianPreTrainedModel:()=>n.MarianPreTrainedModel,MarianTokenizer:()=>i.MarianTokenizer,Mask2FormerImageProcessor:()=>b.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>b.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>n.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>b.MaskFormerImageProcessor,MaskFormerModel:()=>n.MaskFormerModel,MaskFormerPreTrainedModel:()=>n.MaskFormerPreTrainedModel,MaskedLMOutput:()=>n.MaskedLMOutput,MaxLengthCriteria:()=>O.MaxLengthCriteria,Metric3DForDepthEstimation:()=>n.Metric3DForDepthEstimation,Metric3DPreTrainedModel:()=>n.Metric3DPreTrainedModel,Metric3Dv2ForDepthEstimation:()=>n.Metric3Dv2ForDepthEstimation,Metric3Dv2PreTrainedModel:()=>n.Metric3Dv2PreTrainedModel,MgpstrForSceneTextRecognition:()=>n.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>n.MgpstrModelOutput,MgpstrPreTrainedModel:()=>n.MgpstrPreTrainedModel,MgpstrProcessor:()=>C.MgpstrProcessor,MgpstrTokenizer:()=>i.MgpstrTokenizer,MimiDecoderModel:()=>n.MimiDecoderModel,MimiDecoderOutput:()=>n.MimiDecoderOutput,MimiEncoderModel:()=>n.MimiEncoderModel,MimiEncoderOutput:()=>n.MimiEncoderOutput,MimiModel:()=>n.MimiModel,MimiPreTrainedModel:()=>n.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>x.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>x.MinNewTokensLengthLogitsProcessor,MistralForCausalLM:()=>n.MistralForCausalLM,MistralModel:()=>n.MistralModel,MistralPreTrainedModel:()=>n.MistralPreTrainedModel,MobileBertForMaskedLM:()=>n.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>n.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>n.MobileBertForSequenceClassification,MobileBertModel:()=>n.MobileBertModel,MobileBertPreTrainedModel:()=>n.MobileBertPreTrainedModel,MobileBertTokenizer:()=>i.MobileBertTokenizer,MobileLLMForCausalLM:()=>n.MobileLLMForCausalLM,MobileLLMModel:()=>n.MobileLLMModel,MobileLLMPreTrainedModel:()=>n.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>b.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>n.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>n.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>b.MobileNetV1ImageProcessor,MobileNetV1Model:()=>n.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>n.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>b.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>n.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>n.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>b.MobileNetV2ImageProcessor,MobileNetV2Model:()=>n.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>n.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>b.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>n.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>n.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>b.MobileNetV3ImageProcessor,MobileNetV3Model:()=>n.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>n.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>b.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>n.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>n.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>b.MobileNetV4ImageProcessor,MobileNetV4Model:()=>n.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>n.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>b.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>n.MobileViTForImageClassification,MobileViTImageProcessor:()=>b.MobileViTImageProcessor,MobileViTModel:()=>n.MobileViTModel,MobileViTPreTrainedModel:()=>n.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>n.MobileViTV2ForImageClassification,MobileViTV2Model:()=>n.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>n.MobileViTV2PreTrainedModel,ModelOutput:()=>n.ModelOutput,ModernBertForMaskedLM:()=>n.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>n.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>n.ModernBertForTokenClassification,ModernBertModel:()=>n.ModernBertModel,ModernBertPreTrainedModel:()=>n.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>n.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>_.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>n.MoonshineForConditionalGeneration,MoonshineModel:()=>n.MoonshineModel,MoonshinePreTrainedModel:()=>n.MoonshinePreTrainedModel,MoonshineProcessor:()=>C.MoonshineProcessor,MptForCausalLM:()=>n.MptForCausalLM,MptModel:()=>n.MptModel,MptPreTrainedModel:()=>n.MptPreTrainedModel,MultiModalityCausalLM:()=>n.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>n.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>n.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>n.MusicgenForConditionalGeneration,MusicgenModel:()=>n.MusicgenModel,MusicgenPreTrainedModel:()=>n.MusicgenPreTrainedModel,NllbTokenizer:()=>i.NllbTokenizer,NoBadWordsLogitsProcessor:()=>x.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>x.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>n.NomicBertModel,NomicBertPreTrainedModel:()=>n.NomicBertPreTrainedModel,NougatImageProcessor:()=>b.NougatImageProcessor,NougatTokenizer:()=>i.NougatTokenizer,OPTForCausalLM:()=>n.OPTForCausalLM,OPTModel:()=>n.OPTModel,OPTPreTrainedModel:()=>n.OPTPreTrainedModel,ObjectDetectionPipeline:()=>s.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>n.Olmo2ForCausalLM,Olmo2Model:()=>n.Olmo2Model,Olmo2PreTrainedModel:()=>n.Olmo2PreTrainedModel,OlmoForCausalLM:()=>n.OlmoForCausalLM,OlmoModel:()=>n.OlmoModel,OlmoPreTrainedModel:()=>n.OlmoPreTrainedModel,OpenELMForCausalLM:()=>n.OpenELMForCausalLM,OpenELMModel:()=>n.OpenELMModel,OpenELMPreTrainedModel:()=>n.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>b.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>n.OwlViTForObjectDetection,OwlViTImageProcessor:()=>b.OwlViTImageProcessor,OwlViTModel:()=>n.OwlViTModel,OwlViTPreTrainedModel:()=>n.OwlViTPreTrainedModel,OwlViTProcessor:()=>C.OwlViTProcessor,Owlv2ForObjectDetection:()=>n.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>b.Owlv2ImageProcessor,Owlv2Model:()=>n.Owlv2Model,Owlv2PreTrainedModel:()=>n.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>n.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>n.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>C.PaliGemmaProcessor,PatchTSMixerForPrediction:()=>n.PatchTSMixerForPrediction,PatchTSMixerModel:()=>n.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>n.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>n.PatchTSTForPrediction,PatchTSTModel:()=>n.PatchTSTModel,PatchTSTPreTrainedModel:()=>n.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>n.Phi3ForCausalLM,Phi3Model:()=>n.Phi3Model,Phi3PreTrainedModel:()=>n.Phi3PreTrainedModel,Phi3VForCausalLM:()=>n.Phi3VForCausalLM,Phi3VImageProcessor:()=>b.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>n.Phi3VPreTrainedModel,Phi3VProcessor:()=>C.Phi3VProcessor,PhiForCausalLM:()=>n.PhiForCausalLM,PhiModel:()=>n.PhiModel,PhiPreTrainedModel:()=>n.PhiPreTrainedModel,Pipeline:()=>s.Pipeline,PreTrainedModel:()=>n.PreTrainedModel,PreTrainedTokenizer:()=>i.PreTrainedTokenizer,PretrainedConfig:()=>l.PretrainedConfig,PretrainedMixin:()=>n.PretrainedMixin,Processor:()=>L.Processor,PvtForImageClassification:()=>n.PvtForImageClassification,PvtImageProcessor:()=>b.PvtImageProcessor,PvtModel:()=>n.PvtModel,PvtPreTrainedModel:()=>n.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>_.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>n.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>n.PyAnnoteModel,PyAnnotePreTrainedModel:()=>n.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>C.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>n.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>s.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>n.Qwen2ForCausalLM,Qwen2Model:()=>n.Qwen2Model,Qwen2PreTrainedModel:()=>n.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>i.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>n.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>b.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>n.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>C.Qwen2VLProcessor,RFDetrForObjectDetection:()=>n.RFDetrForObjectDetection,RFDetrModel:()=>n.RFDetrModel,RFDetrObjectDetectionOutput:()=>n.RFDetrObjectDetectionOutput,RFDetrPreTrainedModel:()=>n.RFDetrPreTrainedModel,RTDetrForObjectDetection:()=>n.RTDetrForObjectDetection,RTDetrImageProcessor:()=>b.RTDetrImageProcessor,RTDetrModel:()=>n.RTDetrModel,RTDetrObjectDetectionOutput:()=>n.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>n.RTDetrPreTrainedModel,RTDetrV2ForObjectDetection:()=>n.RTDetrV2ForObjectDetection,RTDetrV2Model:()=>n.RTDetrV2Model,RTDetrV2ObjectDetectionOutput:()=>n.RTDetrV2ObjectDetectionOutput,RTDetrV2PreTrainedModel:()=>n.RTDetrV2PreTrainedModel,RawAudio:()=>o.RawAudio,RawImage:()=>c.RawImage,RawVideo:()=>p.RawVideo,RawVideoFrame:()=>p.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>x.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>n.ResNetForImageClassification,ResNetModel:()=>n.ResNetModel,ResNetPreTrainedModel:()=>n.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>n.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>n.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>n.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>n.RoFormerForTokenClassification,RoFormerModel:()=>n.RoFormerModel,RoFormerPreTrainedModel:()=>n.RoFormerPreTrainedModel,RoFormerTokenizer:()=>i.RoFormerTokenizer,RobertaForMaskedLM:()=>n.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>n.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>n.RobertaForSequenceClassification,RobertaForTokenClassification:()=>n.RobertaForTokenClassification,RobertaModel:()=>n.RobertaModel,RobertaPreTrainedModel:()=>n.RobertaPreTrainedModel,RobertaTokenizer:()=>i.RobertaTokenizer,SamImageProcessor:()=>b.SamImageProcessor,SamImageSegmentationOutput:()=>n.SamImageSegmentationOutput,SamModel:()=>n.SamModel,SamPreTrainedModel:()=>n.SamPreTrainedModel,SamProcessor:()=>C.SamProcessor,SapiensForDepthEstimation:()=>n.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>n.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>n.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>n.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>_.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>b.SegformerFeatureExtractor,SegformerForImageClassification:()=>n.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>n.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>b.SegformerImageProcessor,SegformerModel:()=>n.SegformerModel,SegformerPreTrainedModel:()=>n.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>n.Seq2SeqLMOutput,SequenceClassifierOutput:()=>n.SequenceClassifierOutput,SiglipImageProcessor:()=>b.SiglipImageProcessor,SiglipModel:()=>n.SiglipModel,SiglipPreTrainedModel:()=>n.SiglipPreTrainedModel,SiglipTextModel:()=>n.SiglipTextModel,SiglipTokenizer:()=>i.SiglipTokenizer,SiglipVisionModel:()=>n.SiglipVisionModel,SmolVLMForConditionalGeneration:()=>n.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>b.SmolVLMImageProcessor,SmolVLMProcessor:()=>C.SmolVLMProcessor,SnacDecoderModel:()=>n.SnacDecoderModel,SnacEncoderModel:()=>n.SnacEncoderModel,SnacFeatureExtractor:()=>_.SnacFeatureExtractor,SnacModel:()=>n.SnacModel,SnacPreTrainedModel:()=>n.SnacPreTrainedModel,SpeechT5FeatureExtractor:()=>_.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>n.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>n.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>n.SpeechT5HifiGan,SpeechT5Model:()=>n.SpeechT5Model,SpeechT5PreTrainedModel:()=>n.SpeechT5PreTrainedModel,SpeechT5Processor:()=>C.SpeechT5Processor,SpeechT5Tokenizer:()=>i.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>n.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>n.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>n.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>n.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>n.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>i.SqueezeBertTokenizer,StableLmForCausalLM:()=>n.StableLmForCausalLM,StableLmModel:()=>n.StableLmModel,StableLmPreTrainedModel:()=>n.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>n.Starcoder2ForCausalLM,Starcoder2Model:()=>n.Starcoder2Model,Starcoder2PreTrainedModel:()=>n.Starcoder2PreTrainedModel,StoppingCriteria:()=>O.StoppingCriteria,StoppingCriteriaList:()=>O.StoppingCriteriaList,StyleTextToSpeech2Model:()=>n.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>n.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>s.SummarizationPipeline,SuppressTokensAtBeginLogitsProcessor:()=>x.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>n.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>b.Swin2SRImageProcessor,Swin2SRModel:()=>n.Swin2SRModel,Swin2SRPreTrainedModel:()=>n.Swin2SRPreTrainedModel,SwinForImageClassification:()=>n.SwinForImageClassification,SwinForSemanticSegmentation:()=>n.SwinForSemanticSegmentation,SwinModel:()=>n.SwinModel,SwinPreTrainedModel:()=>n.SwinPreTrainedModel,T5ForConditionalGeneration:()=>n.T5ForConditionalGeneration,T5Model:()=>n.T5Model,T5PreTrainedModel:()=>n.T5PreTrainedModel,T5Tokenizer:()=>i.T5Tokenizer,TableTransformerForObjectDetection:()=>n.TableTransformerForObjectDetection,TableTransformerModel:()=>n.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>n.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>n.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>x.TemperatureLogitsWarper,Tensor:()=>d.Tensor,Text2TextGenerationPipeline:()=>s.Text2TextGenerationPipeline,TextClassificationPipeline:()=>s.TextClassificationPipeline,TextGenerationPipeline:()=>s.TextGenerationPipeline,TextStreamer:()=>I.TextStreamer,TextToAudioPipeline:()=>s.TextToAudioPipeline,TokenClassificationPipeline:()=>s.TokenClassificationPipeline,TokenClassifierOutput:()=>n.TokenClassifierOutput,TokenizerModel:()=>i.TokenizerModel,TopKLogitsWarper:()=>x.TopKLogitsWarper,TopPLogitsWarper:()=>x.TopPLogitsWarper,TrOCRForCausalLM:()=>n.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>n.TrOCRPreTrainedModel,TranslationPipeline:()=>s.TranslationPipeline,UltravoxModel:()=>n.UltravoxModel,UltravoxPreTrainedModel:()=>n.UltravoxPreTrainedModel,UltravoxProcessor:()=>C.UltravoxProcessor,UniSpeechForCTC:()=>n.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>n.UniSpeechForSequenceClassification,UniSpeechModel:()=>n.UniSpeechModel,UniSpeechPreTrainedModel:()=>n.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>n.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>n.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>n.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>n.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>n.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>C.VLChatProcessor,VLMImageProcessor:()=>b.VLMImageProcessor,ViTFeatureExtractor:()=>b.ViTFeatureExtractor,ViTForImageClassification:()=>n.ViTForImageClassification,ViTImageProcessor:()=>b.ViTImageProcessor,ViTMAEModel:()=>n.ViTMAEModel,ViTMAEPreTrainedModel:()=>n.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>n.ViTMSNForImageClassification,ViTMSNModel:()=>n.ViTMSNModel,ViTMSNPreTrainedModel:()=>n.ViTMSNPreTrainedModel,ViTModel:()=>n.ViTModel,ViTPreTrainedModel:()=>n.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>n.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>n.VitMatteForImageMatting,VitMatteImageProcessor:()=>b.VitMatteImageProcessor,VitMattePreTrainedModel:()=>n.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>n.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>b.VitPoseImageProcessor,VitPosePreTrainedModel:()=>n.VitPosePreTrainedModel,VitsModel:()=>n.VitsModel,VitsModelOutput:()=>n.VitsModelOutput,VitsPreTrainedModel:()=>n.VitsPreTrainedModel,VitsTokenizer:()=>i.VitsTokenizer,Wav2Vec2BertForCTC:()=>n.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>n.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>n.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>n.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>i.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>_.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>n.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>n.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>n.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>n.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>n.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>C.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>C.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>n.WavLMForAudioFrameClassification,WavLMForCTC:()=>n.WavLMForCTC,WavLMForSequenceClassification:()=>n.WavLMForSequenceClassification,WavLMForXVector:()=>n.WavLMForXVector,WavLMModel:()=>n.WavLMModel,WavLMPreTrainedModel:()=>n.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>_.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>n.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>n.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>_.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>n.WhisperForConditionalGeneration,WhisperModel:()=>n.WhisperModel,WhisperPreTrainedModel:()=>n.WhisperPreTrainedModel,WhisperProcessor:()=>C.WhisperProcessor,WhisperTextStreamer:()=>I.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>x.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>i.WhisperTokenizer,XLMForQuestionAnswering:()=>n.XLMForQuestionAnswering,XLMForSequenceClassification:()=>n.XLMForSequenceClassification,XLMForTokenClassification:()=>n.XLMForTokenClassification,XLMModel:()=>n.XLMModel,XLMPreTrainedModel:()=>n.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>n.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>n.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>n.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>n.XLMRobertaForTokenClassification,XLMRobertaModel:()=>n.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>n.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>i.XLMRobertaTokenizer,XLMTokenizer:()=>i.XLMTokenizer,XLMWithLMHeadModel:()=>n.XLMWithLMHeadModel,XVectorOutput:()=>n.XVectorOutput,YolosFeatureExtractor:()=>b.YolosFeatureExtractor,YolosForObjectDetection:()=>n.YolosForObjectDetection,YolosImageProcessor:()=>b.YolosImageProcessor,YolosModel:()=>n.YolosModel,YolosObjectDetectionOutput:()=>n.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>n.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>s.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>s.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>s.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>s.ZeroShotObjectDetectionPipeline,bankers_round:()=>f.bankers_round,cat:()=>d.cat,cos_sim:()=>f.cos_sim,dot:()=>f.dot,dynamic_time_warping:()=>f.dynamic_time_warping,env:()=>t.env,full:()=>d.full,full_like:()=>d.full_like,getKeyValueShapes:()=>l.getKeyValueShapes,hamming:()=>o.hamming,hanning:()=>o.hanning,interpolate:()=>d.interpolate,interpolate_4d:()=>d.interpolate_4d,interpolate_data:()=>f.interpolate_data,is_chinese_char:()=>i.is_chinese_char,layer_norm:()=>d.layer_norm,load_image:()=>c.load_image,load_video:()=>p.load_video,log_softmax:()=>f.log_softmax,magnitude:()=>f.magnitude,matmul:()=>d.matmul,max:()=>f.max,mean:()=>d.mean,mean_pooling:()=>d.mean_pooling,medianFilter:()=>f.medianFilter,mel_filter_bank:()=>o.mel_filter_bank,min:()=>f.min,ones:()=>d.ones,ones_like:()=>d.ones_like,permute:()=>d.permute,permute_data:()=>f.permute_data,pipeline:()=>s.pipeline,quantize_embeddings:()=>d.quantize_embeddings,rand:()=>d.rand,read_audio:()=>o.read_audio,rfft:()=>d.rfft,round:()=>f.round,slice:()=>d.slice,softmax:()=>f.softmax,spectrogram:()=>o.spectrogram,stack:()=>d.stack,std_mean:()=>d.std_mean,topk:()=>d.topk,window_function:()=>o.window_function,zeros:()=>d.zeros,zeros_like:()=>d.zeros_like});var t=Mn("./src/env.js"),s=Mn("./src/pipelines.js"),n=Mn("./src/models.js"),i=Mn("./src/tokenizers.js"),l=Mn("./src/configs.js"),o=Mn("./src/utils/audio.js"),c=Mn("./src/utils/image.js"),p=Mn("./src/utils/video.js"),d=Mn("./src/utils/tensor.js"),f=Mn("./src/utils/maths.js"),g=Mn("./src/base/feature_extraction_utils.js"),_=Mn("./src/models/feature_extractors.js"),y=Mn("./src/models/auto/feature_extraction_auto.js"),T=Mn("./src/base/image_processors_utils.js"),b=Mn("./src/models/image_processors.js"),k=Mn("./src/models/auto/image_processing_auto.js"),L=Mn("./src/base/processing_utils.js"),C=Mn("./src/models/processors.js"),S=Mn("./src/models/auto/processing_auto.js"),I=Mn("./src/generation/streamers.js"),O=Mn("./src/generation/stopping_criteria.js"),x=Mn("./src/generation/logits_process.js")})();w.ASTFeatureExtractor;w.ASTForAudioClassification;w.ASTModel;w.ASTPreTrainedModel;w.AlbertForMaskedLM;w.AlbertForQuestionAnswering;w.AlbertForSequenceClassification;w.AlbertModel;w.AlbertPreTrainedModel;w.AlbertTokenizer;w.AudioClassificationPipeline;w.AutoConfig;w.AutoFeatureExtractor;w.AutoImageProcessor;w.AutoModel;w.AutoModelForAudioClassification;w.AutoModelForAudioFrameClassification;w.AutoModelForAudioTextToText;w.AutoModelForCTC;w.AutoModelForCausalLM;w.AutoModelForDepthEstimation;w.AutoModelForDocumentQuestionAnswering;w.AutoModelForImageClassification;w.AutoModelForImageFeatureExtraction;w.AutoModelForImageMatting;w.AutoModelForImageSegmentation;w.AutoModelForImageTextToText;w.AutoModelForImageToImage;w.AutoModelForMaskGeneration;w.AutoModelForMaskedLM;w.AutoModelForNormalEstimation;w.AutoModelForObjectDetection;w.AutoModelForPoseEstimation;w.AutoModelForQuestionAnswering;w.AutoModelForSemanticSegmentation;w.AutoModelForSeq2SeqLM;w.AutoModelForSequenceClassification;w.AutoModelForSpeechSeq2Seq;w.AutoModelForTextToSpectrogram;w.AutoModelForTextToWaveform;w.AutoModelForTokenClassification;w.AutoModelForUniversalSegmentation;w.AutoModelForVision2Seq;w.AutoModelForXVector;w.AutoModelForZeroShotObjectDetection;w.AutoProcessor;w.AutoTokenizer;w.AutomaticSpeechRecognitionPipeline;w.BackgroundRemovalPipeline;w.BartForConditionalGeneration;w.BartForSequenceClassification;w.BartModel;w.BartPretrainedModel;w.BartTokenizer;w.BaseModelOutput;w.BaseStreamer;w.BeitFeatureExtractor;w.BeitForImageClassification;w.BeitModel;w.BeitPreTrainedModel;w.BertForMaskedLM;w.BertForQuestionAnswering;w.BertForSequenceClassification;w.BertForTokenClassification;w.BertModel;w.BertPreTrainedModel;w.BertTokenizer;w.BitImageProcessor;w.BlenderbotForConditionalGeneration;w.BlenderbotModel;w.BlenderbotPreTrainedModel;w.BlenderbotSmallForConditionalGeneration;w.BlenderbotSmallModel;w.BlenderbotSmallPreTrainedModel;w.BlenderbotSmallTokenizer;w.BlenderbotTokenizer;w.BloomForCausalLM;w.BloomModel;w.BloomPreTrainedModel;w.BloomTokenizer;w.CLIPFeatureExtractor;w.CLIPImageProcessor;w.CLIPModel;w.CLIPPreTrainedModel;w.CLIPSegForImageSegmentation;w.CLIPSegModel;w.CLIPSegPreTrainedModel;w.CLIPTextModel;w.CLIPTextModelWithProjection;w.CLIPTokenizer;w.CLIPVisionModel;w.CLIPVisionModelWithProjection;w.CamembertForMaskedLM;w.CamembertForQuestionAnswering;w.CamembertForSequenceClassification;w.CamembertForTokenClassification;w.CamembertModel;w.CamembertPreTrainedModel;w.CamembertTokenizer;w.CausalLMOutput;w.CausalLMOutputWithPast;w.ChineseCLIPFeatureExtractor;w.ChineseCLIPModel;w.ChineseCLIPPreTrainedModel;w.ClapAudioModelWithProjection;w.ClapFeatureExtractor;w.ClapModel;w.ClapPreTrainedModel;w.ClapTextModelWithProjection;w.ClassifierFreeGuidanceLogitsProcessor;w.CodeGenForCausalLM;w.CodeGenModel;w.CodeGenPreTrainedModel;w.CodeGenTokenizer;w.CodeLlamaTokenizer;w.CohereForCausalLM;w.CohereModel;w.CoherePreTrainedModel;w.CohereTokenizer;w.ConvBertForMaskedLM;w.ConvBertForQuestionAnswering;w.ConvBertForSequenceClassification;w.ConvBertForTokenClassification;w.ConvBertModel;w.ConvBertPreTrainedModel;w.ConvBertTokenizer;w.ConvNextFeatureExtractor;w.ConvNextForImageClassification;w.ConvNextImageProcessor;w.ConvNextModel;w.ConvNextPreTrainedModel;w.ConvNextV2ForImageClassification;w.ConvNextV2Model;w.ConvNextV2PreTrainedModel;w.DPTFeatureExtractor;w.DPTForDepthEstimation;w.DPTImageProcessor;w.DPTModel;w.DPTPreTrainedModel;w.DacDecoderModel;w.DacDecoderOutput;w.DacEncoderModel;w.DacEncoderOutput;w.DacFeatureExtractor;w.DacModel;w.DacPreTrainedModel;w.DataTypeMap;w.DebertaForMaskedLM;w.DebertaForQuestionAnswering;w.DebertaForSequenceClassification;w.DebertaForTokenClassification;w.DebertaModel;w.DebertaPreTrainedModel;w.DebertaTokenizer;w.DebertaV2ForMaskedLM;w.DebertaV2ForQuestionAnswering;w.DebertaV2ForSequenceClassification;w.DebertaV2ForTokenClassification;w.DebertaV2Model;w.DebertaV2PreTrainedModel;w.DebertaV2Tokenizer;w.DecisionTransformerModel;w.DecisionTransformerPreTrainedModel;w.DeiTFeatureExtractor;w.DeiTForImageClassification;w.DeiTImageProcessor;w.DeiTModel;w.DeiTPreTrainedModel;w.DepthAnythingForDepthEstimation;w.DepthAnythingPreTrainedModel;w.DepthEstimationPipeline;w.DepthProForDepthEstimation;w.DepthProPreTrainedModel;w.DetrFeatureExtractor;w.DetrForObjectDetection;w.DetrForSegmentation;w.DetrImageProcessor;w.DetrModel;w.DetrObjectDetectionOutput;w.DetrPreTrainedModel;w.DetrSegmentationOutput;w.Dinov2ForImageClassification;w.Dinov2Model;w.Dinov2PreTrainedModel;w.Dinov2WithRegistersForImageClassification;w.Dinov2WithRegistersModel;w.Dinov2WithRegistersPreTrainedModel;w.DistilBertForMaskedLM;w.DistilBertForQuestionAnswering;w.DistilBertForSequenceClassification;w.DistilBertForTokenClassification;w.DistilBertModel;w.DistilBertPreTrainedModel;w.DistilBertTokenizer;w.DocumentQuestionAnsweringPipeline;w.DonutFeatureExtractor;w.DonutImageProcessor;w.DonutSwinModel;w.DonutSwinPreTrainedModel;w.EfficientNetForImageClassification;w.EfficientNetImageProcessor;w.EfficientNetModel;w.EfficientNetPreTrainedModel;w.ElectraForMaskedLM;w.ElectraForQuestionAnswering;w.ElectraForSequenceClassification;w.ElectraForTokenClassification;w.ElectraModel;w.ElectraPreTrainedModel;w.ElectraTokenizer;w.EncodecFeatureExtractor;w.EosTokenCriteria;w.EsmForMaskedLM;w.EsmForSequenceClassification;w.EsmForTokenClassification;w.EsmModel;w.EsmPreTrainedModel;w.EsmTokenizer;w.ExaoneForCausalLM;w.ExaoneModel;w.ExaonePreTrainedModel;w.FFT;w.FalconForCausalLM;w.FalconModel;w.FalconPreTrainedModel;w.FalconTokenizer;w.FastViTForImageClassification;w.FastViTModel;w.FastViTPreTrainedModel;w.FeatureExtractionPipeline;w.FeatureExtractor;w.FillMaskPipeline;w.Florence2ForConditionalGeneration;w.Florence2PreTrainedModel;w.Florence2Processor;w.ForcedBOSTokenLogitsProcessor;w.ForcedEOSTokenLogitsProcessor;w.GLPNFeatureExtractor;w.GLPNForDepthEstimation;w.GLPNModel;w.GLPNPreTrainedModel;w.GPT2LMHeadModel;w.GPT2Model;w.GPT2PreTrainedModel;w.GPT2Tokenizer;w.GPTBigCodeForCausalLM;w.GPTBigCodeModel;w.GPTBigCodePreTrainedModel;w.GPTJForCausalLM;w.GPTJModel;w.GPTJPreTrainedModel;w.GPTNeoForCausalLM;w.GPTNeoModel;w.GPTNeoPreTrainedModel;w.GPTNeoXForCausalLM;w.GPTNeoXModel;w.GPTNeoXPreTrainedModel;w.GPTNeoXTokenizer;w.Gemma2ForCausalLM;w.Gemma2Model;w.Gemma2PreTrainedModel;w.Gemma3ForCausalLM;w.Gemma3Model;w.Gemma3PreTrainedModel;w.GemmaForCausalLM;w.GemmaModel;w.GemmaPreTrainedModel;w.GemmaTokenizer;w.GlmForCausalLM;w.GlmModel;w.GlmPreTrainedModel;w.GraniteForCausalLM;w.GraniteModel;w.GranitePreTrainedModel;w.Grok1Tokenizer;w.GroundingDinoForObjectDetection;w.GroundingDinoImageProcessor;w.GroundingDinoPreTrainedModel;w.GroundingDinoProcessor;w.GroupViTModel;w.GroupViTPreTrainedModel;w.HeliumForCausalLM;w.HeliumModel;w.HeliumPreTrainedModel;w.HerbertTokenizer;w.HieraForImageClassification;w.HieraModel;w.HieraPreTrainedModel;w.HubertForCTC;w.HubertForSequenceClassification;w.HubertModel;w.HubertPreTrainedModel;w.IJepaForImageClassification;w.IJepaModel;w.IJepaPreTrainedModel;w.Idefics3ForConditionalGeneration;w.Idefics3ImageProcessor;w.Idefics3PreTrainedModel;w.Idefics3Processor;w.ImageClassificationPipeline;w.ImageFeatureExtractionPipeline;w.ImageFeatureExtractor;w.ImageMattingOutput;w.ImageProcessor;w.ImageSegmentationPipeline;w.ImageToImagePipeline;w.ImageToTextPipeline;w.InterruptableStoppingCriteria;w.JAISLMHeadModel;w.JAISModel;w.JAISPreTrainedModel;w.JinaCLIPImageProcessor;w.JinaCLIPModel;w.JinaCLIPPreTrainedModel;w.JinaCLIPProcessor;w.JinaCLIPTextModel;w.JinaCLIPVisionModel;w.LiteWhisperForConditionalGeneration;w.LlamaForCausalLM;w.LlamaModel;w.LlamaPreTrainedModel;w.LlamaTokenizer;w.LlavaForConditionalGeneration;w.LlavaOnevisionForConditionalGeneration;w.LlavaOnevisionImageProcessor;w.LlavaPreTrainedModel;w.LogitsProcessor;w.LogitsProcessorList;w.LogitsWarper;w.LongT5ForConditionalGeneration;w.LongT5Model;w.LongT5PreTrainedModel;w.M2M100ForConditionalGeneration;w.M2M100Model;w.M2M100PreTrainedModel;w.M2M100Tokenizer;w.MBart50Tokenizer;w.MBartForCausalLM;w.MBartForConditionalGeneration;w.MBartForSequenceClassification;w.MBartModel;w.MBartPreTrainedModel;w.MBartTokenizer;w.MPNetForMaskedLM;w.MPNetForQuestionAnswering;w.MPNetForSequenceClassification;w.MPNetForTokenClassification;w.MPNetModel;w.MPNetPreTrainedModel;w.MPNetTokenizer;w.MT5ForConditionalGeneration;w.MT5Model;w.MT5PreTrainedModel;w.MarianMTModel;w.MarianModel;w.MarianPreTrainedModel;w.MarianTokenizer;w.Mask2FormerImageProcessor;w.MaskFormerFeatureExtractor;w.MaskFormerForInstanceSegmentation;w.MaskFormerImageProcessor;w.MaskFormerModel;w.MaskFormerPreTrainedModel;w.MaskedLMOutput;w.MaxLengthCriteria;w.Metric3DForDepthEstimation;w.Metric3DPreTrainedModel;w.Metric3Dv2ForDepthEstimation;w.Metric3Dv2PreTrainedModel;w.MgpstrForSceneTextRecognition;w.MgpstrModelOutput;w.MgpstrPreTrainedModel;w.MgpstrProcessor;w.MgpstrTokenizer;w.MimiDecoderModel;w.MimiDecoderOutput;w.MimiEncoderModel;w.MimiEncoderOutput;w.MimiModel;w.MimiPreTrainedModel;w.MinLengthLogitsProcessor;w.MinNewTokensLengthLogitsProcessor;w.MistralForCausalLM;w.MistralModel;w.MistralPreTrainedModel;w.MobileBertForMaskedLM;w.MobileBertForQuestionAnswering;w.MobileBertForSequenceClassification;w.MobileBertModel;w.MobileBertPreTrainedModel;w.MobileBertTokenizer;w.MobileLLMForCausalLM;w.MobileLLMModel;w.MobileLLMPreTrainedModel;w.MobileNetV1FeatureExtractor;w.MobileNetV1ForImageClassification;w.MobileNetV1ForSemanticSegmentation;w.MobileNetV1ImageProcessor;w.MobileNetV1Model;w.MobileNetV1PreTrainedModel;w.MobileNetV2FeatureExtractor;w.MobileNetV2ForImageClassification;w.MobileNetV2ForSemanticSegmentation;w.MobileNetV2ImageProcessor;w.MobileNetV2Model;w.MobileNetV2PreTrainedModel;w.MobileNetV3FeatureExtractor;w.MobileNetV3ForImageClassification;w.MobileNetV3ForSemanticSegmentation;w.MobileNetV3ImageProcessor;w.MobileNetV3Model;w.MobileNetV3PreTrainedModel;w.MobileNetV4FeatureExtractor;w.MobileNetV4ForImageClassification;w.MobileNetV4ForSemanticSegmentation;w.MobileNetV4ImageProcessor;w.MobileNetV4Model;w.MobileNetV4PreTrainedModel;w.MobileViTFeatureExtractor;w.MobileViTForImageClassification;w.MobileViTImageProcessor;w.MobileViTModel;w.MobileViTPreTrainedModel;w.MobileViTV2ForImageClassification;w.MobileViTV2Model;w.MobileViTV2PreTrainedModel;w.ModelOutput;w.ModernBertForMaskedLM;w.ModernBertForSequenceClassification;w.ModernBertForTokenClassification;w.ModernBertModel;w.ModernBertPreTrainedModel;w.Moondream1ForConditionalGeneration;w.MoonshineFeatureExtractor;w.MoonshineForConditionalGeneration;w.MoonshineModel;w.MoonshinePreTrainedModel;w.MoonshineProcessor;w.MptForCausalLM;w.MptModel;w.MptPreTrainedModel;w.MultiModalityCausalLM;w.MultiModalityPreTrainedModel;w.MusicgenForCausalLM;w.MusicgenForConditionalGeneration;w.MusicgenModel;w.MusicgenPreTrainedModel;w.NllbTokenizer;w.NoBadWordsLogitsProcessor;w.NoRepeatNGramLogitsProcessor;w.NomicBertModel;w.NomicBertPreTrainedModel;w.NougatImageProcessor;w.NougatTokenizer;w.OPTForCausalLM;w.OPTModel;w.OPTPreTrainedModel;w.ObjectDetectionPipeline;w.Olmo2ForCausalLM;w.Olmo2Model;w.Olmo2PreTrainedModel;w.OlmoForCausalLM;w.OlmoModel;w.OlmoPreTrainedModel;w.OpenELMForCausalLM;w.OpenELMModel;w.OpenELMPreTrainedModel;w.OwlViTFeatureExtractor;w.OwlViTForObjectDetection;w.OwlViTImageProcessor;w.OwlViTModel;w.OwlViTPreTrainedModel;w.OwlViTProcessor;w.Owlv2ForObjectDetection;w.Owlv2ImageProcessor;w.Owlv2Model;w.Owlv2PreTrainedModel;w.PaliGemmaForConditionalGeneration;w.PaliGemmaPreTrainedModel;w.PaliGemmaProcessor;w.PatchTSMixerForPrediction;w.PatchTSMixerModel;w.PatchTSMixerPreTrainedModel;w.PatchTSTForPrediction;w.PatchTSTModel;w.PatchTSTPreTrainedModel;w.Phi3ForCausalLM;w.Phi3Model;w.Phi3PreTrainedModel;w.Phi3VForCausalLM;w.Phi3VImageProcessor;w.Phi3VPreTrainedModel;w.Phi3VProcessor;w.PhiForCausalLM;w.PhiModel;w.PhiPreTrainedModel;w.Pipeline;w.PreTrainedModel;w.PreTrainedTokenizer;w.PretrainedConfig;w.PretrainedMixin;w.Processor;w.PvtForImageClassification;w.PvtImageProcessor;w.PvtModel;w.PvtPreTrainedModel;w.PyAnnoteFeatureExtractor;w.PyAnnoteForAudioFrameClassification;w.PyAnnoteModel;w.PyAnnotePreTrainedModel;w.PyAnnoteProcessor;w.QuestionAnsweringModelOutput;w.QuestionAnsweringPipeline;w.Qwen2ForCausalLM;w.Qwen2Model;w.Qwen2PreTrainedModel;w.Qwen2Tokenizer;w.Qwen2VLForConditionalGeneration;w.Qwen2VLImageProcessor;w.Qwen2VLPreTrainedModel;w.Qwen2VLProcessor;w.RFDetrForObjectDetection;w.RFDetrModel;w.RFDetrObjectDetectionOutput;w.RFDetrPreTrainedModel;w.RTDetrForObjectDetection;w.RTDetrImageProcessor;w.RTDetrModel;w.RTDetrObjectDetectionOutput;w.RTDetrPreTrainedModel;w.RTDetrV2ForObjectDetection;w.RTDetrV2Model;w.RTDetrV2ObjectDetectionOutput;w.RTDetrV2PreTrainedModel;w.RawAudio;w.RawImage;w.RawVideo;w.RawVideoFrame;w.RepetitionPenaltyLogitsProcessor;w.ResNetForImageClassification;w.ResNetModel;w.ResNetPreTrainedModel;w.RoFormerForMaskedLM;w.RoFormerForQuestionAnswering;w.RoFormerForSequenceClassification;w.RoFormerForTokenClassification;w.RoFormerModel;w.RoFormerPreTrainedModel;w.RoFormerTokenizer;w.RobertaForMaskedLM;w.RobertaForQuestionAnswering;w.RobertaForSequenceClassification;w.RobertaForTokenClassification;w.RobertaModel;w.RobertaPreTrainedModel;w.RobertaTokenizer;w.SamImageProcessor;w.SamImageSegmentationOutput;w.SamModel;w.SamPreTrainedModel;w.SamProcessor;w.SapiensForDepthEstimation;w.SapiensForNormalEstimation;w.SapiensForSemanticSegmentation;w.SapiensPreTrainedModel;w.SeamlessM4TFeatureExtractor;w.SegformerFeatureExtractor;w.SegformerForImageClassification;w.SegformerForSemanticSegmentation;w.SegformerImageProcessor;w.SegformerModel;w.SegformerPreTrainedModel;w.Seq2SeqLMOutput;w.SequenceClassifierOutput;w.SiglipImageProcessor;w.SiglipModel;w.SiglipPreTrainedModel;w.SiglipTextModel;w.SiglipTokenizer;w.SiglipVisionModel;w.SmolVLMForConditionalGeneration;w.SmolVLMImageProcessor;w.SmolVLMProcessor;w.SnacDecoderModel;w.SnacEncoderModel;w.SnacFeatureExtractor;w.SnacModel;w.SnacPreTrainedModel;w.SpeechT5FeatureExtractor;w.SpeechT5ForSpeechToText;w.SpeechT5ForTextToSpeech;w.SpeechT5HifiGan;w.SpeechT5Model;w.SpeechT5PreTrainedModel;w.SpeechT5Processor;w.SpeechT5Tokenizer;w.SqueezeBertForMaskedLM;w.SqueezeBertForQuestionAnswering;w.SqueezeBertForSequenceClassification;w.SqueezeBertModel;w.SqueezeBertPreTrainedModel;w.SqueezeBertTokenizer;w.StableLmForCausalLM;w.StableLmModel;w.StableLmPreTrainedModel;w.Starcoder2ForCausalLM;w.Starcoder2Model;w.Starcoder2PreTrainedModel;w.StoppingCriteria;w.StoppingCriteriaList;w.StyleTextToSpeech2Model;w.StyleTextToSpeech2PreTrainedModel;w.SummarizationPipeline;w.SuppressTokensAtBeginLogitsProcessor;w.Swin2SRForImageSuperResolution;w.Swin2SRImageProcessor;w.Swin2SRModel;w.Swin2SRPreTrainedModel;w.SwinForImageClassification;w.SwinForSemanticSegmentation;w.SwinModel;w.SwinPreTrainedModel;w.T5ForConditionalGeneration;w.T5Model;w.T5PreTrainedModel;w.T5Tokenizer;w.TableTransformerForObjectDetection;w.TableTransformerModel;w.TableTransformerObjectDetectionOutput;w.TableTransformerPreTrainedModel;w.TemperatureLogitsWarper;w.Tensor;w.Text2TextGenerationPipeline;w.TextClassificationPipeline;w.TextGenerationPipeline;w.TextStreamer;w.TextToAudioPipeline;w.TokenClassificationPipeline;w.TokenClassifierOutput;w.TokenizerModel;w.TopKLogitsWarper;w.TopPLogitsWarper;w.TrOCRForCausalLM;w.TrOCRPreTrainedModel;w.TranslationPipeline;w.UltravoxModel;w.UltravoxPreTrainedModel;w.UltravoxProcessor;w.UniSpeechForCTC;w.UniSpeechForSequenceClassification;w.UniSpeechModel;w.UniSpeechPreTrainedModel;w.UniSpeechSatForAudioFrameClassification;w.UniSpeechSatForCTC;w.UniSpeechSatForSequenceClassification;w.UniSpeechSatModel;w.UniSpeechSatPreTrainedModel;w.VLChatProcessor;w.VLMImageProcessor;w.ViTFeatureExtractor;w.ViTForImageClassification;w.ViTImageProcessor;w.ViTMAEModel;w.ViTMAEPreTrainedModel;w.ViTMSNForImageClassification;w.ViTMSNModel;w.ViTMSNPreTrainedModel;w.ViTModel;w.ViTPreTrainedModel;w.VisionEncoderDecoderModel;w.VitMatteForImageMatting;w.VitMatteImageProcessor;w.VitMattePreTrainedModel;w.VitPoseForPoseEstimation;w.VitPoseImageProcessor;w.VitPosePreTrainedModel;w.VitsModel;w.VitsModelOutput;w.VitsPreTrainedModel;w.VitsTokenizer;w.Wav2Vec2BertForCTC;w.Wav2Vec2BertForSequenceClassification;w.Wav2Vec2BertModel;w.Wav2Vec2BertPreTrainedModel;w.Wav2Vec2CTCTokenizer;w.Wav2Vec2FeatureExtractor;w.Wav2Vec2ForAudioFrameClassification;w.Wav2Vec2ForCTC;w.Wav2Vec2ForSequenceClassification;w.Wav2Vec2Model;w.Wav2Vec2PreTrainedModel;w.Wav2Vec2Processor;w.Wav2Vec2ProcessorWithLM;w.WavLMForAudioFrameClassification;w.WavLMForCTC;w.WavLMForSequenceClassification;w.WavLMForXVector;w.WavLMModel;w.WavLMPreTrainedModel;w.WeSpeakerFeatureExtractor;w.WeSpeakerResNetModel;w.WeSpeakerResNetPreTrainedModel;w.WhisperFeatureExtractor;w.WhisperForConditionalGeneration;w.WhisperModel;w.WhisperPreTrainedModel;w.WhisperProcessor;w.WhisperTextStreamer;w.WhisperTimeStampLogitsProcessor;w.WhisperTokenizer;w.XLMForQuestionAnswering;w.XLMForSequenceClassification;w.XLMForTokenClassification;w.XLMModel;w.XLMPreTrainedModel;w.XLMRobertaForMaskedLM;w.XLMRobertaForQuestionAnswering;w.XLMRobertaForSequenceClassification;w.XLMRobertaForTokenClassification;w.XLMRobertaModel;w.XLMRobertaPreTrainedModel;w.XLMRobertaTokenizer;w.XLMTokenizer;w.XLMWithLMHeadModel;w.XVectorOutput;w.YolosFeatureExtractor;w.YolosForObjectDetection;w.YolosImageProcessor;w.YolosModel;w.YolosObjectDetectionOutput;w.YolosPreTrainedModel;w.ZeroShotAudioClassificationPipeline;w.ZeroShotClassificationPipeline;w.ZeroShotImageClassificationPipeline;w.ZeroShotObjectDetectionPipeline;w.bankers_round;w.cat;w.cos_sim;w.dot;w.dynamic_time_warping;w.env;w.full;w.full_like;w.getKeyValueShapes;w.hamming;w.hanning;w.interpolate;w.interpolate_4d;w.interpolate_data;w.is_chinese_char;w.layer_norm;w.load_image;w.load_video;w.log_softmax;w.magnitude;w.matmul;w.max;w.mean;w.mean_pooling;w.medianFilter;w.mel_filter_bank;w.min;w.ones;w.ones_like;w.permute;w.permute_data;var GE=w.pipeline;w.quantize_embeddings;w.rand;var WE=w.read_audio;w.rfft;w.round;w.slice;w.softmax;w.spectrogram;w.stack;w.std_mean;w.topk;w.window_function;w.zeros;w.zeros_like;const HE=()=>{const[t,s]=ks.useState(null),[n,i]=ks.useState(!0),[l,o]=ks.useState(null),[c,p]=ks.useState({});return ks.useEffect(()=>{let d=!1;const f=_=>{if(!_.file)return;const y=_.file;let T=0;switch(_.status){case"progress":T=Math.round(_.progress);break;case"done":T=100;break;default:return}p(b=>b[y]===T?b:{...b,[y]:T})};(async()=>{try{const _=await GE("automatic-speech-recognition","Xenova/whisper-base",{dtype:"fp32",useWorker:!0,progress_callback:f});d||s(()=>_)}catch(_){o(_),console.error("❌ model load fail :",_)}finally{i(!1)}})()},[]),{pipe:t,loading:n,error:l,fileProgress:c}},KE=({onStop:t}={})=>{const[s,n]=ks.useState(!1),[i,l]=ks.useState("idle"),[o,c]=ks.useState(""),[p,d]=ks.useState(null),f=ks.useRef(null),g=ks.useRef(null),_=ks.useRef([]),y=ks.useRef([]);ks.useEffect(()=>()=>{var I;((I=g.current)==null?void 0:I.state)==="recording"&&g.current.stop(),f.current&&(f.current.getTracks().forEach(O=>O.stop()),f.current=null),p&&URL.revokeObjectURL(p)},[p]);const T=async()=>{c("Requesting microphone permission..."),l("requesting");try{const I=await navigator.mediaDevices.getUserMedia({audio:!0});return f.current=I,l("granted"),c("Permission granted."),!0}catch(I){return console.error("Mic permission error:",I),l("denied"),c("Microphone permission denied."),!1}},b=I=>{I.data.size>0&&_.current.push(I.data)},k=()=>{const I=new Blob(_.current,{type:"audio/webm"});if(_.current=[],I.size>1024&&(t&&t(I),y.current.push(I)),s&&f.current){const O=new MediaRecorder(f.current);O.ondataavailable=b,O.onstop=k,O.onerror=L,g.current=O,O.start()}},L=I=>{console.error("Recording error:",I),c(`Recording error: ${I.error.message}`),n(!1),l("error")};return{isRecording:s,permissionStatus:i,statusMessage:o,startRecording:async()=>{if(s||!await T()||!f.current)return;c("Recording..."),n(!0),_.current=[],y.current=[];const O=new MediaRecorder(f.current);O.ondataavailable=b,O.onstop=k,O.onerror=L,g.current=O,O.start()},stopRecording:()=>{var I;if(((I=g.current)==null?void 0:I.state)==="recording"&&(c("Stopping recording..."),g.current.stop()),n(!1),f.current&&(f.current.getTracks().forEach(O=>O.stop()),f.current=null),y.current.length>0){const O=new Blob(y.current,{type:"audio/webm"}),x=URL.createObjectURL(O);d(x),y.current=[]}},fullRecordingUrl:p}},qE=({name:t,progress:s})=>Wn.jsxs("div",{className:"mb-3 w-4/5 max-w-[450px]",children:[Wn.jsx("div",{className:"mb-1 overflow-hidden text-sm text-ellipsis whitespace-nowrap text-zinc-200",title:t,children:(t==null?void 0:t.split("/").pop())||t}),Wn.jsx("div",{className:"h-2.5 overflow-hidden rounded bg-zinc-600",children:Wn.jsx("div",{className:"transition-width h-full rounded bg-green-400 duration-200 ease-out",style:{width:`${s}%`}})}),Wn.jsxs("div",{className:"mt-0.5 text-right text-xs text-zinc-400",children:[s,"%"]})]}),QE=()=>{const[t,s]=ks.useState(null),{pipe:n,fileProgress:i}=HE(),{isRecording:l,permissionStatus:o,statusMessage:c,startRecording:p,stopRecording:d,recordingUrl:f}=KE({onStop:async _=>{try{const y=URL.createObjectURL(_),T=await WE(y,16e3),b=await n(T);s(b.text),URL.revokeObjectURL(y)}catch(y){console.error("Transcription failed:",y)}}}),g=Object.entries(i||{});return Wn.jsx("div",{className:"aspect-4/3 h-8/12 max-w-3xl rounded-2xl bg-linear-to-br from-zinc-800 to-zinc-900 p-8 text-zinc-300",children:n?Wn.jsxs("div",{className:"flex h-full w-full flex-col items-center justify-center gap-8",children:[Wn.jsx("h1",{className:"text-2xl font-bold",children:"Model loaded: Xenova/whisper-base"}),c&&Wn.jsxs("p",{className:"text-lg font-medium",children:["Status: ",c]}),Wn.jsxs("div",{className:"flex w-full items-center justify-evenly",children:[Wn.jsx("button",{className:`rounded-full px-6 py-3 font-bold transition-colors duration-200 ${l||o==="denied"||o==="requesting"?"cursor-not-allowed bg-gray-600 text-gray-400":"cursor-pointer bg-green-700 text-white hover:bg-green-600 active:bg-green-800"}`,onClick:p,disabled:l||o==="denied"||o==="requesting",children:"Start Recording"}),Wn.jsx("button",{onClick:d,className:`rounded-full px-6 py-3 font-bold transition-colors duration-200 ${l?"cursor-pointer bg-red-700 text-white hover:bg-red-600 active:bg-red-800":"cursor-not-allowed bg-gray-600 text-gray-400"}`,disabled:!l,children:"Stop Recording"})]}),f&&Wn.jsxs("div",{className:"mt-4 w-full max-w-xl",children:[Wn.jsx("h3",{className:"mb-1 text-sm font-semibold",children:"Playback Recording:"}),Wn.jsx("audio",{controls:!0,preload:"metadata",src:f,className:"w-full",children:"Your browser does not support the audio element."})]}),t&&Wn.jsxs("div",{className:"mt-4 w-full max-w-xl rounded bg-zinc-700 p-4 text-sm",children:[Wn.jsx("h3",{className:"mb-2 font-semibold",children:"Transcript:"}),Wn.jsx("p",{className:"whitespace-pre-wrap",children:t})]})]}):Wn.jsxs("div",{className:"flex h-full w-full flex-col items-center justify-center gap-8",children:[Wn.jsx("h1",{className:"text-2xl font-bold",children:"Loading Whisper Model in Browser"}),g.map(([_,y])=>Wn.jsx(qE,{name:_,progress:y},_))]})})},XE=()=>Wn.jsx(ex,{children:Wn.jsx(QE,{})});JT.createRoot(document.getElementById("root")).render(Wn.jsx(XE,{}));
